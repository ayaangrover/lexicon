function _checkInRHS(e) { if (Object(e) !== e) throw TypeError("right-hand side of 'in' should be an object, got " + (null !== e ? typeof e : "null")); return e; }
function _classPrivateGetter(s, r, a) { return a(_assertClassBrand(s, r)); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = {  }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var Puppeteer = function (exports, _PuppeteerURL, _LazyArg, _ARIAQueryHandler, _mutex2, _onRelease) {
  'use strict';

  
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      
    } instanceof Array && function (d2, b2) {
      
    } || function (d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
      f,
      y,
      t,
      g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;
    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function () {
        if (o && i >= o.length) o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
      r,
      ar = [],
      e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = {
        error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () {
      return this;
    }, i;
    function awaitReturn(f) {
      return function (v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function (v) {
          return new Promise(function (a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator],
      i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function (v) {
        return new Promise(function (resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v2) {
        resolve({
          value: v2,
          done: d
        });
      }, reject);
    }
  }

  
  function isFunction(value) {
    return typeof value === "function";
  }

  
  function createErrorClass(createImpl) {
    var _super = function (instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }

  
  var UnsubscriptionError = createErrorClass(function (_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });

  
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }

  
  var Subscription = function () {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function () {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = {
                error: e_1_1
              };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = {
              error: e_2_1
            };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription2.prototype.add = function (teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function (parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function (parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function (parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function (teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function () {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }

  
  var config = {
    Promise: void 0
  };

  
  var timeoutProvider = {
    setTimeout: function (handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function (handle) {
      return clearTimeout(handle);
    },
    delegate: void 0
  };

  
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function () {
      {
        throw err;
      }
    });
  }

  
  function noop() {}
  function errorContext(cb) {
    {
      cb();
    }
  }

  
  var Subscriber = function (_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function (next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function (value) {
      if (this.isStopped) ;else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function (err) {
      if (this.isStopped) ;else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function () {
      if (this.isStopped) ;else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function () {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function (value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function (err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function () {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription);
  var ConsumerObserver = function () {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function (value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function (err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function () {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function (_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  function handleUnhandledError(error) {
    {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop
  };

  
  var observable = function () {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();

  
  function identity(x) {
    return x;
  }

  
  function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  }
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function (prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  
  var Observable = function () {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function (operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function (observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function () {
        var _a = _this,
          operator = _a.operator,
          source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function (sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function (next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function (resolve, reject) {
        var subscriber = new SafeSubscriber({
          next: function (value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function (subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function () {
      return this;
    };
    Observable2.prototype.pipe = function () {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function (promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function (resolve, reject) {
        var value;
        _this.subscribe(function (x) {
          return value = x;
        }, function (err) {
          return reject(err);
        }, function () {
          return resolve(value);
        });
      });
    };
    Observable2.create = function (subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }

  
  function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init) {
    return function (source) {
      if (hasLift(source)) {
        return source.lift(function (liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }

  
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber = function (_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function (value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function (err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function () {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function () {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber);

  
  var ObjectUnsubscribedError = createErrorClass(function (_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });

  
  var Subject = function (_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function (operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function () {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function (value) {
      var _this = this;
      errorContext(function () {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function (err) {
      var _this = this;
      errorContext(function () {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function () {
      var _this = this;
      errorContext(function () {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function () {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function () {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function (subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function (subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function (subscriber) {
      var _this = this;
      var _a = this,
        hasError = _a.hasError,
        isStopped = _a.isStopped,
        observers = _a.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function () {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function (subscriber) {
      var _a = this,
        hasError = _a.hasError,
        thrownError = _a.thrownError,
        isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function () {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function (destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = function (_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function (value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function (err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function () {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function (subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);

  
  var dateTimestampProvider = {
    now: function () {
      return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0
  };

  
  var ReplaySubject = function (_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === void 0) {
        _bufferSize = Infinity;
      }
      if (_windowTime === void 0) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === void 0) {
        _timestampProvider = dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function (value) {
      var _a = this,
        isStopped = _a.isStopped,
        _buffer = _a._buffer,
        _infiniteTimeWindow = _a._infiniteTimeWindow,
        _timestampProvider = _a._timestampProvider,
        _windowTime = _a._windowTime;
      if (!isStopped) {
        _buffer.push(value);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function (subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a = this,
        _infiniteTimeWindow = _a._infiniteTimeWindow,
        _buffer = _a._buffer;
      var copy = _buffer.slice();
      for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function () {
      var _a = this,
        _bufferSize = _a._bufferSize,
        _timestampProvider = _a._timestampProvider,
        _buffer = _a._buffer,
        _infiniteTimeWindow = _a._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last2 = 0;
        for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
          last2 = i;
        }
        last2 && _buffer.splice(0, last2 + 1);
      }
    };
    return ReplaySubject2;
  }(Subject);

  
  var Action = function (_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function (state, delay2) {
      return this;
    };
    return Action2;
  }(Subscription);

  
  var intervalProvider = {
    setInterval: function (handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearInterval: function (handle) {
      return clearInterval(handle);
    },
    delegate: void 0
  };

  
  var AsyncAction = function (_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function (state, delay2) {
      var _a;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay2);
      }
      this.pending = true;
      this.delay = delay2;
      this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function (scheduler, _id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
    };
    AsyncAction2.prototype.recycleAsyncId = function (_scheduler, id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null && this.delay === delay2 && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider.clearInterval(id);
      }
      return void 0;
    };
    AsyncAction2.prototype.execute = function (state, delay2) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state, delay2);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function (state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function () {
      if (!this.closed) {
        var _a = this,
          id = _a.id,
          scheduler = _a.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action);

  
  var Scheduler = function () {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === void 0) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function (work, delay2, state) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay2);
    };
    Scheduler2.now = dateTimestampProvider.now;
    return Scheduler2;
  }();

  
  var AsyncScheduler = function (_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function (action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error;
      this._active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler);

  
  var asyncScheduler = new AsyncScheduler(AsyncAction);
  var async = asyncScheduler;

  
  var EMPTY = new Observable(function (subscriber) {
    return subscriber.complete();
  });

  
  function isScheduler(value) {
    return value && isFunction(value.schedule);
  }

  
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
  }
  function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  }

  
  var isArrayLike = function (x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };

  
  function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }

  
  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }

  
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }

  
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }

  
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();

  
  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }

  
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1,, 9, 10]);
            _b.label = 2;
          case 2:
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done) return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }

  
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function (subscriber) {
      var obs = obj[observable]();
      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array) {
    return new Observable(function (subscriber) {
      for (var i = 0; i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise) {
    return new Observable(function (subscriber) {
      promise.then(function (value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function (err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function (subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function (subscriber) {
      process$1(asyncIterable, subscriber).catch(function (err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process$1(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function () {
      var value, e_2_1;
      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = {
              error: e_2_1
            };
            return [3, 11];
          case 6:
            _b.trys.push([6,, 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2) throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }

  
  function executeSchedule(parentSubscription, scheduler, work, delay2, repeat) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (repeat === void 0) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function () {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay2));
      } else {
        this.unsubscribe();
      }
    }, delay2);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }

  
  function observeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function (source, subscriber) {
      source.subscribe(createOperatorSubscriber(subscriber, function (value) {
        return executeSchedule(subscriber, scheduler, function () {
          return subscriber.next(value);
        }, delay2);
      }, function () {
        return executeSchedule(subscriber, scheduler, function () {
          return subscriber.complete();
        }, delay2);
      }, function (err) {
        return executeSchedule(subscriber, scheduler, function () {
          return subscriber.error(err);
        }, delay2);
      }));
    });
  }

  
  function subscribeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function (source, subscriber) {
      subscriber.add(scheduler.schedule(function () {
        return source.subscribe(subscriber);
      }, delay2));
    });
  }

  
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  
  function scheduleArray(input, scheduler) {
    return new Observable(function (subscriber) {
      var i = 0;
      return scheduler.schedule(function () {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }

  
  function scheduleIterable(input, scheduler) {
    return new Observable(function (subscriber) {
      var iterator2;
      executeSchedule(subscriber, scheduler, function () {
        iterator2 = input[iterator]();
        executeSchedule(subscriber, scheduler, function () {
          var _a;
          var value;
          var done;
          try {
            _a = iterator2.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function () {
        return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
      };
    });
  }

  
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function (subscriber) {
      executeSchedule(subscriber, scheduler, function () {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function () {
          iterator2.next().then(function (result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }

  
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }

  
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }

  
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }

  
  function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
  }

  
  var EmptyError = createErrorClass(function (_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });

  
  function firstValueFrom(source, config2) {
    return new Promise(function (resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function (value) {
          resolve(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function () {
          {
            reject(new EmptyError());
          }
        }
      });
      source.subscribe(subscriber);
    });
  }

  
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }

  
  function map(project, thisArg) {
    return operate(function (source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function (value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }

  
  var isArray = Array.isArray;
  function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
    return map(function (args) {
      return callOrApply(fn, args);
    });
  }

  
  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function () {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function (value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function (value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function () {
        innerComplete = true;
      }, void 0, function () {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function () {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) ;else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {
      isComplete = true;
      checkComplete();
    }));
    return function () {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }

  
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction(resultSelector)) {
      return mergeMap(function (a, i) {
        return map(function (b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate(function (source, subscriber) {
      return mergeInternals(source, subscriber, project, concurrent);
    });
  }

  
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap(identity, concurrent);
  }

  
  function concatAll() {
    return mergeAll(1);
  }

  
  function concat() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll()(from(args, popScheduler(args)));
  }

  
  function defer(observableFactory) {
    return new Observable(function (subscriber) {
      innerFrom(observableFactory()).subscribe(subscriber);
    });
  }

  
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
      resultSelector = options;
      options = void 0;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
    }
    var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function (methodName) {
        return function (handler) {
          return target[methodName](eventName, handler, options);
        };
      }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2),
      add = _a[0],
      remove = _a[1];
    if (!add) {
      if (isArrayLike(target)) {
        return mergeMap(function (subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable(function (subscriber) {
      var handler = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function () {
        return remove(handler);
      };
    });
  }
  function toCommonHandlerRegistry(target, eventName) {
    return function (methodName) {
      return function (handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction(target.addListener) && isFunction(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction(target.on) && isFunction(target.off);
  }
  function isEventTarget(target) {
    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
  }

  
  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === void 0) {
      dueTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = async;
    }
    return new Observable(function (subscriber) {
      var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function () {
        if (!subscriber.closed) {
          subscriber.next(n++);
          {
            subscriber.complete();
          }
        }
      }, due);
    });
  }

  
  function merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
  }

  
  var NEVER = new Observable(noop);

  
  var isArray3 = Array.isArray;
  function argsOrArgArray(args) {
    return args.length === 1 && isArray3(args[0]) ? args[0] : args;
  }

  
  function filter(predicate, thisArg) {
    return operate(function (source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function (value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }

  
  function race() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    sources = argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
  }
  function raceInit(sources) {
    return function (subscriber) {
      var subscriptions = [];
      var _loop_1 = function (i2) {
        subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function (value) {
          if (subscriptions) {
            for (var s = 0; s < subscriptions.length; s++) {
              s !== i2 && subscriptions[s].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value);
        })));
      };
      for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
        _loop_1(i);
      }
    };
  }

  
  function catchError(selector) {
    return operate(function (source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function (err) {
        handledResult = innerFrom(selector(err, catchError(selector)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }

  
  function defaultIfEmpty(defaultValue) {
    return operate(function (source, subscriber) {
      var hasValue = false;
      source.subscribe(createOperatorSubscriber(subscriber, function (value) {
        hasValue = true;
        subscriber.next(value);
      }, function () {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }

  
  function take(count) {
    return count <= 0 ? function () {
      return EMPTY;
    } : operate(function (source, subscriber) {
      var seen = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function (value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }

  
  function ignoreElements() {
    return operate(function (source, subscriber) {
      source.subscribe(createOperatorSubscriber(subscriber, noop));
    });
  }

  
  function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return operate(function (source, subscriber) {
      var hasValue = false;
      source.subscribe(createOperatorSubscriber(subscriber, function (value) {
        hasValue = true;
        subscriber.next(value);
      }, function () {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  function defaultErrorFactory() {
    return new EmptyError();
  }

  
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) {
      return source.pipe(predicate ? filter(function (v, i) {
        return predicate(v, i, source);
      }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () {
        return new EmptyError();
      }));
    };
  }

  
  function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return operate(function (source, subscriber) {
      var state = seed;
      return mergeInternals(source, subscriber, function (value, index) {
        return accumulator(state, value, index);
      }, concurrent, function (value) {
        state = value;
      }, false, void 0, function () {
        return state = null;
      });
    });
  }

  
  function raceWith() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return !otherSources.length ? identity : operate(function (source, subscriber) {
      raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
    });
  }

  
  function retry(configOrCount) {
    if (configOrCount === void 0) {
      configOrCount = Infinity;
    }
    var config2;
    if (configOrCount && typeof configOrCount === "object") {
      config2 = configOrCount;
    } else {
      config2 = {
        count: configOrCount
      };
    }
    var _a = config2.count,
      count = _a === void 0 ? Infinity : _a,
      delay2 = config2.delay,
      _b = config2.resetOnSuccess,
      resetOnSuccess = _b === void 0 ? false : _b;
    return count <= 0 ? identity : operate(function (source, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function () {
        var syncUnsub = false;
        innerSub = source.subscribe(createOperatorSubscriber(subscriber, function (value) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value);
        }, void 0, function (err) {
          if (soFar++ < count) {
            var resub_1 = function () {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay2 != null) {
              var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
              var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function () {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function () {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  }

  
  function startWith() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler = popScheduler(values);
    return operate(function (source, subscriber) {
      (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
    });
  }

  
  function switchMap(project, resultSelector) {
    return operate(function (source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function () {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(createOperatorSubscriber(subscriber, function (value) {
        innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function (innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function () {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function () {
        isComplete = true;
        checkComplete();
      }));
    });
  }

  
  function takeUntil(notifier) {
    return operate(function (source, subscriber) {
      innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function () {
        return subscriber.complete();
      }, noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }

  
  function tap(observerOrNext, error, complete) {
    var tapObserver = isFunction(observerOrNext) || error || complete ? {
      next: observerOrNext,
      error,
      complete
    } : observerOrNext;
    return tapObserver ? operate(function (source, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(createOperatorSubscriber(subscriber, function (value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function () {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        subscriber.complete();
      }, function (err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function () {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity;
  }

  
  function mitt_default(n) {
    return {
  Symbol.dispose ??= Symbol('dispose');
  Symbol.asyncDispose ??= Symbol('asyncDispose');
  const disposeSymbol = Symbol.dispose;
  const asyncDisposeSymbol = Symbol.asyncDispose;
  class DisposableStack {
    constructor() {
      _classPrivateFieldInitSpec(this, _disposed, false);
      _classPrivateFieldInitSpec(this, _stack, []);
      _defineProperty(this, disposeSymbol, this.dispose);
      _defineProperty(this, Symbol.toStringTag, 'DisposableStack');
    }
    get disposed() {
      return _classPrivateFieldGet(_disposed, this);
    }
    dispose() {
      if (_classPrivateFieldGet(_disposed, this)) {
        return;
      }
      _classPrivateFieldSet(_disposed, this, true);
      for (const resource of _classPrivateFieldGet(_stack, this).reverse()) {
        resource[disposeSymbol]();
      }
    }
    use(value) {
      if (value) {
        _classPrivateFieldGet(_stack, this).push(value);
      }
      return value;
    }
    adopt(value, onDispose) {
      _classPrivateFieldGet(_stack, this).push({
        [disposeSymbol]() {
          onDispose(value);
        }
      });
      return value;
    }
    defer(onDispose) {
      _classPrivateFieldGet(_stack, this).push({
        [disposeSymbol]() {
          onDispose();
        }
      });
    }
    move() {
      if (_classPrivateFieldGet(_disposed, this)) {
        throw new ReferenceError('a disposed stack can not use anything new'); 
      }
      const stack = new DisposableStack(); 
      _classPrivateFieldSet(_stack, stack, _classPrivateFieldGet(_stack, this));
      _classPrivateFieldSet(_disposed, this, true);
      return stack;
    }
  }
  class AsyncDisposableStack {
    constructor() {
      _classPrivateFieldInitSpec(this, _disposed2, false);
      _classPrivateFieldInitSpec(this, _stack2, []);
      _defineProperty(this, asyncDisposeSymbol, this.dispose);
      _defineProperty(this, Symbol.toStringTag, 'AsyncDisposableStack');
    }
    get disposed() {
      return _classPrivateFieldGet(_disposed2, this);
    }
    async dispose() {
      if (_classPrivateFieldGet(_disposed2, this)) {
        return;
      }
      _classPrivateFieldSet(_disposed2, this, true);
      for (const resource of _classPrivateFieldGet(_stack2, this).reverse()) {
        await resource[asyncDisposeSymbol]();
      }
    }
    use(value) {
      if (value) {
        _classPrivateFieldGet(_stack2, this).push(value);
      }
      return value;
    }
    adopt(value, onDispose) {
      _classPrivateFieldGet(_stack2, this).push({
        [asyncDisposeSymbol]() {
          return onDispose(value);
        }
      });
      return value;
    }
    defer(onDispose) {
      _classPrivateFieldGet(_stack2, this).push({
        [asyncDisposeSymbol]() {
          return onDispose();
        }
      });
    }
    move() {
      if (_classPrivateFieldGet(_disposed2, this)) {
        throw new ReferenceError('a disposed stack can not use anything new'); 
      }
      const stack = new AsyncDisposableStack(); 
      _classPrivateFieldSet(_stack2, stack, _classPrivateFieldGet(_stack2, this));
      _classPrivateFieldSet(_disposed2, this, true);
      return stack;
    }
  }

  class EventEmitter {
    constructor(emitter = mitt_default(new Map())) {
      _classPrivateFieldInitSpec(this, _emitter, void 0);
      _classPrivateFieldInitSpec(this, _handlers, new Map());
      _classPrivateFieldSet(_emitter, this, emitter);
    }
    on(type, handler) {
      const handlers = _classPrivateFieldGet(_handlers, this).get(type);
      if (handlers === undefined) {
        _classPrivateFieldGet(_handlers, this).set(type, [handler]);
      } else {
        handlers.push(handler);
      }
      _classPrivateFieldGet(_emitter, this).on(type, handler);
      return this;
    }
    off(type, handler) {
      const handlers = _classPrivateFieldGet(_handlers, this).get(type) ?? [];
      if (handler === undefined) {
        for (const handler of handlers) {
          _classPrivateFieldGet(_emitter, this).off(type, handler);
        }
        _classPrivateFieldGet(_handlers, this).delete(type);
        return this;
      }
      const index = handlers.lastIndexOf(handler);
      if (index > -1) {
        _classPrivateFieldGet(_emitter, this).off(type, ...handlers.splice(index, 1));
      }
      return this;
    }
    emit(type, event) {
      _classPrivateFieldGet(_emitter, this).emit(type, event);
      return this.listenerCount(type) > 0;
    }
    once(type, handler) {
      const onceHandler = eventData => {
        handler(eventData);
        this.off(type, onceHandler);
      };
      return this.on(type, onceHandler);
    }
    listenerCount(type) {
      return _classPrivateFieldGet(_handlers, this).get(type)?.length || 0;
    }
    removeAllListeners(type) {
      if (type !== undefined) {
        return this.off(type);
      }
      this[disposeSymbol]();
      return this;
    }
    [disposeSymbol]() {
      for (const [type, handlers] of _classPrivateFieldGet(_handlers, this)) {
        for (const handler of handlers) {
          _classPrivateFieldGet(_emitter, this).off(type, handler);
        }
      }
      _classPrivateFieldGet(_handlers, this).clear();
    }
  }

  const isNode = !!(typeof process !== 'undefined' && process.version);
  const environment = {
    value: {
      get fs() {
        throw new Error('fs is not available in this environment');
      },
      get ScreenRecorder() {
        throw new Error('ScreenRecorder is not available in this environment');
      }
    }
  };

  const packageVersion = '24.4.0';

  const assert = (value, message) => {
    if (!value) {
      throw new Error(message);
    }
  };

  function stringToTypedArray(string, base64Encoded = false) {
    if (base64Encoded) {
      const binaryString = atob(string);
      
      return Uint8Array.from(binaryString, m => {
        return m.codePointAt(0);
      });
    }
    return new TextEncoder().encode(string);
  }
  function stringToBase64(str) {
    return typedArrayToBase64(new TextEncoder().encode(str));
  }
  function typedArrayToBase64(typedArray) {
    
    
    const chunkSize = 65534;
    const chunks = [];
    for (let i = 0; i < typedArray.length; i += chunkSize) {
      const chunk = typedArray.subarray(i, i + chunkSize);
      chunks.push(String.fromCodePoint.apply(null, chunk));
    }
    const binaryString = chunks.join('');
    return btoa(binaryString);
  }
  function mergeUint8Arrays(items) {
    let length = 0;
    for (const item of items) {
      length += item.length;
    }
    
    const result = new Uint8Array(length);
    let offset = 0;
    for (const item of items) {
      result.set(item, offset);
      offset += item.length;
    }
    return result;
  }

  let debugModule = null;
  async function importDebug() {
    if (!debugModule) {
      debugModule = (await Promise.resolve().then(() => _interopRequireWildcard(require('debug')))).default;
    }
    return debugModule;
  }
  const debug = prefix => {
    if (isNode) {
      return async (...logArgs) => {
        if (captureLogs) {
          capturedLogs.push(prefix + logArgs);
        }
        (await importDebug())(prefix)(logArgs);
      };
    }
    return (...logArgs) => {
      const debugLevel = globalThis.__PUPPETEER_DEBUG;
      if (!debugLevel) {
        return;
      }
      const everythingShouldBeLogged = debugLevel === '*';
      const prefixMatchesDebugLevel = everythingShouldBeLogged || (
      debugLevel.endsWith('*') ? prefix.startsWith(debugLevel) : prefix === debugLevel);
      if (!prefixMatchesDebugLevel) {
        return;
      }
      console.log(`${prefix}:`, ...logArgs);
    };
  };
  let capturedLogs = [];
  let captureLogs = false;
  function setLogCapture(value) {
    capturedLogs = [];
    captureLogs = value;
  }
  function getCapturedLogs() {
    return capturedLogs;
  }

  class PuppeteerError extends Error {
    constructor(message, options) {
      super(message, options);
      this.name = this.constructor.name;
    }
    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
  }
  class TimeoutError extends PuppeteerError {}
  class TouchError extends PuppeteerError {}
  class ProtocolError extends PuppeteerError {
    constructor(...args) {
      super(...args);
      _classPrivateFieldInitSpec(this, _code, void 0);
      _classPrivateFieldInitSpec(this, _originalMessage, '');
    }
    set code(code) {
      _classPrivateFieldSet(_code, this, code);
    }
    get code() {
      return _classPrivateFieldGet(_code, this);
    }
    set originalMessage(originalMessage) {
      _classPrivateFieldSet(_originalMessage, this, originalMessage);
    }
    get originalMessage() {
      return _classPrivateFieldGet(_originalMessage, this);
    }
  }
  class UnsupportedOperation extends PuppeteerError {}
  class TargetCloseError extends ProtocolError {}

  const paperFormats = {
    letter: {
      cm: {
        width: 21.59,
        height: 27.94
      },
      in: {
        width: 8.5,
        height: 11
      }
    },
    legal: {
      cm: {
        width: 21.59,
        height: 35.56
      },
      in: {
        width: 8.5,
        height: 14
      }
    },
    tabloid: {
      cm: {
        width: 27.94,
        height: 43.18
      },
      in: {
        width: 11,
        height: 17
      }
    },
    ledger: {
      cm: {
        width: 43.18,
        height: 27.94
      },
      in: {
        width: 17,
        height: 11
      }
    },
    a0: {
      cm: {
        width: 84.1,
        height: 118.9
      },
      in: {
        width: 33.1102,
        height: 46.811
      }
    },
    a1: {
      cm: {
        width: 59.4,
        height: 84.1
      },
      in: {
        width: 23.3858,
        height: 33.1102
      }
    },
    a2: {
      cm: {
        width: 42,
        height: 59.4
      },
      in: {
        width: 16.5354,
        height: 23.3858
      }
    },
    a3: {
      cm: {
        width: 29.7,
        height: 42
      },
      in: {
        width: 11.6929,
        height: 16.5354
      }
    },
    a4: {
      cm: {
        width: 21,
        height: 29.7
      },
      in: {
        width: 8.2677,
        height: 11.6929
      }
    },
    a5: {
      cm: {
        width: 14.8,
        height: 21
      },
      in: {
        width: 5.8268,
        height: 8.2677
      }
    },
    a6: {
      cm: {
        width: 10.5,
        height: 14.8
      },
      in: {
        width: 4.1339,
        height: 5.8268
      }
    }
  };

  const debugError = debug('puppeteer:error');
  const DEFAULT_VIEWPORT = Object.freeze({
    width: 800,
    height: 600
  });
  const SOURCE_URL = Symbol('Source URL for Puppeteer evaluation scripts');
  class PuppeteerURL {
    constructor() {
      _classPrivateFieldInitSpec(this, _functionName, void 0);
      _classPrivateFieldInitSpec(this, _siteString, void 0);
    }
    static fromCallSite(functionName, site) {
      const url = new PuppeteerURL();
      _classPrivateFieldSet(_functionName, url, functionName);
      _classPrivateFieldSet(_siteString, url, site.toString());
      return url;
    }
    get functionName() {
      return _classPrivateFieldGet(_functionName, this);
    }
    get siteString() {
      return _classPrivateFieldGet(_siteString, this);
    }
    toString() {
      return `pptr:${[_classPrivateFieldGet(_functionName, this), encodeURIComponent(_classPrivateFieldGet(_siteString, this))].join(';')}`;
    }
  }
  _PuppeteerURL = PuppeteerURL;
  _defineProperty(PuppeteerURL, "INTERNAL_URL", 'pptr:internal');
  _defineProperty(PuppeteerURL, "parse", url => {
    url = url.slice('pptr:'.length);
    const [functionName = '', siteString = ''] = url.split(';');
    const puppeteerUrl = new _PuppeteerURL();
    _classPrivateFieldSet(_functionName, puppeteerUrl, functionName);
    _classPrivateFieldSet(_siteString, puppeteerUrl, decodeURIComponent(siteString));
    return puppeteerUrl;
  });
  _defineProperty(PuppeteerURL, "isPuppeteerURL", url => {
    return url.startsWith('pptr:');
  });
  const withSourcePuppeteerURLIfNone = (functionName, object) => {
    if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
      return object;
    }
    const original = Error.prepareStackTrace;
    Error.prepareStackTrace = (_, stack) => {
      
      
      
      
      return stack[2];
    };
    const site = new Error().stack;
    Error.prepareStackTrace = original;
    return Object.assign(object, {
      [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site)
    });
  };
  const getSourcePuppeteerURLIfAvailable = object => {
    if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
      return object[SOURCE_URL];
    }
    return undefined;
  };
  const isString = obj => {
    return typeof obj === 'string' || obj instanceof String;
  };
  const isNumber = obj => {
    return typeof obj === 'number' || obj instanceof Number;
  };
  const isPlainObject = obj => {
    return typeof obj === 'object' && obj?.constructor === Object;
  };
  const isRegExp = obj => {
    return typeof obj === 'object' && obj?.constructor === RegExp;
  };
  const isDate = obj => {
    return typeof obj === 'object' && obj?.constructor === Date;
  };
  function evaluationString(
  
  fun, ...args) {
    if (isString(fun)) {
      assert(args.length === 0, 'Cannot evaluate a string with arguments');
      return fun;
    }
    function serializeArgument(arg) {
      if (Object.is(arg, undefined)) {
        return 'undefined';
      }
      return JSON.stringify(arg);
    }
    return `(${fun})(${args.map(serializeArgument).join(',')})`;
  }
  async function getReadableAsTypedArray(readable, path) {
    const buffers = [];
    const reader = readable.getReader();
    if (path) {
      const fileHandle = await environment.value.fs.promises.open(path, 'w+');
      try {
        while (true) {
          const {
            done,
            value
          } = await reader.read();
          if (done) {
            break;
          }
          buffers.push(value);
          await fileHandle.writeFile(value);
        }
      } finally {
        await fileHandle.close();
      }
    } else {
      while (true) {
        const {
          done,
          value
        } = await reader.read();
        if (done) {
          break;
        }
        buffers.push(value);
      }
    }
    try {
      const concat = mergeUint8Arrays(buffers);
      if (concat.length === 0) {
        return null;
      }
      return concat;
    } catch (error) {
      debugError(error);
      return null;
    }
  }
  async function getReadableFromProtocolStream(client, handle) {
    return new ReadableStream({
      async pull(controller) {
        function getUnit8Array(data, isBase64) {
          if (isBase64) {
            return Uint8Array.from(atob(data), m => {
              return m.codePointAt(0);
            });
          }
          const encoder = new TextEncoder();
          return encoder.encode(data);
        }
        const {
          data,
          base64Encoded,
          eof
        } = await client.send('IO.read', {
          handle
        });
        controller.enqueue(getUnit8Array(data, base64Encoded ?? false));
        if (eof) {
          await client.send('IO.close', {
            handle
          });
          controller.close();
        }
      }
    });
  }
  function validateDialogType(type) {
    let dialogType = null;
    const validDialogTypes = new Set(['alert', 'confirm', 'prompt', 'beforeunload']);
    if (validDialogTypes.has(type)) {
      dialogType = type;
    }
    assert(dialogType, `Unknown javascript dialog type: ${type}`);
    return dialogType;
  }
  function timeout(ms, cause) {
    return ms === 0 ? NEVER : timer(ms).pipe(map(() => {
      throw new TimeoutError(`Timed out after waiting ${ms}ms`, {
        cause
      });
    }));
  }
  const UTILITY_WORLD_NAME = '__puppeteer_utility_world__' + packageVersion;
  const SOURCE_URL_REGEX = /^[\x20\t]*\/\/[@#] sourceURL=\s{0,10}(\S*?)\s{0,10}$/m;
  function getSourceUrlComment(url) {
    return `
  }
  const NETWORK_IDLE_TIME = 500;
  function parsePDFOptions(options = {}, lengthUnit = 'in') {
    const defaults = {
      scale: 1,
      displayHeaderFooter: false,
      headerTemplate: '',
      footerTemplate: '',
      printBackground: false,
      landscape: false,
      pageRanges: '',
      preferCSSPageSize: false,
      omitBackground: false,
      outline: false,
      tagged: true,
      waitForFonts: true
    };
    let width = 8.5;
    let height = 11;
    if (options.format) {
      const format = paperFormats[options.format.toLowerCase()][lengthUnit];
      assert(format, 'Unknown paper format: ' + options.format);
      width = format.width;
      height = format.height;
    } else {
      width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;
      height = convertPrintParameterToInches(options.height, lengthUnit) ?? height;
    }
    const margin = {
      top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,
      left: convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,
      bottom: convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,
      right: convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0
    };
    
    if (options.outline) {
      options.tagged = true;
    }
    return {
      ...defaults,
      ...options,
      width,
      height,
      margin
    };
  }
  const unitToPixels = {
    px: 1,
    in: 96,
    cm: 37.8,
    mm: 3.78
  };
  function convertPrintParameterToInches(parameter, lengthUnit = 'in') {
    if (typeof parameter === 'undefined') {
      return undefined;
    }
    let pixels;
    if (isNumber(parameter)) {
      
      pixels = parameter;
    } else if (isString(parameter)) {
      const text = parameter;
      let unit = text.substring(text.length - 2).toLowerCase();
      let valueText = '';
      if (unit in unitToPixels) {
        valueText = text.substring(0, text.length - 2);
      } else {
        
        
        unit = 'px';
        valueText = text;
      }
      const value = Number(valueText);
      assert(!isNaN(value), 'Failed to parse parameter value: ' + text);
      pixels = value * unitToPixels[unit];
    } else {
      throw new Error('page.pdf() Cannot handle parameter type: ' + typeof parameter);
    }
    return pixels / unitToPixels[lengthUnit];
  }
  function fromEmitterEvent(emitter, eventName) {
    return new Observable(subscriber => {
      const listener = event => {
        subscriber.next(event);
      };
      emitter.on(eventName, listener);
      return () => {
        emitter.off(eventName, listener);
      };
    });
  }
  function fromAbortSignal(signal, cause) {
    return signal ? fromEvent(signal, 'abort').pipe(map(() => {
      if (signal.reason instanceof Error) {
        signal.reason.cause = cause;
        throw signal.reason;
      }
      throw new Error(signal.reason, {
        cause
      });
    })) : NEVER;
  }
  function filterAsync(predicate) {
    return mergeMap(value => {
      return from(Promise.resolve(predicate(value))).pipe(filter(isMatch => {
        return isMatch;
      }), map(() => {
        return value;
      }));
    });
  }

  const WEB_PERMISSION_TO_PROTOCOL_PERMISSION = new Map([['accelerometer', 'sensors'], ['ambient-light-sensor', 'sensors'], ['background-sync', 'backgroundSync'], ['camera', 'videoCapture'], ['clipboard-read', 'clipboardReadWrite'], ['clipboard-sanitized-write', 'clipboardSanitizedWrite'], ['clipboard-write', 'clipboardReadWrite'], ['geolocation', 'geolocation'], ['gyroscope', 'sensors'], ['idle-detection', 'idleDetection'], ['keyboard-lock', 'keyboardLock'], ['magnetometer', 'sensors'], ['microphone', 'audioCapture'], ['midi', 'midi'], ['notifications', 'notifications'], ['payment-handler', 'paymentHandler'], ['persistent-storage', 'durableStorage'], ['pointer-lock', 'pointerLock'],
  
  ['midi-sysex', 'midiSysex']]);
  class Browser extends EventEmitter {
    constructor() {
      super();
    }
    async waitForTarget(predicate, options = {}) {
      const {
        timeout: ms = 30000,
        signal
      } = options;
    async pages() {
      const contextPages = await Promise.all(this.browserContexts().map(context => {
        return context.pages();
      }));
      
      return contextPages.reduce((acc, x) => {
        return acc.concat(x);
      }, []);
    }
    async cookies() {
      return await this.defaultBrowserContext().cookies();
    }
    async setCookie(...cookies) {
      return await this.defaultBrowserContext().setCookie(...cookies);
    }
    async deleteCookie(...cookies) {
      return await this.defaultBrowserContext().deleteCookie(...cookies);
    }
    isConnected() {
      return this.connected;
    }
    [asyncDisposeSymbol]() {
      if (this.process()) {
        return this.close();
      }
      return this.disconnect();
    }
  }

  function _finish(value) {
    clearTimeout(_classPrivateFieldGet(_timeoutId, this));
    _classPrivateFieldSet(_value, this, value);
    _classPrivateFieldGet(_resolve, this).call(this);
  }
  class Mutex {
    constructor() {
      _classPrivateFieldInitSpec(this, _locked, false);
      _classPrivateFieldInitSpec(this, _acquirers, []);
    }
    
    async acquire(onRelease) {
      if (!_classPrivateFieldGet(_locked, this)) {
        _classPrivateFieldSet(_locked, this, true);
        return new Mutex.Guard(this);
      }
      const deferred = Deferred.create();
      _classPrivateFieldGet(_acquirers, this).push(deferred.resolve.bind(deferred));
      await deferred.valueOrThrow();
      return new Mutex.Guard(this, onRelease);
    }
    release() {
      const resolve = _classPrivateFieldGet(_acquirers, this).shift();
      if (!resolve) {
        _classPrivateFieldSet(_locked, this, false);
        return;
      }
      resolve();
    }
  }

    constructor() {
      super();
      _classPrivateFieldInitSpec(this, _pageScreenshotMutex, void 0);
      _classPrivateFieldInitSpec(this, _screenshotOperationsCount, 0);
    }
    startScreenshot() {
      var _this$screenshotOpera, _this$screenshotOpera2;
      const mutex = _classPrivateFieldGet(_pageScreenshotMutex, this) || new Mutex();
      _classPrivateFieldSet(_pageScreenshotMutex, this, mutex);
      _classPrivateFieldSet(_screenshotOperationsCount, this, (_this$screenshotOpera = _classPrivateFieldGet(_screenshotOperationsCount, this), _this$screenshotOpera2 = _this$screenshotOpera++, _this$screenshotOpera)), _this$screenshotOpera2;
      return mutex.acquire(() => {
        var _this$screenshotOpera3, _this$screenshotOpera4;
        _classPrivateFieldSet(_screenshotOperationsCount, this, (_this$screenshotOpera3 = _classPrivateFieldGet(_screenshotOperationsCount, this), _this$screenshotOpera4 = _this$screenshotOpera3--, _this$screenshotOpera3)), _this$screenshotOpera4;
        if (_classPrivateFieldGet(_screenshotOperationsCount, this) === 0) {
          
          _classPrivateFieldSet(_pageScreenshotMutex, this, undefined);
        }
      });
    }
    waitForScreenshotOperations() {
      return _classPrivateFieldGet(_pageScreenshotMutex, this)?.acquire();
    }
    async waitForTarget(predicate, options = {}) {
      const {
        timeout: ms = 30000
      } = options;
    async deleteCookie(...cookies) {
      return await this.setCookie(...cookies.map(cookie => {
        return {
          ...cookie,
          expires: 1
        };
      }));
    }
    get closed() {
      return !this.browser().browserContexts().includes(this);
    }
    get id() {
      return undefined;
    }
    [asyncDisposeSymbol]() {
      return this.close();
    }
  }

  
  exports.CDPSessionEvent = void 0;
  (function (CDPSessionEvent) {
    CDPSessionEvent.Swapped = Symbol('CDPSession.Swapped');
    CDPSessionEvent.Ready = Symbol('CDPSession.Ready');
    CDPSessionEvent.SessionAttached = 'sessionattached';
    CDPSessionEvent.SessionDetached = 'sessiondetached';
  })(exports.CDPSessionEvent || (exports.CDPSessionEvent = {}));
  class CDPSession extends EventEmitter {
    constructor() {
      super();
    }
    parentSession() {
      return undefined;
    }
  }

    constructor(type, message, defaultValue = '') {
      _classPrivateFieldInitSpec(this, _type, void 0);
      _classPrivateFieldInitSpec(this, _message, void 0);
      _classPrivateFieldInitSpec(this, _defaultValue, void 0);
      _defineProperty(this, "handled", false);
      _classPrivateFieldSet(_type, this, type);
      _classPrivateFieldSet(_message, this, message);
      _classPrivateFieldSet(_defaultValue, this, defaultValue);
    }
    type() {
      return _classPrivateFieldGet(_type, this);
    }
    message() {
      return _classPrivateFieldGet(_message, this);
    }
    defaultValue() {
      return _classPrivateFieldGet(_defaultValue, this);
    }
    async accept(promptText) {
      assert(!this.handled, 'Cannot accept dialog which is already handled!');
      this.handled = true;
      await this.handle({
        accept: true,
        text: promptText
      });
    }
    async dismiss() {
      assert(!this.handled, 'Cannot dismiss dialog which is already handled!');
      this.handled = true;
      await this.handle({
        accept: false
      });
    }
  }

  const _isElementHandle = Symbol('_isElementHandle');

  function isErrorLike(obj) {
    return typeof obj === 'object' && obj !== null && 'name' in obj && 'message' in obj;
  }
  function isErrnoException(obj) {
    return isErrorLike(obj) && ('errno' in obj || 'code' in obj || 'path' in obj || 'syscall' in obj);
  }
  function rewriteError$1(error, message, originalMessage) {
    error.message = message;
    error.originalMessage = originalMessage ?? error.originalMessage;
    return error;
  }
  function createProtocolErrorMessage(object) {
    let message = object.error.message;
    
    
    if (object.error && typeof object.error === 'object' && 'data' in object.error) {
      message += ` ${object.error.data}`;
    }
    return message;
  }

  const createdFunctions = new Map();
  const createFunction = functionValue => {
    let fn = createdFunctions.get(functionValue);
    if (fn) {
      return fn;
    }
    
    createdFunctions.set(functionValue, fn);
    return fn;
  };
  function stringifyFunction(fn) {
    let value = fn.toString();
    try {
      
    } catch (err) {
      if (err.message.includes(`Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive`)) {
        
        
        return value;
      }
      
      
      let prefix = 'function ';
      if (value.startsWith('async ')) {
        prefix = `async ${prefix}`;
        value = value.substring('async '.length);
      }
      value = `${prefix}${value}`;
      try {
        
      } catch {
        
        throw new Error('Passed function cannot be serialized!');
      }
    }
    return value;
  }
  const interpolateFunction = (fn, replacements) => {
    let value = stringifyFunction(fn);
    for (const [name, jsValue] of Object.entries(replacements)) {
      value = value.replace(new RegExp(`PLACEHOLDER\\(\\s*(?:'${name}'|"${name}")\\s*\\)`, 'g'),
      
      
      
      `(${jsValue})`);
    }
    return createFunction(value);
  };

  var __addDisposableResource$c = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$c = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  const DEFAULT_BATCH_SIZE = 20;
  async function* fastTransposeIteratorHandle(iterator, size) {
    const env_1 = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const array = __addDisposableResource$c(env_1, await iterator.evaluateHandle(async (iterator, size) => {
        const results = [];
        while (results.length < size) {
          const result = await iterator.next();
          if (result.done) {
            break;
          }
          results.push(result.value);
        }
        return results;
      }, size), false);
      const properties = await array.getProperties();
      const handles = properties.values();
      const stack = __addDisposableResource$c(env_1, new DisposableStack(), false);
      stack.defer(() => {
        for (const handle_1 of handles) {
          const env_2 = {
            stack: [],
            error: void 0,
            hasError: false
          };
          try {
            const handle = __addDisposableResource$c(env_2, handle_1, false);
            handle[disposeSymbol]();
          } catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
          } finally {
            __disposeResources$c(env_2);
          }
        }
      });
      yield* handles;
      return properties.size === 0;
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources$c(env_1);
    }
  }
  async function* transposeIteratorHandle(iterator) {
    let size = DEFAULT_BATCH_SIZE;
    while (!(yield* fastTransposeIteratorHandle(iterator, size))) {
      size <<= 1;
    }
  }
  async function* transposeIterableHandle(handle) {
    const env_3 = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      const generatorHandle = __addDisposableResource$c(env_3, await handle.evaluateHandle(iterable => {
        return async function* () {
          yield* iterable;
        }();
      }), false);
      yield* transposeIteratorHandle(generatorHandle);
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      __disposeResources$c(env_3);
    }
  }

  _LazyArg = LazyArg;
  _defineProperty(LazyArg, "create", get => {
    
    
    return new _LazyArg(get);
  });
  var __addDisposableResource$b = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$b = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  class QueryHandler {
    static get _querySelector() {
      if (this.querySelector) {
        return this.querySelector;
      }
      if (!this.querySelectorAll) {
        throw new Error('Cannot create default `querySelector`.');
      }
      return this.querySelector = interpolateFunction(async (node, selector, PuppeteerUtil) => {
        const querySelectorAll = PLACEHOLDER('querySelectorAll');
        const results = querySelectorAll(node, selector, PuppeteerUtil);
        for await (const result of results) {
          return result;
        }
        return null;
      }, {
        querySelectorAll: stringifyFunction(this.querySelectorAll)
      });
    }
    static get _querySelectorAll() {
      if (this.querySelectorAll) {
        return this.querySelectorAll;
      }
      if (!this.querySelector) {
        throw new Error('Cannot create default `querySelectorAll`.');
      }
      return this.querySelectorAll = interpolateFunction(async function* (node, selector, PuppeteerUtil) {
        const querySelector = PLACEHOLDER('querySelector');
        const result = await querySelector(node, selector, PuppeteerUtil);
        if (result) {
          yield result;
        }
      }, {
        querySelector: stringifyFunction(this.querySelector)
      });
    }
    static async *queryAll(element, selector) {
      const env_1 = {
        stack: [],
        error: void 0,
        hasError: false
      };
      try {
        const handle = __addDisposableResource$b(env_1, await element.evaluateHandle(this._querySelectorAll, selector, LazyArg.create(context => {
          return context.puppeteerUtil;
        })), false);
        yield* transposeIterableHandle(handle);
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources$b(env_1);
      }
    }
    static async queryOne(element, selector) {
      const env_2 = {
        stack: [],
        error: void 0,
        hasError: false
      };
      try {
        const result = __addDisposableResource$b(env_2, await element.evaluateHandle(this._querySelector, selector, LazyArg.create(context => {
          return context.puppeteerUtil;
        })), false);
        if (!(_isElementHandle in result)) {
          return null;
        }
        return result.move();
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        __disposeResources$b(env_2);
      }
    }
    static async waitFor(elementOrFrame, selector, options) {
      const env_3 = {
        stack: [],
        error: void 0,
        hasError: false
      };
      try {
        let frame;
        const element = __addDisposableResource$b(env_3, await (async () => {
          if (!(_isElementHandle in elementOrFrame)) {
            frame = elementOrFrame;
            return;
          }
          frame = elementOrFrame.frame;
          return await frame.isolatedRealm().adoptHandle(elementOrFrame);
        })(), false);
        const {
          visible = false,
          hidden = false,
          timeout,
          signal
        } = options;
  
  _defineProperty(QueryHandler, "querySelectorAll", void 0);
  _defineProperty(QueryHandler, "querySelector", void 0);
  class AsyncIterableUtil {
    static async *map(iterable, map) {
      for await (const value of iterable) {
        yield await map(value);
      }
    }
    static async *flatMap(iterable, map) {
      for await (const value of iterable) {
        yield* map(value);
      }
    }
    static async collect(iterable) {
      const result = [];
      for await (const value of iterable) {
        result.push(value);
      }
      return result;
    }
    static async first(iterable) {
      for await (const value of iterable) {
        return value;
      }
      return;
    }
  }

  const isKnownAttribute = attribute => {
    return ['name', 'role'].includes(attribute);
  };
  const ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
  const parseARIASelector = selector => {
    if (selector.length > 10_000) {
      throw new Error(`Selector ${selector} is too long`);
    }
    const queryOptions = {};
    const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value) => {
      assert(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
      queryOptions[attribute] = value;
      return '';
    });
    if (defaultName && !queryOptions.name) {
      queryOptions.name = defaultName;
    }
    return queryOptions;
  };
  class ARIAQueryHandler extends QueryHandler {
    static async *queryAll(element, selector) {
      const {
        name,
        role
      } = parseARIASelector(selector);
      yield* element.queryAXTree(name, role);
    }
  }

  _ARIAQueryHandler = ARIAQueryHandler;
  _defineProperty(ARIAQueryHandler, "querySelector", async (node, selector, {
    ariaQuerySelector
  }) => {
    return await ariaQuerySelector(node, selector);
  });
  _defineProperty(ARIAQueryHandler, "queryOne", async (element, selector) => {
    return (await AsyncIterableUtil.first(_ARIAQueryHandler.queryAll(element, selector))) ?? null;
  });
  class CSSQueryHandler extends QueryHandler {}

  _defineProperty(CSSQueryHandler, "querySelector", (element, selector, {
    cssQuerySelector
  }) => {
    return cssQuerySelector(element, selector);
  });
  _defineProperty(CSSQueryHandler, "querySelectorAll", (element, selector, {
    cssQuerySelectorAll
  }) => {
    return cssQuerySelectorAll(element, selector);
  });
  const source = "\"use strict\";var g=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var Y=Object.prototype.hasOwnProperty;var l=(t,e)=>{for(var r in e)g(t,r,{get:e[r],enumerable:!0})},J=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of B(e))!Y.call(t,n)&&n!==r&&g(t,n,{get:()=>e[n],enumerable:!(o=X(e,n))||o.enumerable});return t};var z=t=>J(g({},\"__esModule\",{value:!0}),t);var pe={};l(pe,{default:()=>he});module.exports=z(pe);var N=class extends Error{constructor(e,r){super(e,r),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},p=class extends N{};var c=class t{static create(e){return new t(e)}static async race(e){let r=new Set;try{let o=e.map(n=>n instanceof t?(n.#n&&r.add(n),n.valueOrThrow()):n);return await Promise.race(o)}finally{for(let o of r)o.reject(new Error(\"Timeout cleared\"))}}#e=!1;#r=!1;#o;#t;#a=new Promise(e=>{this.#t=e});#n;#i;constructor(e){e&&e.timeout>0&&(this.#i=new p(e.message),this.#n=setTimeout(()=>{this.reject(this.#i)},e.timeout))}#l(e){clearTimeout(this.#n),this.#o=e,this.#t()}resolve(e){this.#r||this.#e||(this.#e=!0,this.#l(e))}reject(e){this.#r||this.#e||(this.#r=!0,this.#l(e))}resolved(){return this.#e}finished(){return this.#e||this.#r}value(){return this.#o}#s;valueOrThrow(){return this.#s||(this.#s=(async()=>{if(await this.#a,this.#r)throw this.#o;return this.#o})()),this.#s}};var L=new Map,F=t=>{let e=L.get(t);return e||(e=new Function(`return ${t}`)(),L.set(t,e),e)};var x={};l(x,{ariaQuerySelector:()=>G,ariaQuerySelectorAll:()=>b});var G=(t,e)=>globalThis.__ariaQuerySelector(t,e),b=async function*(t,e){yield*await globalThis.__ariaQuerySelectorAll(t,e)};var E={};l(E,{cssQuerySelector:()=>K,cssQuerySelectorAll:()=>Z});var K=(t,e)=>t.querySelector(e),Z=function(t,e){return t.querySelectorAll(e)};var A={};l(A,{customQuerySelectors:()=>P});var v=class{#e=new Map;register(e,r){if(!r.queryOne&&r.queryAll){let o=r.queryAll;r.queryOne=(n,i)=>{for(let s of o(n,i))return s;return null}}else if(r.queryOne&&!r.queryAll){let o=r.queryOne;r.queryAll=(n,i)=>{let s=o(n,i);return s?[s]:[]}}else if(!r.queryOne||!r.queryAll)throw new Error(\"At least one query method must be defined.\");this.#e.set(e,{querySelector:r.queryOne,querySelectorAll:r.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},P=new v;var R={};l(R,{pierceQuerySelector:()=>ee,pierceQuerySelectorAll:()=>te});var ee=(t,e)=>{let r=null,o=n=>{let i=document.createTreeWalker(n,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&o(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==n&&!r&&s.matches(e)&&(r=s)}while(!r&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r},te=(t,e)=>{let r=[],o=n=>{let i=document.createTreeWalker(n,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&o(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==n&&s.matches(e)&&r.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r};var u=(t,e)=>{if(!t)throw new Error(e)};var y=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=new MutationObserver(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())}),this.#o.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){u(this.#t,\"Polling never started.\"),this.#t.finished()||this.#t.reject(new Error(\"Polling stopped\")),this.#o&&(this.#o.disconnect(),this.#o=void 0)}result(){return u(this.#t,\"Polling never started.\"),this.#t.valueOrThrow()}},w=class{#e;#r;constructor(e){this.#e=e}async start(){let e=this.#r=c.create(),r=await this.#e();if(r){e.resolve(r);return}let o=async()=>{if(e.finished())return;let n=await this.#e();if(!n){window.requestAnimationFrame(o);return}e.resolve(n),await this.stop()};window.requestAnimationFrame(o)}async stop(){u(this.#r,\"Polling never started.\"),this.#r.finished()||this.#r.reject(new Error(\"Polling stopped\"))}result(){return u(this.#r,\"Polling never started.\"),this.#r.valueOrThrow()}},S=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=setInterval(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())},this.#r)}async stop(){u(this.#t,\"Polling never started.\"),this.#t.finished()||this.#t.reject(new Error(\"Polling stopped\")),this.#o&&(clearInterval(this.#o),this.#o=void 0)}result(){return u(this.#t,\"Polling never started.\"),this.#t.valueOrThrow()}};var _={};l(_,{PCombinator:()=>H,pQuerySelector:()=>fe,pQuerySelectorAll:()=>$});var a=class{static async*map(e,r){for await(let o of e)yield await r(o)}static async*flatMap(e,r){for await(let o of e)yield*r(o)}static async collect(e){let r=[];for await(let o of e)r.push(o);return r}static async first(e){for await(let r of e)return r}};var C={};l(C,{textQuerySelectorAll:()=>m});var re=new Set([\"checkbox\",\"image\",\"radio\"]),oe=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!re.has(t.type),ne=new Set([\"SCRIPT\",\"STYLE\"]),f=t=>!ne.has(t.nodeName)&&!document.head?.contains(t),I=new WeakMap,j=t=>{for(;t;)I.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},W=new WeakSet,se=new MutationObserver(t=>{for(let e of t)j(e.target)}),d=t=>{let e=I.get(t);if(e||(e={full:\"\",immediate:[]},!f(t)))return e;let r=\"\";if(oe(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener(\"input\",o=>{j(o.target)},{once:!0,capture:!0});else{for(let o=t.firstChild;o;o=o.nextSibling){if(o.nodeType===Node.TEXT_NODE){e.full+=o.nodeValue??\"\",r+=o.nodeValue??\"\";continue}r&&e.immediate.push(r),r=\"\",o.nodeType===Node.ELEMENT_NODE&&(e.full+=d(o).full)}r&&e.immediate.push(r),t instanceof Element&&t.shadowRoot&&(e.full+=d(t.shadowRoot).full),W.has(t)||(se.observe(t,{childList:!0,characterData:!0,subtree:!0}),W.add(t))}return I.set(t,e),e};var m=function*(t,e){let r=!1;for(let o of t.childNodes)if(o instanceof Element&&f(o)){let n;o.shadowRoot?n=m(o.shadowRoot,e):n=m(o,e);for(let i of n)yield i,r=!0}r||t instanceof Element&&f(t)&&d(t).full.includes(e)&&(yield t)};var k={};l(k,{checkVisibility:()=>le,pierce:()=>T,pierceAll:()=>O});var ie=[\"hidden\",\"collapse\"],le=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let r=t.nodeType===Node.TEXT_NODE?t.parentElement:t,o=window.getComputedStyle(r),n=o&&!ie.includes(o.visibility)&&!ae(r);return e===n?t:!1};function ae(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var ce=t=>\"shadowRoot\"in t&&t.shadowRoot instanceof ShadowRoot;function*T(t){ce(t)?yield t.shadowRoot:yield t}function*O(t){t=T(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let r of e){let o;for(;o=r.nextNode();)o.shadowRoot&&(yield o.shadowRoot,e.push(document.createTreeWalker(o.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var Q={};l(Q,{xpathQuerySelectorAll:()=>q});var q=function*(t,e,r=-1){let n=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],s;for(;(s=n.iterateNext())&&(i.push(s),!(r&&i.length===r)););for(let h=0;h<i.length;h++)s=i[h],yield s,delete i[h]};var ue=/[-\\w\\P{ASCII}*]/u,H=(r=>(r.Descendent=\">>>\",r.Child=\">>>>\",r))(H||{}),V=t=>\"querySelectorAll\"in t,M=class{#e;#r=[];#o=void 0;elements;constructor(e,r){this.elements=[e],this.#e=r,this.#t()}async run(){if(typeof this.#o==\"string\")switch(this.#o.trimStart()){case\":scope\":this.#t();break}for(;this.#o!==void 0;this.#t()){let e=this.#o;typeof e==\"string\"?e[0]&&ue.test(e[0])?this.elements=a.flatMap(this.elements,async function*(r){V(r)&&(yield*r.querySelectorAll(e))}):this.elements=a.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!V(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let n of r.parentElement.children)if(++o,n===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=a.flatMap(this.elements,async function*(r){switch(e.name){case\"text\":yield*m(r,e.value);break;case\"xpath\":yield*q(r,e.value);break;case\"aria\":yield*b(r,e.value);break;default:let o=P.get(e.name);if(!o)throw new Error(`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#t(){if(this.#r.length!==0){this.#o=this.#r.shift();return}if(this.#e.length===0){this.#o=void 0;return}let e=this.#e.shift();switch(e){case\">>>>\":{this.elements=a.flatMap(this.elements,T),this.#t();break}case\">>>\":{this.elements=a.flatMap(this.elements,O),this.#t();break}default:this.#r=e,this.#t();break}}},D=class{#e=new WeakMap;calculate(e,r=[]){if(e===null)return r;e instanceof ShadowRoot&&(e=e.host);let o=this.#e.get(e);if(o)return[...o,...r];let n=0;for(let s=e.previousSibling;s;s=s.previousSibling)++n;let i=this.calculate(e.parentNode,[n]);return this.#e.set(e,i),[...i,...r]}},U=(t,e)=>{if(t.length+e.length===0)return 0;let[r=-1,...o]=t,[n=-1,...i]=e;return r===n?U(o,i):r<n?-1:1},de=async function*(t){let e=new Set;for await(let o of t)e.add(o);let r=new D;yield*[...e.values()].map(o=>[o,r.calculate(o)]).sort(([,o],[,n])=>U(o,n)).map(([o])=>o)},$=function(t,e){let r=JSON.parse(e);if(r.some(o=>{let n=0;return o.some(i=>(typeof i==\"string\"?++n:n=0,n>1))}))throw new Error(\"Multiple deep combinators found in sequence.\");return de(a.flatMap(r,o=>{let n=new M(t,o);return n.run(),n.elements}))},fe=async function(t,e){for await(let r of $(t,e))return r;return null};var me=Object.freeze({...x,...A,...R,..._,...C,...k,...Q,...E,Deferred:c,createFunction:F,createTextContent:d,IntervalPoller:S,isSuitableNodeForTextMatching:f,MutationPoller:y,RAFPoller:w}),he=me;\n";

  function _update(callback) {
    callback();
    _classPrivateFieldSet(_updated, this, true);
  }
  function _get2() {
    return `(() => {
      const module = {};
      ${source}
      ${[..._classPrivateFieldGet(_amendments, this)].map(statement => {
      return `(${statement})(module.exports.default);`;
    }).join('')}
      return module.exports.default;
    })()`;
  }
  const scriptInjector = new ScriptInjector();

    register(name, handler) {
      var _Class;
      assert(!_classPrivateFieldGet(_handlers2, this).has(name), `Cannot register over existing handler: ${name}`);
      assert(/^[a-zA-Z]+$/.test(name), `Custom query handler names may only contain [a-zA-Z]`);
      assert(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
      const Handler = (_Class = class Handler extends QueryHandler {}, _defineProperty(_Class, "querySelectorAll", interpolateFunction((node, selector, PuppeteerUtil) => {
        return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER('name')).querySelectorAll(node, selector);
      }, {
        name: JSON.stringify(name)
      })), _defineProperty(_Class, "querySelector", interpolateFunction((node, selector, PuppeteerUtil) => {
        return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER('name')).querySelector(node, selector);
      }, {
        name: JSON.stringify(name)
      })), _Class);
      const registerScript = interpolateFunction(PuppeteerUtil => {
        PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER('name'), {
          queryAll: PLACEHOLDER('queryAll'),
          queryOne: PLACEHOLDER('queryOne')
        });
      }, {
        name: JSON.stringify(name),
        queryAll: handler.queryAll ? stringifyFunction(handler.queryAll) : String(undefined),
        queryOne: handler.queryOne ? stringifyFunction(handler.queryOne) : String(undefined)
      }).toString();
      _classPrivateFieldGet(_handlers2, this).set(name, [registerScript, Handler]);
      scriptInjector.append(registerScript);
    }
    unregister(name) {
      const handler = _classPrivateFieldGet(_handlers2, this).get(name);
      if (!handler) {
        throw new Error(`Cannot unregister unknown handler: ${name}`);
      }
      scriptInjector.pop(handler[0]);
      _classPrivateFieldGet(_handlers2, this).delete(name);
    }
    names() {
      return [..._classPrivateFieldGet(_handlers2, this).keys()];
    }
    clear() {
      for (const [registerScript] of _classPrivateFieldGet(_handlers2, this)) {
        scriptInjector.pop(registerScript);
      }
      _classPrivateFieldGet(_handlers2, this).clear();
    }
  }
  const customQueryHandlers = new CustomQueryHandlerRegistry();

  class PierceQueryHandler extends QueryHandler {}

  _defineProperty(PierceQueryHandler, "querySelector", (element, selector, {
    pierceQuerySelector
  }) => {
    return pierceQuerySelector(element, selector);
  });
  _defineProperty(PierceQueryHandler, "querySelectorAll", (element, selector, {
    pierceQuerySelectorAll
  }) => {
    return pierceQuerySelectorAll(element, selector);
  });
  class PQueryHandler extends QueryHandler {}

  
  _defineProperty(PQueryHandler, "querySelectorAll", (element, selector, {
    pQuerySelectorAll
  }) => {
    return pQuerySelectorAll(element, selector);
  });
  _defineProperty(PQueryHandler, "querySelector", (element, selector, {
    pQuerySelector
  }) => {
    return pQuerySelector(element, selector);
  });
  var TOKENS = {
    attribute: /\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,
    id: /#(?<name>[-\w\P{ASCII}]+)/gu,
    class: /\.(?<name>[-\w\P{ASCII}]+)/gu,
    comma: /\s*,\s*/g,
    combinator: /\s*[\s>+~]\s*/g,
    "pseudo-element": /::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>*)\))?/gu,
    "pseudo-class": /:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>*)\))?/gu,
    universal: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,
    type: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu
    
  };
    for (const replacement of replacements.reverse()) {
      for (const token of tokens) {
        const {
          offset,
          value
        } = replacement;
        if (!(token.pos[0] <= offset && offset + value.length <= token.pos[1])) {
          continue;
        }
        const {
          content
        } = token;
        const tokenOffset = offset - token.pos[0];
        token.content = content.slice(0, tokenOffset) + value + content.slice(tokenOffset + value.length);
        if (token.content !== content) {
          changedTokens.add(token);
        }
      }
    }
    for (const token of changedTokens) {
      const pattern = getArgumentPatternByType(token.type);
      if (!pattern) {
        throw new Error(`Unknown token type: ${token.type}`);
      }
      pattern.lastIndex = 0;
      const match = pattern.exec(token.content);
      if (!match) {
        throw new Error(`Unable to parse content for ${token.type}: ${token.content}`);
      }
      Object.assign(token, match.groups);
    }
    return tokens;
  }
  function stringify(listOrNode) {
    if (Array.isArray(listOrNode)) {
      return listOrNode.map(token => token.content).join("");
    }
    switch (listOrNode.type) {
      case "list":
        return listOrNode.list.map(stringify).join(",");
      case "relative":
        return listOrNode.combinator + stringify(listOrNode.right);
      case "complex":
        return stringify(listOrNode.left) + listOrNode.combinator + stringify(listOrNode.right);
      case "compound":
        return listOrNode.list.map(stringify).join("");
      default:
        return listOrNode.content;
    }
  }

  TOKENS['nesting'] = /&/g;
  TOKENS['combinator'] = /\s*(>>>>?|[\s>+~])\s*/g;
  const ESCAPE_REGEXP = /\\[\s\S]/g;
  const unquote = text => {
    if (text.length <= 1) {
      return text;
    }
    if ((text[0] === '"' || text[0] === "'") && text.endsWith(text[0])) {
      text = text.slice(1, -1);
    }
    return text.replace(ESCAPE_REGEXP, match => {
      return match[1];
    });
  };
  function parsePSelectors(selector) {
    let isPureCSS = true;
    let hasAria = false;
    let hasPseudoClasses = false;
    const tokens = tokenize(selector);
    if (tokens.length === 0) {
      return [[], isPureCSS, hasPseudoClasses, false];
    }
    let compoundSelector = [];
    let complexSelector = [compoundSelector];
    const selectors = [complexSelector];
    const storage = [];
    for (const token of tokens) {
      switch (token.type) {
        case 'combinator':
          switch (token.content) {
              complexSelector.push(compoundSelector);
              continue;
              complexSelector.push(compoundSelector);
              continue;
          }
          break;
        case 'pseudo-element':
          if (!token.name.startsWith('-p-')) {
            break;
          }
          isPureCSS = false;
          if (storage.length) {
            compoundSelector.push(stringify(storage));
            storage.splice(0);
          }
          const name = token.name.slice(3);
          if (name === 'aria') {
            hasAria = true;
          }
          compoundSelector.push({
            name,
            value: unquote(token.argument ?? '')
          });
          continue;
        case 'pseudo-class':
          hasPseudoClasses = true;
          break;
        case 'comma':
          if (storage.length) {
            compoundSelector.push(stringify(storage));
            storage.splice(0);
          }
          compoundSelector = [];
          complexSelector = [compoundSelector];
          selectors.push(complexSelector);
          continue;
      }
      storage.push(token);
    }
    if (storage.length) {
      compoundSelector.push(stringify(storage));
    }
    return [selectors, isPureCSS, hasPseudoClasses, hasAria];
  }

  class TextQueryHandler extends QueryHandler {}

  _defineProperty(TextQueryHandler, "querySelectorAll", (element, selector, {
    textQuerySelectorAll
  }) => {
    return textQuerySelectorAll(element, selector);
  });
  class XPathQueryHandler extends QueryHandler {}

  _defineProperty(XPathQueryHandler, "querySelectorAll", (element, selector, {
    xpathQuerySelectorAll
  }) => {
    return xpathQuerySelectorAll(element, selector);
  });
  _defineProperty(XPathQueryHandler, "querySelector", (element, selector, {
    xpathQuerySelectorAll
  }) => {
    for (const result of xpathQuerySelectorAll(element, selector, 1)) {
      return result;
    }
    return null;
  });
  const BUILTIN_QUERY_HANDLERS = {
    aria: ARIAQueryHandler,
    pierce: PierceQueryHandler,
    xpath: XPathQueryHandler,
    text: TextQueryHandler
  };
  const QUERY_SEPARATORS = ['=', '/'];
  function getQueryHandlerAndSelector(selector) {
    for (const handlerMap of [customQueryHandlers.names().map(name => {
      return [name, customQueryHandlers.get(name)];
    }), Object.entries(BUILTIN_QUERY_HANDLERS)]) {
      for (const [name, QueryHandler] of handlerMap) {
        for (const separator of QUERY_SEPARATORS) {
          const prefix = `${name}${separator}`;
          if (selector.startsWith(prefix)) {
            selector = selector.slice(prefix.length);
            return {
              updatedSelector: selector,
          QueryHandler: CSSQueryHandler
        };
      }
      return {
        updatedSelector: JSON.stringify(pSelector),
        QueryHandler: CSSQueryHandler
      };
    }
  }

  var __addDisposableResource$a = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$a = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  const instances = new WeakSet();
  function moveable(Class, _) {
    let hasDispose = false;
    if (Class.prototype[disposeSymbol]) {
      const dispose = Class.prototype[disposeSymbol];
      Class.prototype[disposeSymbol] = function () {
        if (instances.has(this)) {
          instances.delete(this);
          return;
        }
        return dispose.call(this);
      };
      hasDispose = true;
    }
    if (Class.prototype[asyncDisposeSymbol]) {
      const asyncDispose = Class.prototype[asyncDisposeSymbol];
      Class.prototype[asyncDisposeSymbol] = function () {
        if (instances.has(this)) {
          instances.delete(this);
          return;
        }
        return asyncDispose.call(this);
      };
      hasDispose = true;
    }
    if (hasDispose) {
      Class.prototype.move = function () {
        instances.add(this);
        return this;
      };
    }
    return Class;
  }
  function throwIfDisposed(message = value => {
    return `Attempted to use disposed ${value.constructor.name}.`;
  }) {
    return (target, _) => {
      return function (...args) {
        if (this.disposed) {
          throw new Error(message(this));
        }
        return target.call(this, ...args);
      };
    };
  }
  function invokeAtMostOnceForArguments(target, _) {
    const cache = new WeakMap();
    let cacheDepth = -1;
    return function (...args) {
      if (cacheDepth === -1) {
        cacheDepth = args.length;
      }
      if (cacheDepth !== args.length) {
        throw new Error('Memoized method was called with the wrong number of arguments');
      }
      let freshArguments = false;
      let cacheIterator = cache;
      for (const arg of args) {
        if (cacheIterator.has(arg)) {
          cacheIterator = cacheIterator.get(arg);
        } else {
          freshArguments = true;
          cacheIterator.set(arg, new WeakMap());
          cacheIterator = cacheIterator.get(arg);
        }
      }
      if (!freshArguments) {
        return;
      }
      return target.call(this, ...args);
    };
  }
  function guarded(getKey = function () {
    return this;
  }) {
    return (target, _) => {
      const mutexes = new WeakMap();
      return async function (...args) {
        const env_1 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const key = getKey.call(this);
          let mutex = mutexes.get(key);
          if (!mutex) {
            mutex = new Mutex();
            mutexes.set(key, mutex);
          }
          const _ = __addDisposableResource$a(env_1, await mutex.acquire(), true);
          return await target.call(this, ...args);
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          const result_1 = __disposeResources$a(env_1);
          if (result_1) await result_1;
        }
      };
    };
  }

  var __runInitializers$6 = undefined && undefined.__runInitializers || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$6 = undefined && undefined.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind,
      key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _,
      done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? {
        get: descriptor.get,
        set: descriptor.set
      } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field") initializers.unshift(_);else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource$9 = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$9 = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  let JSHandle = ((_ref, _Class2) => {
    let _classDecorators = [moveable];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _instanceExtraInitializers = [];
    let _getProperty_decorators;
    let _getProperties_decorators;
    _ref = (_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol);
    _Class2 = class {
      constructor() {
        __runInitializers$6(this, _instanceExtraInitializers);
      }
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.realm.evaluate(pageFunction, this, ...args);
      }
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.realm.evaluateHandle(pageFunction, this, ...args);
      }
      async getProperty(propertyName) {
        return await this.evaluateHandle((object, propertyName) => {
          return object[propertyName];
        }, propertyName);
      }
      async getProperties() {
        const propertyNames = await this.evaluate(object => {
          const enumerableProperties = [];
          const descriptors = Object.getOwnPropertyDescriptors(object);
          for (const propertyName in descriptors) {
            if (descriptors[propertyName]?.enumerable) {
              enumerableProperties.push(propertyName);
            }
          }
          return enumerableProperties;
        });
        const map = new Map();
        const results = await Promise.all(propertyNames.map(key => {
          return this.getProperty(key);
        }));
        for (const [key, value] of Object.entries(propertyNames)) {
          const env_1 = {
            stack: [],
            error: void 0,
            hasError: false
          };
          try {
            const handle = __addDisposableResource$9(env_1, results[key], false);
            if (handle) {
              map.set(value, handle.move());
            }
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources$9(env_1);
          }
        }
        return map;
      }
      [asyncDisposeSymbol]() {
        return this.dispose();
      }
    };
    _classThis = _Class2;
    (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
      __esDecorate$6(_Class2, null, _getProperty_decorators, {
        kind: "method",
        name: "getProperty",
        static: false,
        private: false,
        access: {
          has: obj => "getProperty" in obj,
          get: obj => obj.getProperty
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$6(_Class2, null, _getProperties_decorators, {
        kind: "method",
        name: "getProperties",
        static: false,
        private: false,
        access: {
          has: obj => "getProperties" in obj,
          get: obj => obj.getProperties
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$6(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers$6(_classThis, _classExtraInitializers);
    })();
    return _classThis;
  })();

  var __runInitializers$5 = undefined && undefined.__runInitializers || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$5 = undefined && undefined.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind,
      key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _,
      done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? {
        get: descriptor.get,
        set: descriptor.set
      } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field") initializers.unshift(_);else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource$8 = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$8 = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  var __setFunctionName$1 = undefined && undefined.__setFunctionName || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
      configurable: true,
      value: prefix ? "".concat(prefix, " ", name) : name
    });
  };
  function bindIsolatedHandle(target, _) {
    return async function (...args) {
      
      
      if (this.realm === this.frame.isolatedRealm()) {
        return await target.call(this, ...args);
      }
      let adoptedThis;
      if (this['isolatedHandle']) {
        adoptedThis = this['isolatedHandle'];
      } else {
        this['isolatedHandle'] = adoptedThis = await this.frame.isolatedRealm().adoptHandle(this);
      }
      const result = await target.call(adoptedThis, ...args);
      
      if (result === adoptedThis) {
        return this;
      }
      
      if (result instanceof JSHandle) {
        return await this.realm.transferHandle(result);
      }
      
      
      if (Array.isArray(result)) {
        await Promise.all(result.map(async (item, index, result) => {
          if (item instanceof JSHandle) {
            result[index] = await this.realm.transferHandle(item);
          }
        }));
      }
      if (result instanceof Map) {
        await Promise.all([...result.entries()].map(async ([key, value]) => {
          if (value instanceof JSHandle) {
            result.set(key, await this.realm.transferHandle(value));
          }
        }));
      }
      return result;
    };
  }
  let ElementHandle = ((_ElementHandle, _ElementHandle_brand) => {
    let _classSuper = JSHandle;
    let _instanceExtraInitializers = [];
    let _getProperty_decorators;
    let _getProperties_decorators;
    let _jsonValue_decorators;
    let _$_decorators;
    let _$$_decorators;
    let _private_$$_decorators;
    let _private_$$_descriptor;
    let _waitForSelector_decorators;
    let _isVisible_decorators;
    let _isHidden_decorators;
    let _toElement_decorators;
    let _clickablePoint_decorators;
    let _hover_decorators;
    let _click_decorators;
    let _drag_decorators;
    let _dragEnter_decorators;
    let _dragOver_decorators;
    let _drop_decorators;
    let _dragAndDrop_decorators;
    let _select_decorators;
    let _tap_decorators;
    let _touchStart_decorators;
    let _touchMove_decorators;
    let _touchEnd_decorators;
    let _focus_decorators;
    let _type_decorators;
    let _press_decorators;
    let _boundingBox_decorators;
    let _boxModel_decorators;
    let _screenshot_decorators;
    let _isIntersectingViewport_decorators;
    let _scrollIntoView_decorators;
      constructor(_handle) {
        super();
        _classPrivateMethodInitSpec(this, _ElementHandle_brand);
        _defineProperty(this, "isolatedHandle", __runInitializers$5(this, _instanceExtraInitializers));
        _defineProperty(this, "handle", void 0);
        this.handle = _handle;
        this[_isElementHandle] = true;
      }
      get id() {
        return this.handle.id;
      }
      get disposed() {
        return this.handle.disposed;
      }
      async getProperty(propertyName) {
        return await this.handle.getProperty(propertyName);
      }
      async getProperties() {
        return await this.handle.getProperties();
      }
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.handle.evaluate(pageFunction, ...args);
      }
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.handle.evaluateHandle(pageFunction, ...args);
      }
      async jsonValue() {
        return await this.handle.jsonValue();
      }
      toString() {
        return this.handle.toString();
      }
      remoteObject() {
        return this.handle.remoteObject();
      }
      async dispose() {
        await Promise.all([this.handle.dispose(), this.isolatedHandle?.dispose()]);
      }
      asElement() {
        return this;
      }
      async $(selector) {
        const {
          updatedSelector,
          QueryHandler
        } = getQueryHandlerAndSelector(selector);
        return await QueryHandler.queryOne(this, updatedSelector);
      }
      async $$(selector, options) {
        if (options?.isolate === false) {
          return await _assertClassBrand(_ElementHandle_brand, this, _$$impl).call(this, selector);
        }
        return await _classPrivateGetter(_ElementHandle_brand, this, _get_$$).call(this, selector);
      }
      async $eval(selector, pageFunction, ...args) {
        const env_1 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
          const elementHandle = __addDisposableResource$8(env_1, await this.$(selector), false);
          if (!elementHandle) {
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
          }
          return await elementHandle.evaluate(pageFunction, ...args);
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources$8(env_1);
        }
      }
      async $$eval(selector, pageFunction, ...args) {
        const env_2 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
          const results = await this.$$(selector);
          const elements = __addDisposableResource$8(env_2, await this.evaluateHandle((_, ...elements) => {
            return elements;
          }, ...results), false);
          const [result] = await Promise.all([elements.evaluate(pageFunction, ...args), ...results.map(results => {
            return results.dispose();
          })]);
          return result;
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          __disposeResources$8(env_2);
        }
      }
      async waitForSelector(selector, options = {}) {
        const {
          updatedSelector,
          QueryHandler,
          polling
        } = getQueryHandlerAndSelector(selector);
        return await QueryHandler.waitFor(this, updatedSelector, {
          polling,
          ...options
        });
      }
      async isVisible() {
        return await _assertClassBrand(_ElementHandle_brand, this, _checkVisibility).call(this, true);
      }
      async isHidden() {
        return await _assertClassBrand(_ElementHandle_brand, this, _checkVisibility).call(this, false);
      }
      async toElement(tagName) {
        const isMatchingTagName = await this.evaluate((node, tagName) => {
          return node.nodeName === tagName.toUpperCase();
        }, tagName);
        if (!isMatchingTagName) {
          throw new Error(`Element is not a(n) \`${tagName}\` element`);
        }
        return this;
      }
      async clickablePoint(offset) {
        const box = await _assertClassBrand(_ElementHandle_brand, this, _clickableBox).call(this);
        if (!box) {
          throw new Error('Node is either not clickable or not an Element');
        }
        if (offset !== undefined) {
          return {
            x: box.x + offset.x,
            y: box.y + offset.y
          };
        }
        return {
          x: box.x + box.width / 2,
          y: box.y + box.height / 2
        };
      }
      async hover() {
        await this.scrollIntoViewIfNeeded();
        const {
          x,
          y
        } = await this.clickablePoint();
        await this.frame.page().mouse.move(x, y);
      }
      async click(options = {}) {
        await this.scrollIntoViewIfNeeded();
        const {
          x,
          y
        } = await this.clickablePoint(options.offset);
        await this.frame.page().mouse.click(x, y, options);
      }
      async drag(target) {
        await this.scrollIntoViewIfNeeded();
        const page = this.frame.page();
        if (page.isDragInterceptionEnabled()) {
          const source = await this.clickablePoint();
          if (target instanceof ElementHandle) {
            target = await target.clickablePoint();
          }
          return await page.mouse.drag(source, target);
        }
        try {
          if (!page._isDragging) {
            page._isDragging = true;
            await this.hover();
            await page.mouse.down();
          }
          if (target instanceof ElementHandle) {
            await target.hover();
          } else {
            await page.mouse.move(target.x, target.y);
          }
        } catch (error) {
          page._isDragging = false;
          throw error;
        }
      }
      async dragEnter(data = {
        items: [],
        dragOperationsMask: 1
      }) {
        const page = this.frame.page();
        await this.scrollIntoViewIfNeeded();
        const target = await this.clickablePoint();
        await page.mouse.dragEnter(target, data);
      }
      async dragOver(data = {
        items: [],
        dragOperationsMask: 1
      }) {
        const page = this.frame.page();
        await this.scrollIntoViewIfNeeded();
        const target = await this.clickablePoint();
        await page.mouse.dragOver(target, data);
      }
      async drop(dataOrElement = {
        items: [],
        dragOperationsMask: 1
      }) {
        const page = this.frame.page();
        if ('items' in dataOrElement) {
          await this.scrollIntoViewIfNeeded();
          const destination = await this.clickablePoint();
          await page.mouse.drop(destination, dataOrElement);
        } else {
          
          
          await dataOrElement.drag(this);
          page._isDragging = false;
          await page.mouse.up();
        }
      }
      async dragAndDrop(target, options) {
        const page = this.frame.page();
        assert(page.isDragInterceptionEnabled(), 'Drag Interception is not enabled!');
        await this.scrollIntoViewIfNeeded();
        const startPoint = await this.clickablePoint();
        const targetPoint = await target.clickablePoint();
        await page.mouse.dragAndDrop(startPoint, targetPoint, options);
      }
      async select(...values) {
        for (const value of values) {
          assert(isString(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
        }
        return await this.evaluate((element, vals) => {
          const values = new Set(vals);
          if (!(element instanceof HTMLSelectElement)) {
            throw new Error('Element is not a <select> element.');
          }
          const selectedValues = new Set();
          if (!element.multiple) {
            for (const option of element.options) {
              option.selected = false;
            }
            for (const option of element.options) {
              if (values.has(option.value)) {
                option.selected = true;
                selectedValues.add(option.value);
                break;
              }
            }
          } else {
            for (const option of element.options) {
              option.selected = values.has(option.value);
              if (option.selected) {
                selectedValues.add(option.value);
              }
            }
          }
          element.dispatchEvent(new Event('input', {
            bubbles: true
          }));
          element.dispatchEvent(new Event('change', {
            bubbles: true
          }));
          return [...selectedValues.values()];
        }, values);
      }
      async tap() {
        await this.scrollIntoViewIfNeeded();
        const {
          x,
          y
        } = await this.clickablePoint();
        await this.frame.page().touchscreen.tap(x, y);
      }
      async touchStart() {
        await this.scrollIntoViewIfNeeded();
        const {
          x,
          y
        } = await this.clickablePoint();
        return await this.frame.page().touchscreen.touchStart(x, y);
      }
      async touchMove(touch) {
        await this.scrollIntoViewIfNeeded();
        const {
          x,
          y
        } = await this.clickablePoint();
        if (touch) {
          return await touch.move(x, y);
        }
        await this.frame.page().touchscreen.touchMove(x, y);
      }
      async touchEnd() {
        await this.scrollIntoViewIfNeeded();
        await this.frame.page().touchscreen.touchEnd();
      }
      async focus() {
        await this.evaluate(element => {
          if (!(element instanceof HTMLElement)) {
            throw new Error('Cannot focus non-HTMLElement');
          }
          return element.focus();
        });
      }
      async type(text, options) {
        await this.focus();
        await this.frame.page().keyboard.type(text, options);
      }
      async press(key, options) {
        await this.focus();
        await this.frame.page().keyboard.press(key, options);
      }
      async boundingBox() {
        const box = await this.evaluate(element => {
          if (!(element instanceof Element)) {
            return null;
          }
          
          if (element.getClientRects().length === 0) {
            return null;
          }
          const rect = element.getBoundingClientRect();
          return {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          };
        });
        if (!box) {
          return null;
        }
        const offset = await _assertClassBrand(_ElementHandle_brand, this, _getTopLeftCornerOfFrame).call(this);
        if (!offset) {
          return null;
        }
        return {
          x: box.x + offset.x,
          y: box.y + offset.y,
          height: box.height,
          width: box.width
        };
      }
      async boxModel() {
        const model = await this.evaluate(element => {
          if (!(element instanceof Element)) {
            return null;
          }
          
          if (element.getClientRects().length === 0) {
            return null;
          }
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          const offsets = {
            padding: {
              left: parseInt(style.paddingLeft, 10),
              top: parseInt(style.paddingTop, 10),
              right: parseInt(style.paddingRight, 10),
              bottom: parseInt(style.paddingBottom, 10)
            },
            margin: {
              left: -parseInt(style.marginLeft, 10),
              top: -parseInt(style.marginTop, 10),
              right: -parseInt(style.marginRight, 10),
              bottom: -parseInt(style.marginBottom, 10)
            },
            border: {
              left: parseInt(style.borderLeft, 10),
              top: parseInt(style.borderTop, 10),
              right: parseInt(style.borderRight, 10),
              bottom: parseInt(style.borderBottom, 10)
            }
          };
          const border = [{
            x: rect.left,
            y: rect.top
          }, {
            x: rect.left + rect.width,
            y: rect.top
          }, {
            x: rect.left + rect.width,
            y: rect.top + rect.height
          }, {
            x: rect.left,
            y: rect.top + rect.height
          }];
          const padding = transformQuadWithOffsets(border, offsets.border);
          const content = transformQuadWithOffsets(padding, offsets.padding);
          const margin = transformQuadWithOffsets(border, offsets.margin);
          return {
            content,
            padding,
            border,
            margin,
            width: rect.width,
            height: rect.height
          };
          function transformQuadWithOffsets(quad, offsets) {
            return [{
              x: quad[0].x + offsets.left,
              y: quad[0].y + offsets.top
            }, {
              x: quad[1].x - offsets.right,
              y: quad[1].y + offsets.top
            }, {
              x: quad[2].x - offsets.right,
              y: quad[2].y - offsets.bottom
            }, {
              x: quad[3].x + offsets.left,
              y: quad[3].y - offsets.bottom
            }];
          }
        });
        if (!model) {
          return null;
        }
        const offset = await _assertClassBrand(_ElementHandle_brand, this, _getTopLeftCornerOfFrame).call(this);
        if (!offset) {
          return null;
        }
        for (const attribute of ['content', 'padding', 'border', 'margin']) {
          for (const point of model[attribute]) {
            point.x += offset.x;
            point.y += offset.y;
          }
        }
        return model;
      }
      async screenshot(options = {}) {
        const {
          scrollIntoView = true,
          clip
        } = options;
        const page = this.frame.page();
        
        if (scrollIntoView) {
          await this.scrollIntoViewIfNeeded();
        }
        const elementClip = await _assertClassBrand(_ElementHandle_brand, this, _nonEmptyVisibleBoundingBox).call(this);
        const [pageLeft, pageTop] = await this.evaluate(() => {
          if (!window.visualViewport) {
            throw new Error('window.visualViewport is not supported.');
          }
          return [window.visualViewport.pageLeft, window.visualViewport.pageTop];
        });
        elementClip.x += pageLeft;
        elementClip.y += pageTop;
        if (clip) {
          elementClip.x += clip.x;
          elementClip.y += clip.y;
          elementClip.height = clip.height;
          elementClip.width = clip.width;
        }
        return await page.screenshot({
          ...options,
          clip: elementClip
        });
      }
      async assertConnectedElement() {
        const error = await this.evaluate(async element => {
          if (!element.isConnected) {
            return 'Node is detached from document';
          }
          if (element.nodeType !== Node.ELEMENT_NODE) {
            return 'Node is not of type HTMLElement';
          }
          return;
        });
        if (error) {
          throw new Error(error);
        }
      }
      async scrollIntoViewIfNeeded() {
        if (await this.isIntersectingViewport({
          threshold: 1
        })) {
          return;
        }
        await this.scrollIntoView();
      }
      async isIntersectingViewport(options = {}) {
        const env_5 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          await this.assertConnectedElement();
          
          const handle = await _assertClassBrand(_ElementHandle_brand, this, _asSVGElementHandle).call(this);
          const target = __addDisposableResource$8(env_5, handle && (await _assertClassBrand(_ElementHandle_brand, handle, _getOwnerSVGElement).call(handle)), false);
          return await (target ?? this).evaluate(async (element, threshold) => {
            const visibleRatio = await new Promise(resolve => {
              const observer = new IntersectionObserver(entries => {
                resolve(entries[0].intersectionRatio);
                observer.disconnect();
              });
              observer.observe(element);
            });
            return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;
          }, options.threshold ?? 0);
        } catch (e_5) {
          env_5.error = e_5;
          env_5.hasError = true;
        } finally {
          __disposeResources$8(env_5);
        }
      }
      async scrollIntoView() {
        await this.assertConnectedElement();
        await this.evaluate(async element => {
          element.scrollIntoView({
            block: 'center',
            inline: 'center',
            behavior: 'instant'
          });
        });
      }
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _getProperty_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _getProperties_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _jsonValue_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _$_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _$$_decorators = [throwIfDisposed()];
      _private_$$_decorators = [bindIsolatedHandle];
      _waitForSelector_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _isVisible_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _isHidden_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _toElement_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _clickablePoint_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _hover_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _click_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _drag_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _dragEnter_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _dragOver_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _drop_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _dragAndDrop_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _select_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _tap_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _touchStart_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _touchMove_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _touchEnd_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _focus_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _type_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _press_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _boundingBox_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _boxModel_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _screenshot_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _isIntersectingViewport_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _scrollIntoView_decorators = [throwIfDisposed(), bindIsolatedHandle];
      __esDecorate$5(_ElementHandle, null, _getProperty_decorators, {
        kind: "method",
        name: "getProperty",
        static: false,
        private: false,
        access: {
          has: obj => "getProperty" in obj,
          get: obj => obj.getProperty
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _getProperties_decorators, {
        kind: "method",
        name: "getProperties",
        static: false,
        private: false,
        access: {
          has: obj => "getProperties" in obj,
          get: obj => obj.getProperties
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _jsonValue_decorators, {
        kind: "method",
        name: "jsonValue",
        static: false,
        private: false,
        access: {
          has: obj => "jsonValue" in obj,
          get: obj => obj.jsonValue
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _$_decorators, {
        kind: "method",
        name: "$",
        static: false,
        private: false,
        access: {
          has: obj => "$" in obj,
          get: obj => obj.$
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _$$_decorators, {
        kind: "method",
        name: "$$",
        static: false,
        private: false,
        access: {
          has: obj => "$$" in obj,
          get: obj => obj.$$
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, _private_$$_descriptor = {
        value: __setFunctionName$1(async function (selector) {
          return await _assertClassBrand(_ElementHandle_brand, this, _$$impl).call(this, selector);
        }, "#$$")
      }, _private_$$_decorators, {
        kind: "method",
        name: "#$$",
        static: false,
        private: true,
        access: {
          has: obj => _ElementHandle_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_ElementHandle_brand, obj, _get_$$)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _waitForSelector_decorators, {
        kind: "method",
        name: "waitForSelector",
        static: false,
        private: false,
        access: {
          has: obj => "waitForSelector" in obj,
          get: obj => obj.waitForSelector
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _isVisible_decorators, {
        kind: "method",
        name: "isVisible",
        static: false,
        private: false,
        access: {
          has: obj => "isVisible" in obj,
          get: obj => obj.isVisible
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _isHidden_decorators, {
        kind: "method",
        name: "isHidden",
        static: false,
        private: false,
        access: {
          has: obj => "isHidden" in obj,
          get: obj => obj.isHidden
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _toElement_decorators, {
        kind: "method",
        name: "toElement",
        static: false,
        private: false,
        access: {
          has: obj => "toElement" in obj,
          get: obj => obj.toElement
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _clickablePoint_decorators, {
        kind: "method",
        name: "clickablePoint",
        static: false,
        private: false,
        access: {
          has: obj => "clickablePoint" in obj,
          get: obj => obj.clickablePoint
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _hover_decorators, {
        kind: "method",
        name: "hover",
        static: false,
        private: false,
        access: {
          has: obj => "hover" in obj,
          get: obj => obj.hover
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _click_decorators, {
        kind: "method",
        name: "click",
        static: false,
        private: false,
        access: {
          has: obj => "click" in obj,
          get: obj => obj.click
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _drag_decorators, {
        kind: "method",
        name: "drag",
        static: false,
        private: false,
        access: {
          has: obj => "drag" in obj,
          get: obj => obj.drag
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _dragEnter_decorators, {
        kind: "method",
        name: "dragEnter",
        static: false,
        private: false,
        access: {
          has: obj => "dragEnter" in obj,
          get: obj => obj.dragEnter
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _dragOver_decorators, {
        kind: "method",
        name: "dragOver",
        static: false,
        private: false,
        access: {
          has: obj => "dragOver" in obj,
          get: obj => obj.dragOver
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _drop_decorators, {
        kind: "method",
        name: "drop",
        static: false,
        private: false,
        access: {
          has: obj => "drop" in obj,
          get: obj => obj.drop
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _dragAndDrop_decorators, {
        kind: "method",
        name: "dragAndDrop",
        static: false,
        private: false,
        access: {
          has: obj => "dragAndDrop" in obj,
          get: obj => obj.dragAndDrop
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _select_decorators, {
        kind: "method",
        name: "select",
        static: false,
        private: false,
        access: {
          has: obj => "select" in obj,
          get: obj => obj.select
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _tap_decorators, {
        kind: "method",
        name: "tap",
        static: false,
        private: false,
        access: {
          has: obj => "tap" in obj,
          get: obj => obj.tap
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _touchStart_decorators, {
        kind: "method",
        name: "touchStart",
        static: false,
        private: false,
        access: {
          has: obj => "touchStart" in obj,
          get: obj => obj.touchStart
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _touchMove_decorators, {
        kind: "method",
        name: "touchMove",
        static: false,
        private: false,
        access: {
          has: obj => "touchMove" in obj,
          get: obj => obj.touchMove
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _touchEnd_decorators, {
        kind: "method",
        name: "touchEnd",
        static: false,
        private: false,
        access: {
          has: obj => "touchEnd" in obj,
          get: obj => obj.touchEnd
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _focus_decorators, {
        kind: "method",
        name: "focus",
        static: false,
        private: false,
        access: {
          has: obj => "focus" in obj,
          get: obj => obj.focus
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _type_decorators, {
        kind: "method",
        name: "type",
        static: false,
        private: false,
        access: {
          has: obj => "type" in obj,
          get: obj => obj.type
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _press_decorators, {
        kind: "method",
        name: "press",
        static: false,
        private: false,
        access: {
          has: obj => "press" in obj,
          get: obj => obj.press
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _boundingBox_decorators, {
        kind: "method",
        name: "boundingBox",
        static: false,
        private: false,
        access: {
          has: obj => "boundingBox" in obj,
          get: obj => obj.boundingBox
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _boxModel_decorators, {
        kind: "method",
        name: "boxModel",
        static: false,
        private: false,
        access: {
          has: obj => "boxModel" in obj,
          get: obj => obj.boxModel
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _screenshot_decorators, {
        kind: "method",
        name: "screenshot",
        static: false,
        private: false,
        access: {
          has: obj => "screenshot" in obj,
          get: obj => obj.screenshot
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _isIntersectingViewport_decorators, {
        kind: "method",
        name: "isIntersectingViewport",
        static: false,
        private: false,
        access: {
          has: obj => "isIntersectingViewport" in obj,
          get: obj => obj.isIntersectingViewport
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$5(_ElementHandle, null, _scrollIntoView_decorators, {
        kind: "method",
        name: "scrollIntoView",
        static: false,
        private: false,
        access: {
          has: obj => "scrollIntoView" in obj,
          get: obj => obj.scrollIntoView
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_ElementHandle, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
    })(), _ElementHandle;
    function _get_$$(_this2) {
      return _private_$$_descriptor.value;
    }
    async function _$$impl(selector) {
      const {
        updatedSelector,
        QueryHandler
      } = getQueryHandlerAndSelector(selector);
      return await AsyncIterableUtil.collect(QueryHandler.queryAll(this, updatedSelector));
    }
    async function _checkVisibility(visibility) {
      return await this.evaluate(async (element, PuppeteerUtil, visibility) => {
        return Boolean(PuppeteerUtil.checkVisibility(element, visibility));
      }, LazyArg.create(context => {
        return context.puppeteerUtil;
      }), visibility);
    }
    async function _clickableBox() {
      const boxes = await this.evaluate(element => {
        if (!(element instanceof Element)) {
          return null;
        }
        return [...element.getClientRects()].map(rect => {
          return {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          };
        });
      });
      if (!boxes?.length) {
        return null;
      }
      await _assertClassBrand(_ElementHandle_brand, this, _intersectBoundingBoxesWithFrame).call(this, boxes);
      let frame = this.frame;
      let parentFrame;
      while (parentFrame = frame?.parentFrame()) {
        const env_3 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const handle = __addDisposableResource$8(env_3, await frame.frameElement(), false);
          if (!handle) {
            throw new Error('Unsupported frame type');
          }
          const parentBox = await handle.evaluate(element => {
            
            if (element.getClientRects().length === 0) {
              return null;
            }
            const rect = element.getBoundingClientRect();
            const style = window.getComputedStyle(element);
            return {
              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
            };
          });
          if (!parentBox) {
            return null;
          }
          for (const box of boxes) {
            box.x += parentBox.left;
            box.y += parentBox.top;
          }
          await _assertClassBrand(_ElementHandle_brand, handle, _intersectBoundingBoxesWithFrame).call(handle, boxes);
          frame = parentFrame;
        } catch (e_3) {
          env_3.error = e_3;
          env_3.hasError = true;
        } finally {
          __disposeResources$8(env_3);
        }
      }
      const box = boxes.find(box => {
        return box.width >= 1 && box.height >= 1;
      });
      if (!box) {
        return null;
      }
      return {
        x: box.x,
        y: box.y,
        height: box.height,
        width: box.width
      };
    }
    async function _intersectBoundingBoxesWithFrame(boxes) {
      const {
        documentWidth,
        documentHeight
      } = await this.frame.isolatedRealm().evaluate(() => {
        return {
          documentWidth: document.documentElement.clientWidth,
          documentHeight: document.documentElement.clientHeight
        };
      });
      for (const box of boxes) {
        intersectBoundingBox(box, documentWidth, documentHeight);
      }
    }
    async function _getTopLeftCornerOfFrame() {
      const point = {
        x: 0,
        y: 0
      };
      let frame = this.frame;
      let parentFrame;
      while (parentFrame = frame?.parentFrame()) {
        const env_4 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const handle = __addDisposableResource$8(env_4, await frame.frameElement(), false);
          if (!handle) {
            throw new Error('Unsupported frame type');
          }
          const parentBox = await handle.evaluate(element => {
            
            if (element.getClientRects().length === 0) {
              return null;
            }
            const rect = element.getBoundingClientRect();
            const style = window.getComputedStyle(element);
            return {
              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
            };
          });
          if (!parentBox) {
            return null;
          }
          point.x += parentBox.left;
          point.y += parentBox.top;
          frame = parentFrame;
        } catch (e_4) {
          env_4.error = e_4;
          env_4.hasError = true;
        } finally {
          __disposeResources$8(env_4);
        }
      }
      return point;
    }
    async function _nonEmptyVisibleBoundingBox() {
      const box = await this.boundingBox();
      assert(box, 'Node is either not visible or not an HTMLElement');
      assert(box.width !== 0, 'Node has 0 width.');
      assert(box.height !== 0, 'Node has 0 height.');
      return box;
    }
    async function _asSVGElementHandle() {
      if (await this.evaluate(element => {
        return element instanceof SVGElement;
      })) {
        return this;
      } else {
        return null;
      }
    }
    async function _getOwnerSVGElement() {
      
      return await this.evaluateHandle(element => {
        if (element instanceof SVGSVGElement) {
          return element;
        }
        return element.ownerSVGElement;
      });
    }
  })();
  function intersectBoundingBox(box, width, height) {
    box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);
    box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);
  }
  var __addDisposableResource$7 = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$7 = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  exports.LocatorEvent = void 0;
  (function (LocatorEvent) {
    LocatorEvent["Action"] = "action";
  })(exports.LocatorEvent || (exports.LocatorEvent = {}));
      _defineProperty(this, "visibility", null);
      _defineProperty(this, "_timeout", 30000);
      _classPrivateFieldInitSpec(this, _ensureElementIsInTheViewport, true);
      _classPrivateFieldInitSpec(this, _waitForEnabled, true);
      _classPrivateFieldInitSpec(this, _waitForStableBoundingBox, true);
      _defineProperty(this, "operators", {
        conditions: (conditions, signal) => {
          return mergeMap(handle => {
            return merge(...conditions.map(condition => {
              return condition(handle, signal);
            })).pipe(defaultIfEmpty(handle));
          });
        },
        retryAndRaceWithSignalAndTimer: (signal, cause) => {
          const candidates = [];
          if (signal) {
            candidates.push(fromAbortSignal(signal, cause));
          }
          candidates.push(timeout(this._timeout, cause));
          return pipe(retry({
            delay: RETRY_DELAY
          }), raceWith(...candidates));
        }
      });
      _classPrivateFieldInitSpec(this, _waitForEnabledIfNeeded, (handle, signal) => {
        if (!_classPrivateFieldGet(_waitForEnabled, this)) {
          return EMPTY;
        }
        return from(handle.frame.waitForFunction(element => {
          if (!(element instanceof HTMLElement)) {
            return true;
          }
          const isNativeFormControl = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTION', 'OPTGROUP'].includes(element.nodeName);
          return !isNativeFormControl || !element.hasAttribute('disabled');
        }, {
          timeout: this._timeout,
          signal
        }, handle)).pipe(ignoreElements());
      });
      _classPrivateFieldInitSpec(this, _waitForStableBoundingBoxIfNeeded, handle => {
        if (!_classPrivateFieldGet(_waitForStableBoundingBox, this)) {
          return EMPTY;
        }
        return defer(() => {
          
          return from(handle.evaluate(element => {
            return new Promise(resolve => {
              window.requestAnimationFrame(() => {
                const rect1 = element.getBoundingClientRect();
                window.requestAnimationFrame(() => {
                  const rect2 = element.getBoundingClientRect();
                  resolve([{
                    x: rect1.x,
                    y: rect1.y,
                    width: rect1.width,
                    height: rect1.height
                  }, {
                    x: rect2.x,
                    y: rect2.y,
                    width: rect2.width,
                    height: rect2.height
                  }]);
                });
              });
            });
          }));
        }).pipe(first(([rect1, rect2]) => {
          return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
        }), retry({
          delay: RETRY_DELAY
        }), ignoreElements());
      });
      _classPrivateFieldInitSpec(this, _ensureElementIsInTheViewportIfNeeded, handle => {
        if (!_classPrivateFieldGet(_ensureElementIsInTheViewport, this)) {
          return EMPTY;
        }
        return from(handle.isIntersectingViewport({
          threshold: 0
        })).pipe(filter(isIntersectingViewport => {
          return !isIntersectingViewport;
        }), mergeMap(() => {
          return from(handle.scrollIntoView());
        }), mergeMap(() => {
          return defer(() => {
            return from(handle.isIntersectingViewport({
              threshold: 0
            }));
          }).pipe(first(identity), retry({
            delay: RETRY_DELAY
          }), ignoreElements());
        }));
      });
    }
    static race(locators) {
      return RaceLocator.create(locators);
    }
    
    get timeout() {
      return this._timeout;
    }
    setTimeout(timeout) {
      const locator = this._clone();
      locator._timeout = timeout;
      return locator;
    }
    setVisibility(visibility) {
      const locator = this._clone();
      locator.visibility = visibility;
      return locator;
    }
    setWaitForEnabled(value) {
      const locator = this._clone();
      _classPrivateFieldSet(_waitForEnabled, locator, value);
      return locator;
    }
    setEnsureElementIsInTheViewport(value) {
      const locator = this._clone();
      _classPrivateFieldSet(_ensureElementIsInTheViewport, locator, value);
      return locator;
    }
    setWaitForStableBoundingBox(value) {
      const locator = this._clone();
      _classPrivateFieldSet(_waitForStableBoundingBox, locator, value);
      return locator;
    }
    copyOptions(locator) {
      this._timeout = locator._timeout;
      this.visibility = locator.visibility;
      _classPrivateFieldSet(_waitForEnabled, this, _classPrivateFieldGet(_waitForEnabled, locator));
      _classPrivateFieldSet(_ensureElementIsInTheViewport, this, _classPrivateFieldGet(_ensureElementIsInTheViewport, locator));
      _classPrivateFieldSet(_waitForStableBoundingBox, this, _classPrivateFieldGet(_waitForStableBoundingBox, locator));
      return this;
    }
    clone() {
      return this._clone();
    }
    async waitHandle(options) {
      const cause = new Error('Locator.waitHandle');
      return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal, cause)));
    }
    async wait(options) {
      const env_1 = {
        stack: [],
        error: void 0,
        hasError: false
      };
      try {
        const handle = __addDisposableResource$7(env_1, await this.waitHandle(options), false);
        return await handle.jsonValue();
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources$7(env_1);
      }
    }
    map(mapper) {
      return new MappedLocator(this._clone(), handle => {
        
        return handle.evaluateHandle(mapper);
      });
    }
    filter(predicate) {
      return new FilteredLocator(this._clone(), async (handle, signal) => {
        await handle.frame.waitForFunction(predicate, {
          signal,
          timeout: this._timeout
        }, handle);
        return true;
      });
    }
    filterHandle(predicate) {
      return new FilteredLocator(this._clone(), predicate);
    }
    mapHandle(mapper) {
      return new MappedLocator(this._clone(), mapper);
    }
    click(options) {
      return firstValueFrom(_assertClassBrand(_Locator_brand, this, _click).call(this, options));
    }
    fill(value, options) {
      return firstValueFrom(_assertClassBrand(_Locator_brand, this, _fill).call(this, value, options));
    }
    hover(options) {
      return firstValueFrom(_assertClassBrand(_Locator_brand, this, _hover).call(this, options));
    }
    scroll(options) {
      return firstValueFrom(_assertClassBrand(_Locator_brand, this, _scroll).call(this, options));
    }
  }
  function _click(options) {
    const signal = options?.signal;
    const cause = new Error('Locator.click');
    return this._wait(options).pipe(this.operators.conditions([_classPrivateFieldGet(_ensureElementIsInTheViewportIfNeeded, this), _classPrivateFieldGet(_waitForStableBoundingBoxIfNeeded, this), _classPrivateFieldGet(_waitForEnabledIfNeeded, this)], signal), tap(() => {
      return this.emit(exports.LocatorEvent.Action, undefined);
    }), mergeMap(handle => {
      return from(handle.click(options)).pipe(catchError(err => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
  }
  function _fill(value, options) {
    const signal = options?.signal;
    const cause = new Error('Locator.fill');
    return this._wait(options).pipe(this.operators.conditions([_classPrivateFieldGet(_ensureElementIsInTheViewportIfNeeded, this), _classPrivateFieldGet(_waitForStableBoundingBoxIfNeeded, this), _classPrivateFieldGet(_waitForEnabledIfNeeded, this)], signal), tap(() => {
      return this.emit(exports.LocatorEvent.Action, undefined);
    }), mergeMap(handle => {
      return from(handle.evaluate(el => {
        if (el instanceof HTMLSelectElement) {
          return 'select';
        }
        if (el instanceof HTMLTextAreaElement) {
          return 'typeable-input';
        }
        if (el instanceof HTMLInputElement) {
          if (new Set(['textarea', 'text', 'url', 'tel', 'search', 'password', 'number', 'email']).has(el.type)) {
            return 'typeable-input';
          } else {
            return 'other-input';
          }
        }
        if (el.isContentEditable) {
          return 'contenteditable';
        }
        return 'unknown';
      })).pipe(mergeMap(inputType => {
        switch (inputType) {
          case 'select':
            return from(handle.select(value).then(noop));
          case 'contenteditable':
          case 'typeable-input':
            return from(handle.evaluate((input, newValue) => {
              const currentValue = input.isContentEditable ? input.innerText : input.value;
              
              
              if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {
                if (input.isContentEditable) {
                  input.innerText = '';
                } else {
                  input.value = '';
                }
                return newValue;
              }
              const originalValue = input.isContentEditable ? input.innerText : input.value;
              
              
              if (input.isContentEditable) {
                input.innerText = '';
                input.innerText = originalValue;
              } else {
                input.value = '';
                input.value = originalValue;
              }
              return newValue.substring(originalValue.length);
            }, value)).pipe(mergeMap(textToType => {
              return from(handle.type(textToType));
            }));
          case 'other-input':
            return from(handle.focus()).pipe(mergeMap(() => {
              return from(handle.evaluate((input, value) => {
                input.value = value;
                input.dispatchEvent(new Event('input', {
                  bubbles: true
                }));
                input.dispatchEvent(new Event('change', {
                  bubbles: true
                }));
              }, value));
            }));
          case 'unknown':
            throw new Error(`Element cannot be filled out.`);
        }
      })).pipe(catchError(err => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
  }
  function _hover(options) {
    const signal = options?.signal;
    const cause = new Error('Locator.hover');
    return this._wait(options).pipe(this.operators.conditions([_classPrivateFieldGet(_ensureElementIsInTheViewportIfNeeded, this), _classPrivateFieldGet(_waitForStableBoundingBoxIfNeeded, this)], signal), tap(() => {
      return this.emit(exports.LocatorEvent.Action, undefined);
    }), mergeMap(handle => {
      return from(handle.hover()).pipe(catchError(err => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
  }
  function _scroll(options) {
    const signal = options?.signal;
    const cause = new Error('Locator.scroll');
    return this._wait(options).pipe(this.operators.conditions([_classPrivateFieldGet(_ensureElementIsInTheViewportIfNeeded, this), _classPrivateFieldGet(_waitForStableBoundingBoxIfNeeded, this)], signal), tap(() => {
      return this.emit(exports.LocatorEvent.Action, undefined);
    }), mergeMap(handle => {
      return from(handle.evaluate((el, scrollTop, scrollLeft) => {
        if (scrollTop !== undefined) {
          el.scrollTop = scrollTop;
        }
        if (scrollLeft !== undefined) {
          el.scrollLeft = scrollLeft;
        }
      }, options?.scrollTop, options?.scrollLeft)).pipe(catchError(err => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
  }
  class FunctionLocator extends Locator {
    static create(pageOrFrame, func) {
      return new FunctionLocator(pageOrFrame, func).setTimeout('getDefaultTimeout' in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
    }
    constructor(pageOrFrame, func) {
      super();
      _classPrivateFieldInitSpec(this, _pageOrFrame, void 0);
      _classPrivateFieldInitSpec(this, _func, void 0);
      _classPrivateFieldSet(_pageOrFrame, this, pageOrFrame);
      _classPrivateFieldSet(_func, this, func);
    }
    _clone() {
      return new FunctionLocator(_classPrivateFieldGet(_pageOrFrame, this), _classPrivateFieldGet(_func, this));
    }
    _wait(options) {
      const signal = options?.signal;
      return defer(() => {
        return from(_classPrivateFieldGet(_pageOrFrame, this).waitForFunction(_classPrivateFieldGet(_func, this), {
          timeout: this.timeout,
          signal
        }));
      }).pipe(throwIfEmpty());
    }
  }
      _classPrivateFieldInitSpec(this, _waitForVisibilityIfNeeded, handle => {
        if (!this.visibility) {
          return EMPTY;
        }
        return (() => {
          switch (this.visibility) {
            case 'hidden':
              return defer(() => {
                return from(handle.isHidden());
              });
            case 'visible':
              return defer(() => {
                return from(handle.isVisible());
              });
          }
        })().pipe(first(identity), retry({
          delay: RETRY_DELAY
        }), ignoreElements());
      });
      _classPrivateFieldSet(_pageOrFrame2, this, pageOrFrame);
      _classPrivateFieldSet(_selector, this, selector);
    }
    _clone() {
      return new NodeLocator(_classPrivateFieldGet(_pageOrFrame2, this), _classPrivateFieldGet(_selector, this)).copyOptions(this);
    }
    _wait(options) {
      const signal = options?.signal;
      return defer(() => {
        return from(_classPrivateFieldGet(_pageOrFrame2, this).waitForSelector(_classPrivateFieldGet(_selector, this), {
          visible: false,
          timeout: this._timeout,
          signal
        }));
      }).pipe(filter(value => {
        return value !== null;
      }), throwIfEmpty(), this.operators.conditions([_classPrivateFieldGet(_waitForVisibilityIfNeeded, this)], signal));
    }
  }
  function checkLocatorArray(locators) {
    for (const locator of locators) {
      if (!(locator instanceof Locator)) {
        throw new Error('Unknown locator for race candidate');
      }
    }
    return locators;
  }
  const RETRY_DELAY = 100;

  var __runInitializers$4 = undefined && undefined.__runInitializers || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$4 = undefined && undefined.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind,
      key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _,
      done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? {
        get: descriptor.get,
        set: descriptor.set
      } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field") initializers.unshift(_);else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource$6 = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$6 = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  
  exports.FrameEvent = void 0;
  (function (FrameEvent) {
    FrameEvent.FrameNavigated = Symbol('Frame.FrameNavigated');
    FrameEvent.FrameSwapped = Symbol('Frame.FrameSwapped');
    FrameEvent.LifecycleEvent = Symbol('Frame.LifecycleEvent');
    FrameEvent.FrameNavigatedWithinDocument = Symbol('Frame.FrameNavigatedWithinDocument');
    FrameEvent.FrameDetached = Symbol('Frame.FrameDetached');
    FrameEvent.FrameSwappedByActivation = Symbol('Frame.FrameSwappedByActivation');
  })(exports.FrameEvent || (exports.FrameEvent = {}));
  const throwIfDetached = throwIfDisposed(frame => {
    return `Attempted to use detached Frame '${frame._id}'.`;
  });
  let Frame = ((_Frame, _document, _Frame_brand) => {
    let _classSuper = EventEmitter;
    let _instanceExtraInitializers = [];
    let _frameElement_decorators;
    let _evaluateHandle_decorators;
    let _evaluate_decorators;
    let _locator_decorators;
    let _$_decorators;
    let _$$_decorators;
    let _$eval_decorators;
    let _$$eval_decorators;
    let _waitForSelector_decorators;
    let _waitForFunction_decorators;
    let _content_decorators;
    let _addScriptTag_decorators;
    let _addStyleTag_decorators;
    let _click_decorators;
    let _focus_decorators;
    let _hover_decorators;
    let _select_decorators;
    let _tap_decorators;
    let _type_decorators;
    let _title_decorators;
      constructor() {
        super();
        _classPrivateMethodInitSpec(this, _Frame_brand);
        _defineProperty(this, "_id", __runInitializers$4(this, _instanceExtraInitializers));
        _defineProperty(this, "_parentId", void 0);
        _defineProperty(this, "_name", void 0);
        _defineProperty(this, "_hasStartedLoading", false);
        _classPrivateFieldInitSpec(this, _document, void 0);
      }
      clearDocumentHandle() {
        _classPrivateFieldSet(_document, this, undefined);
      }
      async frameElement() {
        const env_1 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const parentFrame = this.parentFrame();
          if (!parentFrame) {
            return null;
          }
          const list = __addDisposableResource$6(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {
            return document.querySelectorAll('iframe,frame');
          }), false);
          for await (const iframe_1 of transposeIterableHandle(list)) {
            const env_2 = {
              stack: [],
              error: void 0,
              hasError: false
            };
            try {
              const iframe = __addDisposableResource$6(env_2, iframe_1, false);
              const frame = await iframe.contentFrame();
              if (frame?._id === this._id) {
                return await parentFrame.mainRealm().adoptHandle(iframe);
              }
            } catch (e_1) {
              env_2.error = e_1;
              env_2.hasError = true;
            } finally {
              __disposeResources$6(env_2);
            }
          }
          return null;
        } catch (e_2) {
          env_1.error = e_2;
          env_1.hasError = true;
        } finally {
          __disposeResources$6(env_1);
        }
      }
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.mainRealm().evaluateHandle(pageFunction, ...args);
      }
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.mainRealm().evaluate(pageFunction, ...args);
      }
      locator(selectorOrFunc) {
        if (typeof selectorOrFunc === 'string') {
          return NodeLocator.create(this, selectorOrFunc);
        } else {
          return FunctionLocator.create(this, selectorOrFunc);
        }
      }
      async $(selector) {
        
        const document = await _assertClassBrand(_Frame_brand, this, _document2).call(this);
        return await document.$(selector);
      }
      async $$(selector, options) {
        
        const document = await _assertClassBrand(_Frame_brand, this, _document2).call(this);
        return await document.$$(selector, options);
      }
      async $eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
        
        const document = await _assertClassBrand(_Frame_brand, this, _document2).call(this);
        return await document.$eval(selector, pageFunction, ...args);
      }
      async $$eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
        
        const document = await _assertClassBrand(_Frame_brand, this, _document2).call(this);
        return await document.$$eval(selector, pageFunction, ...args);
      }
      async waitForSelector(selector, options = {}) {
        const {
          updatedSelector,
          QueryHandler,
          polling
        } = getQueryHandlerAndSelector(selector);
        return await QueryHandler.waitFor(this, updatedSelector, {
          polling,
          ...options
        });
      }
      async waitForFunction(pageFunction, options = {}, ...args) {
        return await this.mainRealm().waitForFunction(pageFunction, options, ...args);
      }
      async content() {
        return await this.evaluate(() => {
          let content = '';
          for (const node of document.childNodes) {
            switch (node) {
              case document.documentElement:
                content += document.documentElement.outerHTML;
                break;
              default:
                content += new XMLSerializer().serializeToString(node);
                break;
            }
          }
          return content;
        });
      }
      async setFrameContent(content) {
        throw new Error("unsupported")
      }
      name() {
        return this._name || '';
      }
      isDetached() {
        return this.detached;
      }
      get disposed() {
        return this.detached;
      }
      async addScriptTag(options) {
        let {
          content = '',
          type
        } = options;
        const {
          path
        } = options;
        if (+!!options.url + +!!path + +!!content !== 1) {
          throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');
        }
        if (path) {
          content = await environment.value.fs.promises.readFile(path, 'utf8');
          content += `
        }
        type = type ?? 'text/javascript';
        return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({
          url,
          id,
          type,
          content
        }) => {
          return await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.type = type;
            script.text = content;
            script.addEventListener('error', event => {
              reject(new Error(event.message ?? 'Could not load script'));
            }, {
              once: true
            });
            if (id) {
              script.id = id;
            }
            if (url) {
              throw new Error("unsupported")
              script.addEventListener('load', () => {
                resolve(script);
              }, {
                once: true
              });
              document.head.appendChild(script);
            } else {
              document.head.appendChild(script);
              resolve(script);
            }
          });
        }, {
          ...options,
          type,
          content
        }));
      }
      async addStyleTag(options) {
        let {
          content = ''
        } = options;
        const {
          path
        } = options;
        if (+!!options.url + +!!path + +!!content !== 1) {
          throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');
        }
        if (path) {
          content = await environment.value.fs.promises.readFile(path, 'utf8');
      async click(selector, options = {}) {
        const env_3 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const handle = __addDisposableResource$6(env_3, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          await handle.click(options);
          await handle.dispose();
        } catch (e_3) {
          env_3.error = e_3;
          env_3.hasError = true;
        } finally {
          __disposeResources$6(env_3);
        }
      }
      async focus(selector) {
        const env_4 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const handle = __addDisposableResource$6(env_4, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          await handle.focus();
        } catch (e_4) {
          env_4.error = e_4;
          env_4.hasError = true;
        } finally {
          __disposeResources$6(env_4);
        }
      }
      async hover(selector) {
        const env_5 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const handle = __addDisposableResource$6(env_5, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          await handle.hover();
        } catch (e_5) {
          env_5.error = e_5;
          env_5.hasError = true;
        } finally {
          __disposeResources$6(env_5);
        }
      }
      async select(selector, ...values) {
        const env_6 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const handle = __addDisposableResource$6(env_6, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          return await handle.select(...values);
        } catch (e_6) {
          env_6.error = e_6;
          env_6.hasError = true;
        } finally {
          __disposeResources$6(env_6);
        }
      }
      async tap(selector) {
        const env_7 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const handle = __addDisposableResource$6(env_7, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          await handle.tap();
        } catch (e_7) {
          env_7.error = e_7;
          env_7.hasError = true;
        } finally {
          __disposeResources$6(env_7);
        }
      }
      async type(selector, text, options) {
        const env_8 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const handle = __addDisposableResource$6(env_8, await this.$(selector), false);
          assert(handle, `No element found for selector: ${selector}`);
          await handle.type(text, options);
        } catch (e_8) {
          env_8.error = e_8;
          env_8.hasError = true;
        } finally {
          __disposeResources$6(env_8);
        }
      }
      async title() {
        return await this.isolatedRealm().evaluate(() => {
          return document.title;
        });
      }
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _frameElement_decorators = [throwIfDetached];
      _evaluateHandle_decorators = [throwIfDetached];
      _evaluate_decorators = [throwIfDetached];
      _locator_decorators = [throwIfDetached];
      _$_decorators = [throwIfDetached];
      _$$_decorators = [throwIfDetached];
      _$eval_decorators = [throwIfDetached];
      _$$eval_decorators = [throwIfDetached];
      _waitForSelector_decorators = [throwIfDetached];
      _waitForFunction_decorators = [throwIfDetached];
      _content_decorators = [throwIfDetached];
      _addScriptTag_decorators = [throwIfDetached];
      _addStyleTag_decorators = [throwIfDetached];
      _click_decorators = [throwIfDetached];
      _focus_decorators = [throwIfDetached];
      _hover_decorators = [throwIfDetached];
      _select_decorators = [throwIfDetached];
      _tap_decorators = [throwIfDetached];
      _type_decorators = [throwIfDetached];
      _title_decorators = [throwIfDetached];
      __esDecorate$4(_Frame, null, _frameElement_decorators, {
        kind: "method",
        name: "frameElement",
        static: false,
        private: false,
        access: {
          has: obj => "frameElement" in obj,
          get: obj => obj.frameElement
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _evaluateHandle_decorators, {
        kind: "method",
        name: "evaluateHandle",
        static: false,
        private: false,
        access: {
          has: obj => "evaluateHandle" in obj,
          get: obj => obj.evaluateHandle
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _evaluate_decorators, {
        kind: "method",
        name: "evaluate",
        static: false,
        private: false,
        access: {
          has: obj => "evaluate" in obj,
          get: obj => obj.evaluate
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _locator_decorators, {
        kind: "method",
        name: "locator",
        static: false,
        private: false,
        access: {
          has: obj => "locator" in obj,
          get: obj => obj.locator
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _$_decorators, {
        kind: "method",
        name: "$",
        static: false,
        private: false,
        access: {
          has: obj => "$" in obj,
          get: obj => obj.$
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _$$_decorators, {
        kind: "method",
        name: "$$",
        static: false,
        private: false,
        access: {
          has: obj => "$$" in obj,
          get: obj => obj.$$
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _$eval_decorators, {
        kind: "method",
        name: "$eval",
        static: false,
        private: false,
        access: {
          has: obj => "$eval" in obj,
          get: obj => obj.$eval
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _$$eval_decorators, {
        kind: "method",
        name: "$$eval",
        static: false,
        private: false,
        access: {
          has: obj => "$$eval" in obj,
          get: obj => obj.$$eval
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _waitForSelector_decorators, {
        kind: "method",
        name: "waitForSelector",
        static: false,
        private: false,
        access: {
          has: obj => "waitForSelector" in obj,
          get: obj => obj.waitForSelector
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _waitForFunction_decorators, {
        kind: "method",
        name: "waitForFunction",
        static: false,
        private: false,
        access: {
          has: obj => "waitForFunction" in obj,
          get: obj => obj.waitForFunction
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _content_decorators, {
        kind: "method",
        name: "content",
        static: false,
        private: false,
        access: {
          has: obj => "content" in obj,
          get: obj => obj.content
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _addScriptTag_decorators, {
        kind: "method",
        name: "addScriptTag",
        static: false,
        private: false,
        access: {
          has: obj => "addScriptTag" in obj,
          get: obj => obj.addScriptTag
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _addStyleTag_decorators, {
        kind: "method",
        name: "addStyleTag",
        static: false,
        private: false,
        access: {
          has: obj => "addStyleTag" in obj,
          get: obj => obj.addStyleTag
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _click_decorators, {
        kind: "method",
        name: "click",
        static: false,
        private: false,
        access: {
          has: obj => "click" in obj,
          get: obj => obj.click
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _focus_decorators, {
        kind: "method",
        name: "focus",
        static: false,
        private: false,
        access: {
          has: obj => "focus" in obj,
          get: obj => obj.focus
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _hover_decorators, {
        kind: "method",
        name: "hover",
        static: false,
        private: false,
        access: {
          has: obj => "hover" in obj,
          get: obj => obj.hover
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _select_decorators, {
        kind: "method",
        name: "select",
        static: false,
        private: false,
        access: {
          has: obj => "select" in obj,
          get: obj => obj.select
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _tap_decorators, {
        kind: "method",
        name: "tap",
        static: false,
        private: false,
        access: {
          has: obj => "tap" in obj,
          get: obj => obj.tap
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _type_decorators, {
        kind: "method",
        name: "type",
        static: false,
        private: false,
        access: {
          has: obj => "type" in obj,
          get: obj => obj.type
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$4(_Frame, null, _title_decorators, {
        kind: "method",
        name: "title",
        static: false,
        private: false,
        access: {
          has: obj => "title" in obj,
          get: obj => obj.title
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_Frame, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
    })(), _Frame;
    function _document2() {
      if (!_classPrivateFieldGet(_document, this)) {
        _classPrivateFieldSet(_document, this, this.mainRealm().evaluateHandle(() => {
          return document;
        }));
      }
      return _classPrivateFieldGet(_document, this);
    }
  })();

  const DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = 0;
    constructor() {
      _classPrivateMethodInitSpec(this, _HTTPRequest_brand);
      _defineProperty(this, "_interceptionId", void 0);
      _defineProperty(this, "_failureText", null);
      _defineProperty(this, "_response", null);
      _defineProperty(this, "_fromMemoryCache", false);
      _defineProperty(this, "_redirectChain", []);
      _defineProperty(this, "interception", {
        enabled: false,
        handled: false,
        handlers: [],
        resolutionState: {
          action: exports.InterceptResolutionAction.None
        },
        requestOverrides: {},
        response: null,
        abortReason: null
      });
    }
    continueRequestOverrides() {
      assert(this.interception.enabled, 'Request Interception is not enabled!');
      return this.interception.requestOverrides;
    }
    responseForRequest() {
      assert(this.interception.enabled, 'Request Interception is not enabled!');
      return this.interception.response;
    }
    abortErrorReason() {
      assert(this.interception.enabled, 'Request Interception is not enabled!');
      return this.interception.abortReason;
    }
    interceptResolutionState() {
      if (!this.interception.enabled) {
        return {
          action: exports.InterceptResolutionAction.Disabled
        };
      }
      if (this.interception.handled) {
        return {
          action: exports.InterceptResolutionAction.AlreadyHandled
        };
      }
      return {
        ...this.interception.resolutionState
      };
    }
    isInterceptResolutionHandled() {
      return this.interception.handled;
    }
    enqueueInterceptAction(pendingHandler) {
      this.interception.handlers.push(pendingHandler);
    }
    async finalizeInterceptions() {
      await this.interception.handlers.reduce((promiseChain, interceptAction) => {
        return promiseChain.then(interceptAction);
      }, Promise.resolve());
      this.interception.handlers = [];
      const {
        action
      } = this.interceptResolutionState();
      switch (action) {
        case 'abort':
          return await this._abort(this.interception.abortReason);
        case 'respond':
          if (this.interception.response === null) {
            throw new Error('Response is missing for the interception');
          }
          return await this._respond(this.interception.response);
        case 'continue':
          return await this._continue(this.interception.requestOverrides);
      }
    }
    async continue(overrides = {}, priority) {
      if (!_assertClassBrand(_HTTPRequest_brand, this, _canBeIntercepted).call(this)) {
        return;
      }
      assert(this.interception.enabled, 'Request Interception is not enabled!');
      assert(!this.interception.handled, 'Request is already handled!');
      if (priority === undefined) {
        return await this._continue(overrides);
      }
      this.interception.requestOverrides = overrides;
      if (this.interception.resolutionState.priority === undefined || priority > this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: exports.InterceptResolutionAction.Continue,
          priority
        };
        return;
      }
      if (priority === this.interception.resolutionState.priority) {
        if (this.interception.resolutionState.action === 'abort' || this.interception.resolutionState.action === 'respond') {
          return;
        }
        this.interception.resolutionState.action = exports.InterceptResolutionAction.Continue;
      }
      return;
    }
    async respond(response, priority) {
      if (!_assertClassBrand(_HTTPRequest_brand, this, _canBeIntercepted).call(this)) {
        return;
      }
      assert(this.interception.enabled, 'Request Interception is not enabled!');
      assert(!this.interception.handled, 'Request is already handled!');
      if (priority === undefined) {
        return await this._respond(response);
      }
      this.interception.response = response;
      if (this.interception.resolutionState.priority === undefined || priority > this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: exports.InterceptResolutionAction.Respond,
          priority
        };
        return;
      }
      if (priority === this.interception.resolutionState.priority) {
        if (this.interception.resolutionState.action === 'abort') {
          return;
        }
        this.interception.resolutionState.action = exports.InterceptResolutionAction.Respond;
      }
    }
    async abort(errorCode = 'failed', priority) {
      if (!_assertClassBrand(_HTTPRequest_brand, this, _canBeIntercepted).call(this)) {
        return;
      }
      const errorReason = errorReasons[errorCode];
      assert(errorReason, 'Unknown error code: ' + errorCode);
      assert(this.interception.enabled, 'Request Interception is not enabled!');
      assert(!this.interception.handled, 'Request is already handled!');
      if (priority === undefined) {
        return await this._abort(errorReason);
      }
      this.interception.abortReason = errorReason;
      if (this.interception.resolutionState.priority === undefined || priority >= this.interception.resolutionState.priority) {
        this.interception.resolutionState = {
          action: exports.InterceptResolutionAction.Abort,
          priority
        };
        return;
      }
    }
    static getResponse(body) {
      
      const byteBody = isString(body) ? new TextEncoder().encode(body) : body;
      return {
        contentLength: byteBody.byteLength,
        base64: typedArrayToBase64(byteBody)
      };
    }
  }
  function _canBeIntercepted() {
    return !this.url().startsWith('data:') && !this._fromMemoryCache;
  }
  exports.InterceptResolutionAction = void 0;
  (function (InterceptResolutionAction) {
    InterceptResolutionAction["Abort"] = "abort";
    InterceptResolutionAction["Respond"] = "respond";
    InterceptResolutionAction["Continue"] = "continue";
    InterceptResolutionAction["Disabled"] = "disabled";
    InterceptResolutionAction["None"] = "none";
    InterceptResolutionAction["AlreadyHandled"] = "already-handled";
  })(exports.InterceptResolutionAction || (exports.InterceptResolutionAction = {}));
  function headersArray(headers) {
    const result = [];
    for (const name in headers) {
      const value = headers[name];
      if (!Object.is(value, undefined)) {
        const values = Array.isArray(value) ? value : [value];
        result.push(...values.map(value => {
          return {
            name,
            value: value + ''
          };
        }));
      }
    }
    return result;
  }
  const STATUS_TEXTS = {
    '100': 'Continue',
    '101': 'Switching Protocols',
    '102': 'Processing',
    '103': 'Early Hints',
    '200': 'OK',
    '201': 'Created',
    '202': 'Accepted',
    '203': 'Non-Authoritative Information',
    '204': 'No Content',
    '205': 'Reset Content',
    '206': 'Partial Content',
    '207': 'Multi-Status',
    '208': 'Already Reported',
    '226': 'IM Used',
    '300': 'Multiple Choices',
    '301': 'Moved Permanently',
    '302': 'Found',
    '303': 'See Other',
    '304': 'Not Modified',
    '305': 'Use Proxy',
    '306': 'Switch Proxy',
    '307': 'Temporary Redirect',
    '308': 'Permanent Redirect',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '402': 'Payment Required',
    '403': 'Forbidden',
    '404': 'Not Found',
    '405': 'Method Not Allowed',
    '406': 'Not Acceptable',
    '407': 'Proxy Authentication Required',
    '408': 'Request Timeout',
    '409': 'Conflict',
    '410': 'Gone',
    '411': 'Length Required',
    '412': 'Precondition Failed',
    '413': 'Payload Too Large',
    '414': 'URI Too Long',
    '415': 'Unsupported Media Type',
    '416': 'Range Not Satisfiable',
    '417': 'Expectation Failed',
    '418': "I'm a teapot",
    '421': 'Misdirected Request',
    '422': 'Unprocessable Entity',
    '423': 'Locked',
    '424': 'Failed Dependency',
    '425': 'Too Early',
    '426': 'Upgrade Required',
    '428': 'Precondition Required',
    '429': 'Too Many Requests',
    '431': 'Request Header Fields Too Large',
    '451': 'Unavailable For Legal Reasons',
    '500': 'Internal Server Error',
    '501': 'Not Implemented',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable',
    '504': 'Gateway Timeout',
    '505': 'HTTP Version Not Supported',
    '506': 'Variant Also Negotiates',
    '507': 'Insufficient Storage',
    '508': 'Loop Detected',
    '510': 'Not Extended',
    '511': 'Network Authentication Required'
  };
  const errorReasons = {
    aborted: 'Aborted',
    accessdenied: 'AccessDenied',
    addressunreachable: 'AddressUnreachable',
    blockedbyclient: 'BlockedByClient',
    blockedbyresponse: 'BlockedByResponse',
    connectionaborted: 'ConnectionAborted',
    connectionclosed: 'ConnectionClosed',
    connectionfailed: 'ConnectionFailed',
    connectionrefused: 'ConnectionRefused',
    connectionreset: 'ConnectionReset',
    internetdisconnected: 'InternetDisconnected',
    namenotresolved: 'NameNotResolved',
    timedout: 'TimedOut',
    failed: 'Failed'
  };
  function handleError(error) {
    
    
    if (error.originalMessage.includes('Invalid header') || error.originalMessage.includes('Unsafe header') || error.originalMessage.includes('Expected "header"') ||
    
    error.originalMessage.includes('invalid argument')) {
      throw error;
    }
    
    
    
    debugError(error);
  }

  class HTTPResponse {
    constructor() {}
    ok() {
      
      const status = this.status();
      return status === 0 || status >= 200 && status <= 299;
    }
    async buffer() {
      const content = await this.content();
      return Buffer.from(content);
    }
    async text() {
      const content = await this.content();
      return new TextDecoder().decode(content);
    }
    async json() {
      const content = await this.text();
      return JSON.parse(content);
    }
  }

  function createIncrementalIdGenerator() {
    let id = 0;
    return () => {
      return ++id;
    };
  }

  class Keyboard {
    constructor() {}
  }
  const MouseButton = Object.freeze({
    Left: 'left',
    Right: 'right',
    Middle: 'middle',
    Back: 'back',
    Forward: 'forward'
  });
  class Mouse {
    constructor() {}
  }
  class Touchscreen {
    constructor() {
      _defineProperty(this, "idGenerator", createIncrementalIdGenerator());
      _defineProperty(this, "touches", []);
    }
    removeHandle(handle) {
      const index = this.touches.indexOf(handle);
      if (index === -1) {
        return;
      }
      this.touches.splice(index, 1);
    }
    async tap(x, y) {
      const touch = await this.touchStart(x, y);
      await touch.end();
    }
    async touchMove(x, y) {
      const touch = this.touches[0];
      if (!touch) {
        throw new TouchError('Must start a new Touch first');
      }
      return await touch.move(x, y);
    }
    async touchEnd() {
      const touch = this.touches.shift();
      if (!touch) {
        throw new TouchError('Must start a new Touch first');
      }
      await touch.end();
    }
  }

  const DEFAULT_TIMEOUT = 30000;
  class TimeoutSettings {
    constructor() {
      _classPrivateFieldInitSpec(this, _defaultTimeout, void 0);
      _classPrivateFieldInitSpec(this, _defaultNavigationTimeout, void 0);
      _classPrivateFieldSet(_defaultTimeout, this, null);
      _classPrivateFieldSet(_defaultNavigationTimeout, this, null);
    }
    setDefaultTimeout(timeout) {
      _classPrivateFieldSet(_defaultTimeout, this, timeout);
    }
    setDefaultNavigationTimeout(timeout) {
      _classPrivateFieldSet(_defaultNavigationTimeout, this, timeout);
    }
    navigationTimeout() {
      if (_classPrivateFieldGet(_defaultNavigationTimeout, this) !== null) {
        return _classPrivateFieldGet(_defaultNavigationTimeout, this);
      }
      if (_classPrivateFieldGet(_defaultTimeout, this) !== null) {
        return _classPrivateFieldGet(_defaultTimeout, this);
      }
      return DEFAULT_TIMEOUT;
    }
    timeout() {
      if (_classPrivateFieldGet(_defaultTimeout, this) !== null) {
        return _classPrivateFieldGet(_defaultTimeout, this);
      }
      return DEFAULT_TIMEOUT;
    }
  }

  var __runInitializers$3 = undefined && undefined.__runInitializers || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$3 = undefined && undefined.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind,
      key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _,
      done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? {
        get: descriptor.get,
        set: descriptor.set
      } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field") initializers.unshift(_);else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var __addDisposableResource$5 = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$5 = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  function setDefaultScreenshotOptions(options) {
    options.optimizeForSpeed ??= false;
    options.type ??= 'png';
    options.fromSurface ??= true;
    options.fullPage ??= false;
    options.omitBackground ??= false;
    options.encoding ??= 'binary';
    options.captureBeyondViewport ??= true;
  }
  let Page = ((_ref2, _Page, _requestHandlers, _inflight$, _screencastSessionCount, _startScreencastPromise, _Page_brand) => {
    let _classSuper = EventEmitter;
    let _instanceExtraInitializers = [];
    let _screenshot_decorators;
      constructor() {
        super();
        _classPrivateMethodInitSpec(this, _Page_brand);
        _defineProperty(this, "_isDragging", (__runInitializers$3(this, _instanceExtraInitializers), false));
        _defineProperty(this, "_timeoutSettings", new TimeoutSettings());
        _classPrivateFieldInitSpec(this, _requestHandlers, new WeakMap());
        _classPrivateFieldInitSpec(this, _inflight$, new ReplaySubject(1));
        _classPrivateFieldInitSpec(this, _screencastSessionCount, 0);
        _classPrivateFieldInitSpec(this, _startScreencastPromise, void 0);
            return response.request();
          }))).pipe(filter(request => {
            return request.id === originalRequest.id;
          }), take(1), map(() => {
            return -1;
          })));
        }), mergeScan((acc, addend) => {
          return of(acc + addend);
      on(type, handler) {
      off(type, handler) {
      get accessibility() {
        return this.mainFrame().accessibility;
      }
      locator(selectorOrFunc) {
        if (typeof selectorOrFunc === 'string') {
          return NodeLocator.create(this, selectorOrFunc);
        } else {
          return FunctionLocator.create(this, selectorOrFunc);
        }
      }
      locatorRace(locators) {
        return Locator.race(locators);
      }
      async $(selector) {
        return await this.mainFrame().$(selector);
      }
      async $$(selector, options) {
        return await this.mainFrame().$$(selector, options);
      }
      async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        return await this.mainFrame().evaluateHandle(pageFunction, ...args);
      }
      async $eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
        return await this.mainFrame().$eval(selector, pageFunction, ...args);
      }
      async $$eval(selector, pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
        return await this.mainFrame().$$eval(selector, pageFunction, ...args);
      }
      async addScriptTag(options) {
        return await this.mainFrame().addScriptTag(options);
      }
      async addStyleTag(options) {
        return await this.mainFrame().addStyleTag(options);
      }
      url() {
        return this.mainFrame().url();
      }
      async content() {
        return await this.mainFrame().content();
      }
      async setContent(html, options) {
        await this.mainFrame().setContent(html, options);
      }
      async goto(url, options) {
        return await this.mainFrame().goto(url, options);
      }
      async waitForNavigation(options = {}) {
        return await this.mainFrame().waitForNavigation(options);
      }
      waitForRequest(urlOrPredicate, options = {}) {
        const {
          timeout: ms = this._timeoutSettings.timeout(),
          signal
        } = options;
        if (typeof urlOrPredicate === 'string') {
          const url = urlOrPredicate;
          urlOrPredicate = request => {
            return request.url() === url;
          };
        }
      waitForResponse(urlOrPredicate, options = {}) {
        const {
          timeout: ms = this._timeoutSettings.timeout(),
          signal
        } = options;
        if (typeof urlOrPredicate === 'string') {
          const url = urlOrPredicate;
          urlOrPredicate = response => {
            return response.url() === url;
          };
        }
      waitForNetworkIdle(options = {}) {
        return firstValueFrom(this.waitForNetworkIdle$(options));
      }
      waitForNetworkIdle$(options = {}) {
        const {
          timeout: ms = this._timeoutSettings.timeout(),
          idleTime = NETWORK_IDLE_TIME,
          concurrency = 0,
          signal
        } = options;
        return _classPrivateFieldGet(_inflight$, this).pipe(switchMap(inflight => {
          if (inflight > concurrency) {
            return EMPTY;
          }
          return timer(idleTime);
      async waitForFrame(urlOrPredicate, options = {}) {
        const {
          timeout: ms = this.getDefaultTimeout(),
          signal
        } = options;
        const predicate = isString(urlOrPredicate) ? frame => {
          return urlOrPredicate === frame.url();
        } : urlOrPredicate;
      async emulate(device) {
        await Promise.all([this.setUserAgent(device.userAgent), this.setViewport(device.viewport)]);
      }
      async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        return await this.mainFrame().evaluate(pageFunction, ...args);
      }
      async _maybeWriteTypedArrayToFile(path, typedArray) {
        if (!path) {
          return;
        }
        await environment.value.fs.promises.writeFile(path, typedArray);
      }
      async screencast(options = {}) {
        const ScreenRecorder = environment.value.ScreenRecorder;
        const [width, height, devicePixelRatio] = await _assertClassBrand(_Page_brand, this, _getNativePixelDimensions).call(this);
        let crop;
        if (options.crop) {
          const {
            x,
            y,
            width: cropWidth,
            height: cropHeight
          } = roundRectangle(normalizeRectangle(options.crop));
          if (x < 0 || y < 0) {
            throw new Error(`\`crop.x\` and \`crop.y\` must be greater than or equal to 0.`);
          }
          if (cropWidth <= 0 || cropHeight <= 0) {
            throw new Error(`\`crop.height\` and \`crop.width\` must be greater than or equal to 0.`);
          }
          const viewportWidth = width / devicePixelRatio;
          const viewportHeight = height / devicePixelRatio;
          if (x + cropWidth > viewportWidth) {
            throw new Error(`\`crop.width\` cannot be larger than the viewport width (${viewportWidth}).`);
          }
          if (y + cropHeight > viewportHeight) {
            throw new Error(`\`crop.height\` cannot be larger than the viewport height (${viewportHeight}).`);
          }
          crop = {
            x: x * devicePixelRatio,
            y: y * devicePixelRatio,
            width: cropWidth * devicePixelRatio,
            height: cropHeight * devicePixelRatio
          };
        }
        if (options.speed !== undefined && options.speed <= 0) {
          throw new Error(`\`speed\` must be greater than 0.`);
        }
        if (options.scale !== undefined && options.scale <= 0) {
          throw new Error(`\`scale\` must be greater than 0.`);
        }
        const recorder = new ScreenRecorder(this, width, height, {
          ...options,
          path: options.ffmpegPath,
          crop
        });
        try {
          await this._startScreencast();
        } catch (error) {
          void recorder.stop();
          throw error;
        }
        if (options.path) {
          const {
            createWriteStream
          } = environment.value.fs;
          const stream = createWriteStream(options.path, 'binary');
          recorder.pipe(stream);
        }
        return recorder;
      }
      async _startScreencast() {
        var _this$screencastSessi;
        _classPrivateFieldSet(_screencastSessionCount, this, (_this$screencastSessi = _classPrivateFieldGet(_screencastSessionCount, this), ++_this$screencastSessi));
        if (!_classPrivateFieldGet(_startScreencastPromise, this)) {
          _classPrivateFieldSet(_startScreencastPromise, this, this.mainFrame().client.send('Page.startScreencast', {
            format: 'png'
          }).then(() => {
            
            return new Promise(resolve => {
              return this.mainFrame().client.once('Page.screencastFrame', () => {
                return resolve();
              });
            });
          }));
        }
        await _classPrivateFieldGet(_startScreencastPromise, this);
      }
      async _stopScreencast() {
        var _this$screencastSessi2;
        _classPrivateFieldSet(_screencastSessionCount, this, (_this$screencastSessi2 = _classPrivateFieldGet(_screencastSessionCount, this), --_this$screencastSessi2));
        if (!_classPrivateFieldGet(_startScreencastPromise, this)) {
          return;
        }
        _classPrivateFieldSet(_startScreencastPromise, this, undefined);
        if (_classPrivateFieldGet(_screencastSessionCount, this) === 0) {
          await this.mainFrame().client.send('Page.stopScreencast');
        }
      }
      async screenshot(userOptions = {}) {
        const env_2 = {
          stack: [],
          error: void 0,
          hasError: false
        };
        try {
          const _guard = __addDisposableResource$5(env_2, await this.browserContext().startScreenshot(), false);
          const options = {
            ...userOptions,
            clip: userOptions.clip ? {
              ...userOptions.clip
            } : undefined
          };
          if (options.type === undefined && options.path !== undefined) {
            const filePath = options.path;
            
            const extension = filePath.slice(filePath.lastIndexOf('.') + 1).toLowerCase();
            switch (extension) {
              case 'png':
                options.type = 'png';
                break;
              case 'jpeg':
              case 'jpg':
                options.type = 'jpeg';
                break;
              case 'webp':
                options.type = 'webp';
                break;
            }
          }
          if (options.quality !== undefined) {
            if (options.quality < 0 || options.quality > 100) {
              throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);
            }
            if (options.type === undefined || !['jpeg', 'webp'].includes(options.type)) {
              throw new Error(`${options.type ?? 'png'} screenshots do not support 'quality'.`);
            }
          }
          if (options.clip) {
            if (options.clip.width <= 0) {
              throw new Error("'width' in 'clip' must be positive.");
            }
            if (options.clip.height <= 0) {
              throw new Error("'height' in 'clip' must be positive.");
            }
          }
          setDefaultScreenshotOptions(options);
          const stack = __addDisposableResource$5(env_2, new AsyncDisposableStack(), true);
          if (options.clip) {
            if (options.fullPage) {
              throw new Error("'clip' and 'fullPage' are mutually exclusive");
            }
            options.clip = roundRectangle(normalizeRectangle(options.clip));
          } else {
            if (options.fullPage) {
              
              
              
              if (!options.captureBeyondViewport) {
                const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {
                  const element = document.documentElement;
                  return {
                    width: element.scrollWidth,
                    height: element.scrollHeight
                  };
                });
                const viewport = this.viewport();
                await this.setViewport({
                  ...viewport,
                  ...scrollDimensions
                });
                stack.defer(async () => {
                  await this.setViewport(viewport).catch(debugError);
                });
              }
            } else {
              options.captureBeyondViewport = false;
            }
          }
          const data = await this._screenshot(options);
          if (options.encoding === 'base64') {
            return data;
          }
          const typedArray = stringToTypedArray(data, true);
          await this._maybeWriteTypedArrayToFile(options.path, typedArray);
          return typedArray;
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          const result_1 = __disposeResources$5(env_2);
          if (result_1) await result_1;
        }
      }
      async title() {
        return await this.mainFrame().title();
      }
      click(selector, options) {
        return this.mainFrame().click(selector, options);
      }
      focus(selector) {
        return this.mainFrame().focus(selector);
      }
      hover(selector) {
        return this.mainFrame().hover(selector);
      }
      select(selector, ...values) {
        return this.mainFrame().select(selector, ...values);
      }
      tap(selector) {
        return this.mainFrame().tap(selector);
      }
      type(selector, text, options) {
        return this.mainFrame().type(selector, text, options);
      }
      async waitForSelector(selector, options = {}) {
        return await this.mainFrame().waitForSelector(selector, options);
      }
      waitForFunction(pageFunction, options, ...args) {
        return this.mainFrame().waitForFunction(pageFunction, options, ...args);
      }
      [asyncDisposeSymbol]() {
        return this.close();
      }
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate$3(_Page, null, _screenshot_decorators, {
        kind: "method",
        name: "screenshot",
        static: false,
        private: false,
        access: {
          has: obj => "screenshot" in obj,
          get: obj => obj.screenshot
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_Page, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
    })(), _Page;
    async function _getNativePixelDimensions() {
      const env_1 = {
        stack: [],
        error: void 0,
        hasError: false
      };
      try {
        const viewport = this.viewport();
        const stack = __addDisposableResource$5(env_1, new DisposableStack(), false);
        if (viewport && viewport.deviceScaleFactor !== 0) {
          await this.setViewport({
            ...viewport,
            deviceScaleFactor: 0
          });
          stack.defer(() => {
            void this.setViewport(viewport).catch(debugError);
          });
        }
        return await this.mainFrame().isolatedRealm().evaluate(() => {
          return [window.visualViewport.width * window.devicePixelRatio, window.visualViewport.height * window.devicePixelRatio, window.devicePixelRatio];
        });
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources$5(env_1);
      }
    }
  })();
  const supportedMetrics$1 = new Set(['Timestamp', 'Documents', 'Frames', 'JSEventListeners', 'Nodes', 'LayoutCount', 'RecalcStyleCount', 'LayoutDuration', 'RecalcStyleDuration', 'ScriptDuration', 'TaskDuration', 'JSHeapUsedSize', 'JSHeapTotalSize']);
  class WaitTask {
    constructor(world, options, fn, ...args) {
      _classPrivateFieldInitSpec(this, _world, void 0);
      _classPrivateFieldInitSpec(this, _polling, void 0);
      _classPrivateFieldInitSpec(this, _root, void 0);
      _classPrivateFieldInitSpec(this, _fn, void 0);
      _classPrivateFieldInitSpec(this, _args, void 0);
      _classPrivateFieldInitSpec(this, _timeout, void 0);
      _classPrivateFieldInitSpec(this, _timeoutError2, void 0);
      _classPrivateFieldInitSpec(this, _result, Deferred.create());
      _classPrivateFieldInitSpec(this, _poller, void 0);
      _classPrivateFieldInitSpec(this, _signal, void 0);
      _classPrivateFieldInitSpec(this, _reruns, []);
      _classPrivateFieldInitSpec(this, _onAbortSignal, () => {
        void this.terminate(_classPrivateFieldGet(_signal, this)?.reason);
      });
      _classPrivateFieldSet(_world, this, world);
      _classPrivateFieldSet(_polling, this, options.polling);
      _classPrivateFieldSet(_root, this, options.root);
      _classPrivateFieldSet(_signal, this, options.signal);
      _classPrivateFieldGet(_signal, this)?.addEventListener('abort', _classPrivateFieldGet(_onAbortSignal, this), {
        once: true
      });
      switch (typeof fn) {
        case 'string':
          _classPrivateFieldSet(_fn, this, `() => {return (${fn});}`);
          break;
        default:
          _classPrivateFieldSet(_fn, this, stringifyFunction(fn));
          break;
      }
      _classPrivateFieldSet(_args, this, args);
      _classPrivateFieldGet(_world, this).taskManager.add(this);
      if (options.timeout) {
        _classPrivateFieldSet(_timeoutError2, this, new TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`));
        _classPrivateFieldSet(_timeout, this, setTimeout(() => {
          void this.terminate(_classPrivateFieldGet(_timeoutError2, this));
        }, options.timeout));
      }
      void this.rerun();
    }
    get result() {
      return _classPrivateFieldGet(_result, this).valueOrThrow();
    }
    async rerun() {
      for (const prev of _classPrivateFieldGet(_reruns, this)) {
        prev.abort();
      }
      _classPrivateFieldGet(_reruns, this).length = 0;
      const controller = new AbortController();
      _classPrivateFieldGet(_reruns, this).push(controller);
      try {
        switch (_classPrivateFieldGet(_polling, this)) {
          case 'raf':
            _classPrivateFieldSet(_poller, this, await _classPrivateFieldGet(_world, this).evaluateHandle(({
              RAFPoller,
              createFunction
            }, fn, ...args) => {
              const fun = createFunction(fn);
              return new RAFPoller(() => {
                return fun(...args);
              });
            }, LazyArg.create(context => {
              return context.puppeteerUtil;
            }), _classPrivateFieldGet(_fn, this), ..._classPrivateFieldGet(_args, this)));
            break;
          case 'mutation':
            _classPrivateFieldSet(_poller, this, await _classPrivateFieldGet(_world, this).evaluateHandle(({
              MutationPoller,
              createFunction
            }, root, fn, ...args) => {
              const fun = createFunction(fn);
              return new MutationPoller(() => {
                return fun(...args);
              }, root || document);
            }, LazyArg.create(context => {
              return context.puppeteerUtil;
            }), _classPrivateFieldGet(_root, this), _classPrivateFieldGet(_fn, this), ..._classPrivateFieldGet(_args, this)));
            break;
          default:
            _classPrivateFieldSet(_poller, this, await _classPrivateFieldGet(_world, this).evaluateHandle(({
              IntervalPoller,
              createFunction
            }, ms, fn, ...args) => {
              const fun = createFunction(fn);
              return new IntervalPoller(() => {
                return fun(...args);
              }, ms);
            }, LazyArg.create(context => {
              return context.puppeteerUtil;
            }), _classPrivateFieldGet(_polling, this), _classPrivateFieldGet(_fn, this), ..._classPrivateFieldGet(_args, this)));
            break;
        }
        await _classPrivateFieldGet(_poller, this).evaluate(poller => {
          void poller.start();
        });
        const result = await _classPrivateFieldGet(_poller, this).evaluateHandle(poller => {
          return poller.result();
        });
        _classPrivateFieldGet(_result, this).resolve(result);
        await this.terminate();
      } catch (error) {
        if (controller.signal.aborted) {
          return;
        }
        const badError = this.getBadError(error);
        if (badError) {
          await this.terminate(badError);
        }
      }
    }
    async terminate(error) {
      _classPrivateFieldGet(_world, this).taskManager.delete(this);
      _classPrivateFieldGet(_signal, this)?.removeEventListener('abort', _classPrivateFieldGet(_onAbortSignal, this));
      clearTimeout(_classPrivateFieldGet(_timeout, this));
      if (error && !_classPrivateFieldGet(_result, this).finished()) {
        _classPrivateFieldGet(_result, this).reject(error);
      }
      if (_classPrivateFieldGet(_poller, this)) {
        try {
          await _classPrivateFieldGet(_poller, this).evaluate(async poller => {
            await poller.stop();
          });
          if (_classPrivateFieldGet(_poller, this)) {
            await _classPrivateFieldGet(_poller, this).dispose();
            _classPrivateFieldSet(_poller, this, undefined);
          }
        } catch {
          
        }
      }
    }
    getBadError(error) {
      if (isErrorLike(error)) {
        
        
        
        if (error.message.includes('Execution context is not available in detached frame')) {
          return new Error('Waiting failed: Frame detached');
        }
        
        
        if (error.message.includes('Execution context was destroyed')) {
          return;
        }
        
        
        if (error.message.includes('Cannot find context with specified id')) {
          return;
        }
        
        
        if (error.message.includes('DiscardedBrowsingContextError')) {
          return;
        }
        return error;
      }
      return new Error('WaitTask failed with an error', {
        cause: error
      });
    }
  }
    dispose() {
      _classPrivateFieldSet(_disposed3, this, true);
      this.taskManager.terminateAll(new Error('waitForFunction failed: frame got detached.'));
    }
  exports.TargetType = void 0;
  (function (TargetType) {
    TargetType["PAGE"] = "page";
    TargetType["BACKGROUND_PAGE"] = "background_page";
    TargetType["SERVICE_WORKER"] = "service_worker";
    TargetType["SHARED_WORKER"] = "shared_worker";
    TargetType["BROWSER"] = "browser";
    TargetType["WEBVIEW"] = "webview";
    TargetType["OTHER"] = "other";
    TargetType["TAB"] = "tab";
  })(exports.TargetType || (exports.TargetType = {}));
  class Target {
    constructor() {}
    async worker() {
      return null;
    }
    async page() {
      return null;
    }
  }

    constructor(url) {
      super();
      _defineProperty(this, "timeoutSettings", new TimeoutSettings());
      _classPrivateFieldInitSpec(this, _url, void 0);
      _classPrivateFieldSet(_url, this, url);
    }
    url() {
      return _classPrivateFieldGet(_url, this);
    }
    async evaluate(func, ...args) {
      func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);
      return await this.mainRealm().evaluate(func, ...args);
    }
    async evaluateHandle(func, ...args) {
      func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);
      return await this.mainRealm().evaluateHandle(func, ...args);
    }
    async close() {
      throw new UnsupportedOperation('WebWorker.close() is not supported');
    }
  }

  var __addDisposableResource$4 = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$4 = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  class Accessibility {
    constructor(realm, frameId = '') {
      _classPrivateFieldInitSpec(this, _realm, void 0);
      _classPrivateFieldInitSpec(this, _frameId, void 0);
      _classPrivateFieldSet(_realm, this, realm);
      _classPrivateFieldSet(_frameId, this, frameId);
    }
    async snapshot(options = {}) {
      const {
        interestingOnly = true,
        root = null,
        includeIframes = false
      } = options;
      const {
        nodes
      } = await _classPrivateFieldGet(_realm, this).environment.client.send('Accessibility.getFullAXTree', {
        frameId: _classPrivateFieldGet(_frameId, this)
      });
      let backendNodeId;
      if (root) {
        const {
          node
        } = await _classPrivateFieldGet(_realm, this).environment.client.send('DOM.describeNode', {
          objectId: root.id
        });
        backendNodeId = node.backendNodeId;
      }
      const defaultRoot = AXNode.createTree(_classPrivateFieldGet(_realm, this), nodes);
      const populateIframes = async root => {
        if (root.payload.role?.value === 'Iframe') {
          const env_1 = {
            stack: [],
            error: void 0,
            hasError: false
          };
          try {
            if (!root.payload.backendDOMNodeId) {
              return;
            }
            const handle = __addDisposableResource$4(env_1, await _classPrivateFieldGet(_realm, this).adoptBackendNode(root.payload.backendDOMNodeId), false);
            if (!handle || !('contentFrame' in handle)) {
              return;
            }
            const frame = await handle.contentFrame();
            if (!frame) {
              return;
            }
            const iframeSnapshot = await frame.accessibility.snapshot(options);
            root.iframeSnapshot = iframeSnapshot ?? undefined;
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources$4(env_1);
          }
        }
        for (const child of root.children) {
          await populateIframes(child);
        }
      };
      let needle = defaultRoot;
      if (!defaultRoot) {
        return null;
      }
      if (includeIframes) {
        await populateIframes(defaultRoot);
      }
      if (backendNodeId) {
        needle = defaultRoot.find(node => {
          return node.payload.backendDOMNodeId === backendNodeId;
        });
      }
      if (!needle) {
        return null;
      }
      if (!interestingOnly) {
        return this.serializeTree(needle)[0] ?? null;
      }
      const interestingNodes = new Set();
      this.collectInterestingNodes(interestingNodes, defaultRoot, false);
      if (!interestingNodes.has(needle)) {
        return null;
      }
      return this.serializeTree(needle, interestingNodes)[0] ?? null;
    }
    serializeTree(node, interestingNodes) {
      const children = [];
      for (const child of node.children) {
        children.push(...this.serializeTree(child, interestingNodes));
      }
      if (interestingNodes && !interestingNodes.has(node)) {
        return children;
      }
      const serializedNode = node.serialize();
      if (children.length) {
        serializedNode.children = children;
      }
      if (node.iframeSnapshot) {
        if (!serializedNode.children) {
          serializedNode.children = [];
        }
        serializedNode.children.push(node.iframeSnapshot);
      }
      return [serializedNode];
    }
    collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl) || node.iframeSnapshot) {
        collection.add(node);
      }
      if (node.isLeafNode()) {
        return;
      }
      insideControl = insideControl || node.isControl();
      for (const child of node.children) {
        this.collectInterestingNodes(collection, child, insideControl);
      }
    }
  }
  class AXNode {
    constructor(realm, payload) {
      _classPrivateMethodInitSpec(this, _AXNode_brand);
      _defineProperty(this, "payload", void 0);
      _defineProperty(this, "children", []);
      _defineProperty(this, "iframeSnapshot", void 0);
      _classPrivateFieldInitSpec(this, _richlyEditable, false);
      _classPrivateFieldInitSpec(this, _editable, false);
      _classPrivateFieldInitSpec(this, _focusable, false);
      _classPrivateFieldInitSpec(this, _hidden, false);
      _classPrivateFieldInitSpec(this, _name, void 0);
      _classPrivateFieldInitSpec(this, _role, void 0);
      _classPrivateFieldInitSpec(this, _ignored, void 0);
      _classPrivateFieldInitSpec(this, _cachedHasFocusableChild, void 0);
      _classPrivateFieldInitSpec(this, _realm2, void 0);
      this.payload = payload;
      _classPrivateFieldSet(_name, this, this.payload.name ? this.payload.name.value : '');
      _classPrivateFieldSet(_role, this, this.payload.role ? this.payload.role.value : 'Unknown');
      _classPrivateFieldSet(_ignored, this, this.payload.ignored);
      _classPrivateFieldSet(_realm2, this, realm);
      for (const property of this.payload.properties || []) {
        if (property.name === 'editable') {
          _classPrivateFieldSet(_richlyEditable, this, property.value.value === 'richtext');
          _classPrivateFieldSet(_editable, this, true);
        }
        if (property.name === 'focusable') {
          _classPrivateFieldSet(_focusable, this, property.value.value);
        }
        if (property.name === 'hidden') {
          _classPrivateFieldSet(_hidden, this, property.value.value);
        }
      }
    }
    find(predicate) {
      if (predicate(this)) {
        return this;
      }
      for (const child of this.children) {
        const result = child.find(predicate);
        if (result) {
          return result;
        }
      }
      return null;
    }
    isLeafNode() {
      if (!this.children.length) {
        return true;
      }
      
      
      
      
      if (_assertClassBrand(_AXNode_brand, this, _isPlainTextField).call(this) || _assertClassBrand(_AXNode_brand, this, _isTextOnlyObject).call(this)) {
        return true;
      }
      
      
      
      
      switch (_classPrivateFieldGet(_role, this)) {
        case 'doc-cover':
        case 'graphics-symbol':
        case 'img':
        case 'image':
        case 'Meter':
        case 'scrollbar':
        case 'slider':
        case 'separator':
        case 'progressbar':
          return true;
      }
      
      if (_assertClassBrand(_AXNode_brand, this, _hasFocusableChild).call(this)) {
        return false;
      }
      if (_classPrivateFieldGet(_focusable, this) && _classPrivateFieldGet(_name, this)) {
        return true;
      }
      if (_classPrivateFieldGet(_role, this) === 'heading' && _classPrivateFieldGet(_name, this)) {
        return true;
      }
      return false;
    }
    isControl() {
      switch (_classPrivateFieldGet(_role, this)) {
        case 'button':
        case 'checkbox':
        case 'ColorWell':
        case 'combobox':
        case 'DisclosureTriangle':
        case 'listbox':
        case 'menu':
        case 'menubar':
        case 'menuitem':
        case 'menuitemcheckbox':
        case 'menuitemradio':
        case 'radio':
        case 'scrollbar':
        case 'searchbox':
        case 'slider':
        case 'spinbutton':
        case 'switch':
        case 'tab':
        case 'textbox':
        case 'tree':
        case 'treeitem':
          return true;
        default:
          return false;
      }
    }
    isInteresting(insideControl) {
      const role = _classPrivateFieldGet(_role, this);
      if (role === 'Ignored' || _classPrivateFieldGet(_hidden, this) || _classPrivateFieldGet(_ignored, this)) {
        return false;
      }
      if (_classPrivateFieldGet(_focusable, this) || _classPrivateFieldGet(_richlyEditable, this)) {
        return true;
      }
      
      if (this.isControl()) {
        return true;
      }
      
      if (insideControl) {
        return false;
      }
      return this.isLeafNode() && !!_classPrivateFieldGet(_name, this);
    }
    serialize() {
      const properties = new Map();
      for (const property of this.payload.properties || []) {
        properties.set(property.name.toLowerCase(), property.value.value);
      }
      if (this.payload.name) {
        properties.set('name', this.payload.name.value);
      }
      if (this.payload.value) {
        properties.set('value', this.payload.value.value);
      }
      if (this.payload.description) {
        properties.set('description', this.payload.description.value);
      }
      const node = {
        role: _classPrivateFieldGet(_role, this),
        elementHandle: async () => {
          if (!this.payload.backendDOMNodeId) {
            return null;
          }
          return await _classPrivateFieldGet(_realm2, this).adoptBackendNode(this.payload.backendDOMNodeId);
        }
      };
      const userStringProperties = ['name', 'value', 'description', 'keyshortcuts', 'roledescription', 'valuetext'];
      const getUserStringPropertyValue = key => {
        return properties.get(key);
      };
      for (const userStringProperty of userStringProperties) {
        if (!properties.has(userStringProperty)) {
          continue;
        }
        node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
      }
      const booleanProperties = ['disabled', 'expanded', 'focused', 'modal', 'multiline', 'multiselectable', 'readonly', 'required', 'selected'];
      const getBooleanPropertyValue = key => {
        return properties.get(key);
      };
      for (const booleanProperty of booleanProperties) {
        
        
        
        if (booleanProperty === 'focused' && _classPrivateFieldGet(_role, this) === 'RootWebArea') {
          continue;
        }
        const value = getBooleanPropertyValue(booleanProperty);
        if (!value) {
          continue;
        }
        node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
      }
      const tristateProperties = ['checked', 'pressed'];
      for (const tristateProperty of tristateProperties) {
        if (!properties.has(tristateProperty)) {
          continue;
        }
        const value = properties.get(tristateProperty);
        node[tristateProperty] = value === 'mixed' ? 'mixed' : value === 'true' ? true : false;
      }
      const numericalProperties = ['level', 'valuemax', 'valuemin'];
      const getNumericalPropertyValue = key => {
        return properties.get(key);
      };
      for (const numericalProperty of numericalProperties) {
        if (!properties.has(numericalProperty)) {
          continue;
        }
        node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
      }
      const tokenProperties = ['autocomplete', 'haspopup', 'invalid', 'orientation'];
      const getTokenPropertyValue = key => {
        return properties.get(key);
      };
      for (const tokenProperty of tokenProperties) {
        const value = getTokenPropertyValue(tokenProperty);
        if (!value || value === 'false') {
          continue;
        }
        node[tokenProperty] = getTokenPropertyValue(tokenProperty);
      }
      return node;
    }
    static createTree(realm, payloads) {
      const nodeById = new Map();
      for (const payload of payloads) {
        nodeById.set(payload.nodeId, new AXNode(realm, payload));
      }
      for (const node of nodeById.values()) {
        for (const childId of node.payload.childIds || []) {
          const child = nodeById.get(childId);
          if (child) {
            node.children.push(child);
          }
        }
      }
      return nodeById.values().next().value ?? null;
    }
  }
  function _isPlainTextField() {
    if (_classPrivateFieldGet(_richlyEditable, this)) {
      return false;
    }
    if (_classPrivateFieldGet(_editable, this)) {
      return true;
    }
    return _classPrivateFieldGet(_role, this) === 'textbox' || _classPrivateFieldGet(_role, this) === 'searchbox';
  }
  function _isTextOnlyObject() {
    const role = _classPrivateFieldGet(_role, this);
    return role === 'LineBreak' || role === 'text' || role === 'InlineTextBox' || role === 'StaticText';
  }
  function _hasFocusableChild() {
    if (_classPrivateFieldGet(_cachedHasFocusableChild, this) === undefined) {
      _classPrivateFieldSet(_cachedHasFocusableChild, this, false);
      for (const child of this.children) {
        if (_classPrivateFieldGet(_focusable, child) || _assertClassBrand(_AXNode_brand, child, _hasFocusableChild).call(child)) {
          _classPrivateFieldSet(_cachedHasFocusableChild, this, true);
          break;
        }
      }
    }
    return _classPrivateFieldGet(_cachedHasFocusableChild, this);
  }
  var __addDisposableResource$3 = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$3 = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
    async run(context, id, args, isTrivial) {
      const stack = new DisposableStack();
      try {
        if (!isTrivial) {
          const env_1 = {
            stack: [],
            error: void 0,
            hasError: false
          };
          try {
            
            const handles = __addDisposableResource$3(env_1, await context.evaluateHandle((name, seq) => {
              
              return globalThis[name].args.get(seq);
            }, _classPrivateFieldGet(_name2, this), id), false);
            const properties = await handles.getProperties();
            for (const [index, handle] of properties) {
              
              
              if (index in args) {
                switch (handle.remoteObject().subtype) {
                  case 'node':
                    args[+index] = handle;
                    break;
                  default:
                    stack.use(handle);
                }
              } else {
                stack.use(handle);
              }
            }
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources$3(env_1);
          }
        }
        await context.evaluate((name, seq, result) => {
          
          const callbacks = globalThis[name].callbacks;
          callbacks.get(seq).resolve(result);
          callbacks.delete(seq);
        }, _classPrivateFieldGet(_name2, this), id, await _classPrivateFieldGet(_fn2, this).call(this, ...args));
        for (const arg of args) {
          if (arg instanceof JSHandle) {
            stack.use(arg);
          }
        }
      } catch (error) {
        if (isErrorLike(error)) {
          await context.evaluate((name, seq, message, stack) => {
            const error = new Error(message);
            error.stack = stack;
            
            const callbacks = globalThis[name].callbacks;
            callbacks.get(seq).reject(error);
            callbacks.delete(seq);
          }, _classPrivateFieldGet(_name2, this), id, error.message, error.stack).catch(debugError);
        } else {
          await context.evaluate((name, seq, error) => {
            
            const callbacks = globalThis[name].callbacks;
            callbacks.get(seq).reject(error);
            callbacks.delete(seq);
          }, _classPrivateFieldGet(_name2, this), id, error).catch(debugError);
        }
      }
    }
  }

    constructor(type, text, args, stackTraceLocations, frame) {
      _classPrivateFieldInitSpec(this, _type2, void 0);
      _classPrivateFieldInitSpec(this, _text, void 0);
      _classPrivateFieldInitSpec(this, _args2, void 0);
      _classPrivateFieldInitSpec(this, _stackTraceLocations, void 0);
      _classPrivateFieldInitSpec(this, _frame, void 0);
      _classPrivateFieldSet(_type2, this, type);
      _classPrivateFieldSet(_text, this, text);
      _classPrivateFieldSet(_args2, this, args);
      _classPrivateFieldSet(_stackTraceLocations, this, stackTraceLocations);
      _classPrivateFieldSet(_frame, this, frame);
    }
    type() {
      return _classPrivateFieldGet(_type2, this);
    }
    text() {
      return _classPrivateFieldGet(_text, this);
    }
    args() {
      return _classPrivateFieldGet(_args2, this);
    }
    location() {
      return _classPrivateFieldGet(_stackTraceLocations, this)[0] ?? (_classPrivateFieldGet(_frame, this) ? {
        url: _classPrivateFieldGet(_frame, this).url()
      } : {});
    }
    stackTrace() {
      return _classPrivateFieldGet(_stackTraceLocations, this);
    }
  }

    constructor(element, event) {
      _classPrivateFieldInitSpec(this, _element, void 0);
      _classPrivateFieldInitSpec(this, _multiple, void 0);
      _classPrivateFieldInitSpec(this, _handled, false);
      _classPrivateFieldSet(_element, this, element);
      _classPrivateFieldSet(_multiple, this, event.mode !== 'selectSingle');
    }
    isMultiple() {
      return _classPrivateFieldGet(_multiple, this);
    }
    async accept(paths) {
      assert(!_classPrivateFieldGet(_handled, this), 'Cannot accept FileChooser which is already handled!');
      _classPrivateFieldSet(_handled, this, true);
      await _classPrivateFieldGet(_element, this).uploadFile(...paths);
    }
    async cancel() {
      assert(!_classPrivateFieldGet(_handled, this), 'Cannot cancel FileChooser which is already handled!');
      _classPrivateFieldSet(_handled, this, true);
      
      
      await _classPrivateFieldGet(_element, this).evaluate(element => {
        element.dispatchEvent(new Event('cancel', {
          bubbles: true
        }));
      });
    }
  }

  
  exports.NetworkManagerEvent = void 0;
  (function (NetworkManagerEvent) {
    NetworkManagerEvent.Request = Symbol('NetworkManager.Request');
    NetworkManagerEvent.RequestServedFromCache = Symbol('NetworkManager.RequestServedFromCache');
    NetworkManagerEvent.Response = Symbol('NetworkManager.Response');
    NetworkManagerEvent.RequestFailed = Symbol('NetworkManager.RequestFailed');
    NetworkManagerEvent.RequestFinished = Symbol('NetworkManager.RequestFinished');
  })(exports.NetworkManagerEvent || (exports.NetworkManagerEvent = {}));

  class CallbackRegistry {
    constructor() {
      _classPrivateFieldInitSpec(this, _callbacks, new Map());
      _classPrivateFieldInitSpec(this, _idGenerator, createIncrementalIdGenerator());
    }
    create(label, timeout, request) {
      const callback = new Callback(_classPrivateFieldGet(_idGenerator, this).call(this), label, timeout);
      _classPrivateFieldGet(_callbacks, this).set(callback.id, callback);
      try {
        request(callback.id);
      } catch (error) {
        
        
        callback.promise.catch(debugError).finally(() => {
          _classPrivateFieldGet(_callbacks, this).delete(callback.id);
        });
        callback.reject(error);
        throw error;
      }
      
      return callback.promise.finally(() => {
        _classPrivateFieldGet(_callbacks, this).delete(callback.id);
      });
    }
    reject(id, message, originalMessage) {
      const callback = _classPrivateFieldGet(_callbacks, this).get(id);
      if (!callback) {
        return;
      }
      this._reject(callback, message, originalMessage);
    }
    rejectRaw(id, error) {
      const callback = _classPrivateFieldGet(_callbacks, this).get(id);
      if (!callback) {
        return;
      }
      callback.reject(error);
    }
    _reject(callback, errorMessage, originalMessage) {
      let error;
      let message;
      if (errorMessage instanceof ProtocolError) {
        error = errorMessage;
        error.cause = callback.error;
        message = errorMessage.message;
      } else {
        error = callback.error;
        message = errorMessage;
      }
      callback.reject(rewriteError$1(error, `Protocol error (${callback.label}): ${message}`, originalMessage));
    }
    resolve(id, value) {
      const callback = _classPrivateFieldGet(_callbacks, this).get(id);
      if (!callback) {
        return;
      }
      callback.resolve(value);
    }
    clear() {
      for (const callback of _classPrivateFieldGet(_callbacks, this).values()) {
        
        this._reject(callback, new TargetCloseError('Target closed'));
      }
      _classPrivateFieldGet(_callbacks, this).clear();
    }
    getPendingProtocolErrors() {
      const result = [];
      for (const callback of _classPrivateFieldGet(_callbacks, this).values()) {
        result.push(new Error(`${callback.label} timed out. Trace: ${callback.error.stack}`));
      }
      return result;
    }
  }
  class CdpCDPSession extends CDPSession {
    constructor(connection, targetType, sessionId, parentSessionId, rawErrors) {
      super();
      _classPrivateFieldInitSpec(this, _sessionId, void 0);
      _classPrivateFieldInitSpec(this, _targetType, void 0);
      _classPrivateFieldInitSpec(this, _callbacks2, new CallbackRegistry());
      _classPrivateFieldInitSpec(this, _connection, void 0);
      _classPrivateFieldInitSpec(this, _parentSessionId, void 0);
      _classPrivateFieldInitSpec(this, _target, void 0);
      _classPrivateFieldInitSpec(this, _rawErrors, false);
      _classPrivateFieldInitSpec(this, _detached, false);
      _classPrivateFieldSet(_connection, this, connection);
      _classPrivateFieldSet(_targetType, this, targetType);
      _classPrivateFieldSet(_sessionId, this, sessionId);
      _classPrivateFieldSet(_parentSessionId, this, parentSessionId);
      _classPrivateFieldSet(_rawErrors, this, rawErrors);
    }
    setTarget(target) {
      _classPrivateFieldSet(_target, this, target);
    }
    target() {
      assert(_classPrivateFieldGet(_target, this), 'Target must exist');
      return _classPrivateFieldGet(_target, this);
    }
    connection() {
      return _classPrivateFieldGet(_connection, this);
    }
    get detached() {
      return _classPrivateFieldGet(_connection, this)._closed || _classPrivateFieldGet(_detached, this);
    }
    parentSession() {
      if (!_classPrivateFieldGet(_parentSessionId, this)) {
        
        
        return this;
      }
      const parent = _classPrivateFieldGet(_connection, this)?.session(_classPrivateFieldGet(_parentSessionId, this));
      return parent ?? undefined;
    }
    send(method, params, options) {
      if (this.detached) {
        return Promise.reject(new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${_classPrivateFieldGet(_targetType, this)} has been closed.`));
      }
      return _classPrivateFieldGet(_connection, this)._rawSend(_classPrivateFieldGet(_callbacks2, this), method, params, _classPrivateFieldGet(_sessionId, this), options);
    }
    onMessage(object) {
      if (object.id) {
        if (object.error) {
          if (_classPrivateFieldGet(_rawErrors, this)) {
            _classPrivateFieldGet(_callbacks2, this).rejectRaw(object.id, object.error);
          } else {
            _classPrivateFieldGet(_callbacks2, this).reject(object.id, createProtocolErrorMessage(object), object.error.message);
          }
        } else {
          _classPrivateFieldGet(_callbacks2, this).resolve(object.id, object.result);
        }
      } else {
        assert(!object.id);
        this.emit(object.method, object.params);
      }
    }
    async detach() {
      if (this.detached) {
        throw new Error(`Session already detached. Most likely the ${_classPrivateFieldGet(_targetType, this)} has been closed.`);
      }
      await _classPrivateFieldGet(_connection, this).send('Target.detachFromTarget', {
        sessionId: _classPrivateFieldGet(_sessionId, this)
      });
      _classPrivateFieldSet(_detached, this, true);
    }
    onClosed() {
      _classPrivateFieldGet(_callbacks2, this).clear();
      _classPrivateFieldSet(_detached, this, true);
      this.emit(exports.CDPSessionEvent.Disconnected, undefined);
    }
    id() {
      return _classPrivateFieldGet(_sessionId, this);
    }
    getPendingProtocolErrors() {
      return _classPrivateFieldGet(_callbacks2, this).getPendingProtocolErrors();
    }
  }

  const debugProtocolSend = debug('puppeteer:protocol:SEND ');
  const debugProtocolReceive = debug('puppeteer:protocol:RECV ');
  class Connection extends EventEmitter {
    constructor(url, transport, delay = 0, timeout, rawErrors = false) {
      super();
      _classPrivateMethodInitSpec(this, _Connection_brand);
      _classPrivateFieldInitSpec(this, _url2, void 0);
      _classPrivateFieldInitSpec(this, _transport, void 0);
      _classPrivateFieldInitSpec(this, _delay2, void 0);
      _classPrivateFieldInitSpec(this, _timeout2, void 0);
      _classPrivateFieldInitSpec(this, _sessions, new Map());
      _classPrivateFieldInitSpec(this, _closed, false);
      _classPrivateFieldInitSpec(this, _manuallyAttached, new Set());
      _classPrivateFieldInitSpec(this, _callbacks3, void 0);
      _classPrivateFieldInitSpec(this, _rawErrors2, false);
      _classPrivateFieldSet(_rawErrors2, this, rawErrors);
      _classPrivateFieldSet(_callbacks3, this, new CallbackRegistry());
      _classPrivateFieldSet(_url2, this, url);
      _classPrivateFieldSet(_delay2, this, delay);
      _classPrivateFieldSet(_timeout2, this, timeout ?? 180_000);
      _classPrivateFieldSet(_transport, this, transport);
      _classPrivateFieldGet(_transport, this).onmessage = this.onMessage.bind(this);
      _classPrivateFieldGet(_transport, this).onclose = _assertClassBrand(_Connection_brand, this, _onClose).bind(this);
    }
    static fromSession(session) {
      return session.connection();
    }
    get delay() {
      return _classPrivateFieldGet(_delay2, this);
    }
    get timeout() {
      return _classPrivateFieldGet(_timeout2, this);
    }
    get _closed() {
      return _classPrivateFieldGet(_closed, this);
    }
    get _sessions() {
      return _classPrivateFieldGet(_sessions, this);
    }
    _session(sessionId) {
      return _classPrivateFieldGet(_sessions, this).get(sessionId) || null;
    }
    session(sessionId) {
      return this._session(sessionId);
    }
    url() {
      return _classPrivateFieldGet(_url2, this);
    }
    send(method, params, options) {
      
      
      
      
      
      
      return this._rawSend(_classPrivateFieldGet(_callbacks3, this), method, params, undefined, options);
    }
    _rawSend(callbacks, method, params, sessionId, options) {
      if (_classPrivateFieldGet(_closed, this)) {
        return Promise.reject(new Error('Protocol error: Connection closed.'));
      }
      return callbacks.create(method, options?.timeout ?? _classPrivateFieldGet(_timeout2, this), id => {
        const stringifiedMessage = JSON.stringify({
          method,
          params,
          id,
          sessionId
        });
        debugProtocolSend(stringifiedMessage);
        _classPrivateFieldGet(_transport, this).send(stringifiedMessage);
      });
    }
    async closeBrowser() {
      await this.send('Browser.close');
    }
    async onMessage(message) {
      if (_classPrivateFieldGet(_delay2, this)) {
        await new Promise(r => {
          return setTimeout(r, _classPrivateFieldGet(_delay2, this));
        });
      }
      debugProtocolReceive(message);
      const object = JSON.parse(message);
      if (object.method === 'Target.attachedToTarget') {
        const sessionId = object.params.sessionId;
        const session = new CdpCDPSession(this, object.params.targetInfo.type, sessionId, object.sessionId, _classPrivateFieldGet(_rawErrors2, this));
        _classPrivateFieldGet(_sessions, this).set(sessionId, session);
        this.emit(exports.CDPSessionEvent.SessionAttached, session);
        const parentSession = _classPrivateFieldGet(_sessions, this).get(object.sessionId);
        if (parentSession) {
          parentSession.emit(exports.CDPSessionEvent.SessionAttached, session);
        }
      } else if (object.method === 'Target.detachedFromTarget') {
        const session = _classPrivateFieldGet(_sessions, this).get(object.params.sessionId);
        if (session) {
          session.onClosed();
          _classPrivateFieldGet(_sessions, this).delete(object.params.sessionId);
          this.emit(exports.CDPSessionEvent.SessionDetached, session);
          const parentSession = _classPrivateFieldGet(_sessions, this).get(object.sessionId);
          if (parentSession) {
            parentSession.emit(exports.CDPSessionEvent.SessionDetached, session);
          }
        }
      }
      if (object.sessionId) {
        const session = _classPrivateFieldGet(_sessions, this).get(object.sessionId);
        if (session) {
          session.onMessage(object);
        }
      } else if (object.id) {
        if (object.error) {
          if (_classPrivateFieldGet(_rawErrors2, this)) {
            _classPrivateFieldGet(_callbacks3, this).rejectRaw(object.id, object.error);
          } else {
            _classPrivateFieldGet(_callbacks3, this).reject(object.id, createProtocolErrorMessage(object), object.error.message);
          }
        } else {
          _classPrivateFieldGet(_callbacks3, this).resolve(object.id, object.result);
        }
      } else {
        this.emit(object.method, object.params);
      }
    }
    dispose() {
      _assertClassBrand(_Connection_brand, this, _onClose).call(this);
      _classPrivateFieldGet(_transport, this).close();
    }
    isAutoAttached(targetId) {
      return !_classPrivateFieldGet(_manuallyAttached, this).has(targetId);
    }
    async _createSession(targetInfo, isAutoAttachEmulated = true) {
      if (!isAutoAttachEmulated) {
        _classPrivateFieldGet(_manuallyAttached, this).add(targetInfo.targetId);
      }
      const {
        sessionId
      } = await this.send('Target.attachToTarget', {
        targetId: targetInfo.targetId,
        flatten: true
      });
      _classPrivateFieldGet(_manuallyAttached, this).delete(targetInfo.targetId);
      const session = _classPrivateFieldGet(_sessions, this).get(sessionId);
      if (!session) {
        throw new Error('CDPSession creation failed.');
      }
      return session;
    }
    async createSession(targetInfo) {
      return await this._createSession(targetInfo, false);
    }
    getPendingProtocolErrors() {
      const result = [];
      result.push(..._classPrivateFieldGet(_callbacks3, this).getPendingProtocolErrors());
      for (const session of _classPrivateFieldGet(_sessions, this).values()) {
        result.push(...session.getPendingProtocolErrors());
      }
      return result;
    }
  }
  function _onClose() {
    if (_classPrivateFieldGet(_closed, this)) {
      return;
    }
    _classPrivateFieldSet(_closed, this, true);
    _classPrivateFieldGet(_transport, this).onmessage = undefined;
    _classPrivateFieldGet(_transport, this).onclose = undefined;
    _classPrivateFieldGet(_callbacks3, this).clear();
    for (const session of _classPrivateFieldGet(_sessions, this).values()) {
      session.onClosed();
    }
    _classPrivateFieldGet(_sessions, this).clear();
    this.emit(exports.CDPSessionEvent.Disconnected, undefined);
  }
  function isTargetClosedError(error) {
    return error instanceof TargetCloseError;
  }

  class Coverage {
    constructor(client) {
      _classPrivateFieldInitSpec(this, _jsCoverage, void 0);
      _classPrivateFieldInitSpec(this, _cssCoverage, void 0);
      _classPrivateFieldSet(_jsCoverage, this, new JSCoverage(client));
      _classPrivateFieldSet(_cssCoverage, this, new CSSCoverage(client));
    }
    updateClient(client) {
      _classPrivateFieldGet(_jsCoverage, this).updateClient(client);
      _classPrivateFieldGet(_cssCoverage, this).updateClient(client);
    }
    async startJSCoverage(options = {}) {
      return await _classPrivateFieldGet(_jsCoverage, this).start(options);
    }
    async stopJSCoverage() {
      return await _classPrivateFieldGet(_jsCoverage, this).stop();
    }
    async startCSSCoverage(options = {}) {
      return await _classPrivateFieldGet(_cssCoverage, this).start(options);
    }
    async stopCSSCoverage() {
      return await _classPrivateFieldGet(_cssCoverage, this).stop();
    }
  }
    constructor(client) {
      _classPrivateMethodInitSpec(this, _JSCoverage_brand);
      _classPrivateFieldInitSpec(this, _client2, void 0);
      _classPrivateFieldInitSpec(this, _enabled, false);
      _classPrivateFieldInitSpec(this, _scriptURLs, new Map());
      _classPrivateFieldInitSpec(this, _scriptSources, new Map());
      _classPrivateFieldInitSpec(this, _subscriptions, void 0);
      _classPrivateFieldInitSpec(this, _resetOnNavigation, false);
      _classPrivateFieldInitSpec(this, _reportAnonymousScripts, false);
      _classPrivateFieldInitSpec(this, _includeRawScriptCoverage, false);
      _classPrivateFieldSet(_client2, this, client);
    }
    updateClient(client) {
      _classPrivateFieldSet(_client2, this, client);
    }
    async start(options = {}) {
      assert(!_classPrivateFieldGet(_enabled, this), 'JSCoverage is already enabled');
      const {
        resetOnNavigation = true,
        reportAnonymousScripts = false,
        includeRawScriptCoverage = false,
        useBlockCoverage = true
      } = options;
      _classPrivateFieldSet(_resetOnNavigation, this, resetOnNavigation);
      _classPrivateFieldSet(_reportAnonymousScripts, this, reportAnonymousScripts);
      _classPrivateFieldSet(_includeRawScriptCoverage, this, includeRawScriptCoverage);
      _classPrivateFieldSet(_enabled, this, true);
      _classPrivateFieldGet(_scriptURLs, this).clear();
      _classPrivateFieldGet(_scriptSources, this).clear();
      _classPrivateFieldSet(_subscriptions, this, new DisposableStack());
      const clientEmitter = _classPrivateFieldGet(_subscriptions, this).use(new EventEmitter(_classPrivateFieldGet(_client2, this)));
      clientEmitter.on('Debugger.scriptParsed', _assertClassBrand(_JSCoverage_brand, this, _onScriptParsed).bind(this));
      clientEmitter.on('Runtime.executionContextsCleared', _assertClassBrand(_JSCoverage_brand, this, _onExecutionContextsCleared).bind(this));
      await Promise.all([_classPrivateFieldGet(_client2, this).send('Profiler.enable'), _classPrivateFieldGet(_client2, this).send('Profiler.startPreciseCoverage', {
        callCount: _classPrivateFieldGet(_includeRawScriptCoverage, this),
        detailed: useBlockCoverage
      }), _classPrivateFieldGet(_client2, this).send('Debugger.enable'), _classPrivateFieldGet(_client2, this).send('Debugger.setSkipAllPauses', {
        skip: true
      })]);
    }
    async stop() {
      assert(_classPrivateFieldGet(_enabled, this), 'JSCoverage is not enabled');
      _classPrivateFieldSet(_enabled, this, false);
      const result = await Promise.all([_classPrivateFieldGet(_client2, this).send('Profiler.takePreciseCoverage'), _classPrivateFieldGet(_client2, this).send('Profiler.stopPreciseCoverage'), _classPrivateFieldGet(_client2, this).send('Profiler.disable'), _classPrivateFieldGet(_client2, this).send('Debugger.disable')]);
      _classPrivateFieldGet(_subscriptions, this)?.dispose();
      const coverage = [];
      const profileResponse = result[0];
      for (const entry of profileResponse.result) {
        let url = _classPrivateFieldGet(_scriptURLs, this).get(entry.scriptId);
        if (!url && _classPrivateFieldGet(_reportAnonymousScripts, this)) {
          url = 'debugger:
        }
        const text = _classPrivateFieldGet(_scriptSources, this).get(entry.scriptId);
        if (text === undefined || url === undefined) {
          continue;
        }
        const flattenRanges = [];
        for (const func of entry.functions) {
          flattenRanges.push(...func.ranges);
        }
        const ranges = convertToDisjointRanges(flattenRanges);
        if (!_classPrivateFieldGet(_includeRawScriptCoverage, this)) {
          coverage.push({
            url,
            ranges,
            text
          });
        } else {
          coverage.push({
            url,
            ranges,
            text,
            rawScriptCoverage: entry
          });
        }
      }
      return coverage;
    }
  }
  function _onExecutionContextsCleared() {
    if (!_classPrivateFieldGet(_resetOnNavigation, this)) {
      return;
    }
    _classPrivateFieldGet(_scriptURLs, this).clear();
    _classPrivateFieldGet(_scriptSources, this).clear();
  }
  async function _onScriptParsed(event) {
    
    if (PuppeteerURL.isPuppeteerURL(event.url)) {
      return;
    }
    
    if (!event.url && !_classPrivateFieldGet(_reportAnonymousScripts, this)) {
      return;
    }
    try {
      const response = await _classPrivateFieldGet(_client2, this).send('Debugger.getScriptSource', {
        scriptId: event.scriptId
      });
      _classPrivateFieldGet(_scriptURLs, this).set(event.scriptId, event.url);
      _classPrivateFieldGet(_scriptSources, this).set(event.scriptId, response.scriptSource);
    } catch (error) {
      
      debugError(error);
    }
  }
    updateClient(client) {
      _classPrivateFieldSet(_client3, this, client);
    }
    async start(options = {}) {
      assert(!_classPrivateFieldGet(_enabled2, this), 'CSSCoverage is already enabled');
      const {
        resetOnNavigation = true
      } = options;
      _classPrivateFieldSet(_resetOnNavigation2, this, resetOnNavigation);
      _classPrivateFieldSet(_enabled2, this, true);
      _classPrivateFieldGet(_stylesheetURLs, this).clear();
      _classPrivateFieldGet(_stylesheetSources, this).clear();
      _classPrivateFieldSet(_eventListeners, this, new DisposableStack());
      const clientEmitter = _classPrivateFieldGet(_eventListeners, this).use(new EventEmitter(_classPrivateFieldGet(_client3, this)));
      clientEmitter.on('CSS.styleSheetAdded', _assertClassBrand(_CSSCoverage_brand, this, _onStyleSheet).bind(this));
      clientEmitter.on('Runtime.executionContextsCleared', _assertClassBrand(_CSSCoverage_brand, this, _onExecutionContextsCleared2).bind(this));
      await Promise.all([_classPrivateFieldGet(_client3, this).send('DOM.enable'), _classPrivateFieldGet(_client3, this).send('CSS.enable'), _classPrivateFieldGet(_client3, this).send('CSS.startRuleUsageTracking')]);
    }
    async stop() {
      assert(_classPrivateFieldGet(_enabled2, this), 'CSSCoverage is not enabled');
      _classPrivateFieldSet(_enabled2, this, false);
      const ruleTrackingResponse = await _classPrivateFieldGet(_client3, this).send('CSS.stopRuleUsageTracking');
      await Promise.all([_classPrivateFieldGet(_client3, this).send('CSS.disable'), _classPrivateFieldGet(_client3, this).send('DOM.disable')]);
      _classPrivateFieldGet(_eventListeners, this)?.dispose();
      
      const styleSheetIdToCoverage = new Map();
      for (const entry of ruleTrackingResponse.ruleUsage) {
        let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
        if (!ranges) {
          ranges = [];
          styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
        }
        ranges.push({
          startOffset: entry.startOffset,
          endOffset: entry.endOffset,
          count: entry.used ? 1 : 0
        });
      }
      const coverage = [];
      for (const styleSheetId of _classPrivateFieldGet(_stylesheetURLs, this).keys()) {
        const url = _classPrivateFieldGet(_stylesheetURLs, this).get(styleSheetId);
        assert(typeof url !== 'undefined', `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
        const text = _classPrivateFieldGet(_stylesheetSources, this).get(styleSheetId);
        assert(typeof text !== 'undefined', `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
        const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
        coverage.push({
          url,
          ranges,
          text
        });
      }
      return coverage;
    }
  }
  function _onExecutionContextsCleared2() {
    if (!_classPrivateFieldGet(_resetOnNavigation2, this)) {
      return;
    }
    _classPrivateFieldGet(_stylesheetURLs, this).clear();
    _classPrivateFieldGet(_stylesheetSources, this).clear();
  }
  async function _onStyleSheet(event) {
    const header = event.header;
    
    if (!header.sourceURL) {
      return;
    }
    try {
      const response = await _classPrivateFieldGet(_client3, this).send('CSS.getStyleSheetText', {
        styleSheetId: header.styleSheetId
      });
      _classPrivateFieldGet(_stylesheetURLs, this).set(header.styleSheetId, header.sourceURL);
      _classPrivateFieldGet(_stylesheetSources, this).set(header.styleSheetId, response.text);
    } catch (error) {
      
      debugError(error);
    }
  }
  function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range of nestedRanges) {
      points.push({
        offset: range.startOffset,
        type: 0,
        range
      });
      points.push({
        offset: range.endOffset,
        type: 1,
        range
      });
    }
    
    points.sort((a, b) => {
      
      if (a.offset !== b.offset) {
        return a.offset - b.offset;
      }
      
      if (a.type !== b.type) {
        return b.type - a.type;
      }
      const aLength = a.range.endOffset - a.range.startOffset;
      const bLength = b.range.endOffset - b.range.startOffset;
      
      if (a.type === 0) {
        return bLength - aLength;
      }
      
      return aLength - bLength;
    });
    const hitCountStack = [];
    const results = [];
    let lastOffset = 0;
    
    for (const point of points) {
      if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
        const lastResult = results[results.length - 1];
        if (lastResult && lastResult.end === lastOffset) {
          lastResult.end = point.offset;
        } else {
          results.push({
            start: lastOffset,
            end: point.offset
          });
        }
      }
      lastOffset = point.offset;
      if (point.type === 0) {
        hitCountStack.push(point.range.count);
      } else {
        hitCountStack.pop();
      }
    }
    
    return results.filter(range => {
      return range.end - range.start > 0;
    });
  }

  let EmulationManager = ((_EmulationManager, _client5, _emulatingMobile, _hasTouch, _states, _viewportState, _idleOverridesState, _timezoneState, _visionDeficiencyState, _cpuThrottlingState, _mediaFeaturesState, _mediaTypeState, _geoLocationState, _defaultBackgroundColorState, _javascriptEnabledState, _secondaryClients, _EmulationManager_brand) => {
    let _instanceExtraInitializers = [];
    let _private_applyViewport_decorators;
    let _private_applyViewport_descriptor;
    let _private_emulateIdleState_decorators;
    let _private_emulateIdleState_descriptor;
    let _private_emulateTimezone_decorators;
    let _private_emulateTimezone_descriptor;
    let _private_emulateVisionDeficiency_decorators;
    let _private_emulateVisionDeficiency_descriptor;
    let _private_emulateCpuThrottling_decorators;
    let _private_emulateCpuThrottling_descriptor;
    let _private_emulateMediaFeatures_decorators;
    let _private_emulateMediaFeatures_descriptor;
    let _private_emulateMediaType_decorators;
    let _private_emulateMediaType_descriptor;
    let _private_setGeolocation_decorators;
    let _private_setGeolocation_descriptor;
    let _private_setDefaultBackgroundColor_decorators;
    let _private_setDefaultBackgroundColor_descriptor;
    let _private_setJavaScriptEnabled_decorators;
    let _private_setJavaScriptEnabled_descriptor;
      async resetDefaultBackgroundColor() {
        await _classPrivateFieldGet(_defaultBackgroundColorState, this).setState({
          active: true,
          color: undefined
        });
      }
      async setTransparentBackgroundColor() {
        await _classPrivateFieldGet(_defaultBackgroundColorState, this).setState({
          active: true,
          color: {
            r: 0,
            g: 0,
            b: 0,
            a: 0
          }
        });
      }
      async setJavaScriptEnabled(enabled) {
        await _classPrivateFieldGet(_javascriptEnabledState, this).setState({
          active: true,
          javaScriptEnabled: enabled
        });
      }
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
      _private_applyViewport_decorators = [invokeAtMostOnceForArguments];
      _private_emulateIdleState_decorators = [invokeAtMostOnceForArguments];
      _private_emulateTimezone_decorators = [invokeAtMostOnceForArguments];
      _private_emulateVisionDeficiency_decorators = [invokeAtMostOnceForArguments];
      _private_emulateCpuThrottling_decorators = [invokeAtMostOnceForArguments];
      _private_emulateMediaFeatures_decorators = [invokeAtMostOnceForArguments];
      _private_emulateMediaType_decorators = [invokeAtMostOnceForArguments];
      _private_setGeolocation_decorators = [invokeAtMostOnceForArguments];
      _private_setDefaultBackgroundColor_decorators = [invokeAtMostOnceForArguments];
      _private_setJavaScriptEnabled_decorators = [invokeAtMostOnceForArguments];
      __esDecorate$2(_EmulationManager, _private_applyViewport_descriptor = {
        value: __setFunctionName(async function (client, viewportState) {
          if (!viewportState.viewport) {
            await Promise.all([client.send('Emulation.clearDeviceMetricsOverride'), client.send('Emulation.setTouchEmulationEnabled', {
              enabled: false
            })]).catch(debugError);
            return;
          }
          const {
            viewport
          } = viewportState;
          const mobile = viewport.isMobile || false;
          const width = viewport.width;
          const height = viewport.height;
          const deviceScaleFactor = viewport.deviceScaleFactor ?? 1;
          const screenOrientation = viewport.isLandscape ? {
            angle: 90,
            type: 'landscapePrimary'
          } : {
            angle: 0,
            type: 'portraitPrimary'
          };
          const hasTouch = viewport.hasTouch || false;
          await Promise.all([client.send('Emulation.setDeviceMetricsOverride', {
            mobile,
            width,
            height,
            deviceScaleFactor,
            screenOrientation
          }).catch(err => {
            if (err.message.includes('Target does not support metrics override')) {
              debugError(err);
              return;
            }
            throw err;
          }), client.send('Emulation.setTouchEmulationEnabled', {
            enabled: hasTouch
          })]);
        }, "#applyViewport")
      }, _private_applyViewport_decorators, {
        kind: "method",
        name: "#applyViewport",
        static: false,
        private: true,
        access: {
          has: obj => _EmulationManager_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_EmulationManager_brand, obj, _get_applyViewport)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$2(_EmulationManager, _private_emulateIdleState_descriptor = {
        value: __setFunctionName(async function (client, idleStateState) {
          if (!idleStateState.active) {
            return;
          }
          if (idleStateState.overrides) {
            await client.send('Emulation.setIdleOverride', {
              isUserActive: idleStateState.overrides.isUserActive,
              isScreenUnlocked: idleStateState.overrides.isScreenUnlocked
            });
          } else {
            await client.send('Emulation.clearIdleOverride');
          }
        }, "#emulateIdleState")
      }, _private_emulateIdleState_decorators, {
        kind: "method",
        name: "#emulateIdleState",
        static: false,
        private: true,
        access: {
          has: obj => _EmulationManager_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_EmulationManager_brand, obj, _get_emulateIdleState)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$2(_EmulationManager, _private_emulateTimezone_descriptor = {
        value: __setFunctionName(async function (client, timezoneState) {
          if (!timezoneState.active) {
            return;
          }
          try {
            await client.send('Emulation.setTimezoneOverride', {
              timezoneId: timezoneState.timezoneId || ''
            });
          } catch (error) {
            if (isErrorLike(error) && error.message.includes('Invalid timezone')) {
              throw new Error(`Invalid timezone ID: ${timezoneState.timezoneId}`);
            }
            throw error;
          }
        }, "#emulateTimezone")
      }, _private_emulateTimezone_decorators, {
        kind: "method",
        name: "#emulateTimezone",
        static: false,
        private: true,
        access: {
          has: obj => _EmulationManager_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_EmulationManager_brand, obj, _get_emulateTimezone)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$2(_EmulationManager, _private_emulateVisionDeficiency_descriptor = {
        value: __setFunctionName(async function (client, visionDeficiency) {
          if (!visionDeficiency.active) {
            return;
          }
          await client.send('Emulation.setEmulatedVisionDeficiency', {
            type: visionDeficiency.visionDeficiency || 'none'
          });
        }, "#emulateVisionDeficiency")
      }, _private_emulateVisionDeficiency_decorators, {
        kind: "method",
        name: "#emulateVisionDeficiency",
        static: false,
        private: true,
        access: {
          has: obj => _EmulationManager_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_EmulationManager_brand, obj, _get_emulateVisionDeficiency)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$2(_EmulationManager, _private_emulateCpuThrottling_descriptor = {
        value: __setFunctionName(async function (client, state) {
          if (!state.active) {
            return;
          }
          await client.send('Emulation.setCPUThrottlingRate', {
            rate: state.factor ?? 1
          });
        }, "#emulateCpuThrottling")
      }, _private_emulateCpuThrottling_decorators, {
        kind: "method",
        name: "#emulateCpuThrottling",
        static: false,
        private: true,
        access: {
          has: obj => _EmulationManager_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_EmulationManager_brand, obj, _get_emulateCpuThrottling)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$2(_EmulationManager, _private_emulateMediaFeatures_descriptor = {
        value: __setFunctionName(async function (client, state) {
          if (!state.active) {
            return;
          }
          await client.send('Emulation.setEmulatedMedia', {
            features: state.mediaFeatures
          });
        }, "#emulateMediaFeatures")
      }, _private_emulateMediaFeatures_decorators, {
        kind: "method",
        name: "#emulateMediaFeatures",
        static: false,
        private: true,
        access: {
          has: obj => _EmulationManager_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_EmulationManager_brand, obj, _get_emulateMediaFeatures)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$2(_EmulationManager, _private_emulateMediaType_descriptor = {
        value: __setFunctionName(async function (client, state) {
          if (!state.active) {
            return;
          }
          await client.send('Emulation.setEmulatedMedia', {
            media: state.type || ''
          });
        }, "#emulateMediaType")
      }, _private_emulateMediaType_decorators, {
        kind: "method",
        name: "#emulateMediaType",
        static: false,
        private: true,
        access: {
          has: obj => _EmulationManager_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_EmulationManager_brand, obj, _get_emulateMediaType)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$2(_EmulationManager, _private_setGeolocation_descriptor = {
        value: __setFunctionName(async function (client, state) {
          if (!state.active) {
            return;
          }
          await client.send('Emulation.setGeolocationOverride', state.geoLocation ? {
            longitude: state.geoLocation.longitude,
            latitude: state.geoLocation.latitude,
            accuracy: state.geoLocation.accuracy
          } : undefined);
        }, "#setGeolocation")
      }, _private_setGeolocation_decorators, {
        kind: "method",
        name: "#setGeolocation",
        static: false,
        private: true,
        access: {
          has: obj => _EmulationManager_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_EmulationManager_brand, obj, _get_setGeolocation)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$2(_EmulationManager, _private_setDefaultBackgroundColor_descriptor = {
        value: __setFunctionName(async function (client, state) {
          if (!state.active) {
            return;
          }
          await client.send('Emulation.setDefaultBackgroundColorOverride', {
            color: state.color
          });
        }, "#setDefaultBackgroundColor")
      }, _private_setDefaultBackgroundColor_decorators, {
        kind: "method",
        name: "#setDefaultBackgroundColor",
        static: false,
        private: true,
        access: {
          has: obj => _EmulationManager_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_EmulationManager_brand, obj, _get_setDefaultBackgroundColor)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$2(_EmulationManager, _private_setJavaScriptEnabled_descriptor = {
        value: __setFunctionName(async function (client, state) {
          if (!state.active) {
            return;
          }
          await client.send('Emulation.setScriptExecutionDisabled', {
            value: !state.javaScriptEnabled
          });
        }, "#setJavaScriptEnabled")
      }, _private_setJavaScriptEnabled_decorators, {
        kind: "method",
        name: "#setJavaScriptEnabled",
        static: false,
        private: true,
        access: {
          has: obj => _EmulationManager_brand.has(_checkInRHS(obj)),
          get: obj => _classPrivateGetter(_EmulationManager_brand, obj, _get_setJavaScriptEnabled)
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_EmulationManager, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
    })(), _EmulationManager;
    function _get_applyViewport(_this3) {
      return _private_applyViewport_descriptor.value;
    }
    function _get_emulateIdleState(_this4) {
      return _private_emulateIdleState_descriptor.value;
    }
    function _get_emulateTimezone(_this5) {
      return _private_emulateTimezone_descriptor.value;
    }
    function _get_emulateVisionDeficiency(_this6) {
      return _private_emulateVisionDeficiency_descriptor.value;
    }
    function _get_emulateCpuThrottling(_this7) {
      return _private_emulateCpuThrottling_descriptor.value;
    }
    function _get_emulateMediaFeatures(_this8) {
      return _private_emulateMediaFeatures_descriptor.value;
    }
    function _get_emulateMediaType(_this9) {
      return _private_emulateMediaType_descriptor.value;
    }
    function _get_setGeolocation(_this10) {
      return _private_setGeolocation_descriptor.value;
    }
    function _get_setDefaultBackgroundColor(_this11) {
      return _private_setDefaultBackgroundColor_descriptor.value;
    }
    function _get_setJavaScriptEnabled(_this12) {
      return _private_setJavaScriptEnabled_descriptor.value;
    }
  })();

      _classPrivateFieldInitSpec(this, _id3, void 0);
      _classPrivateFieldInitSpec(this, _source, void 0);
      _classPrivateFieldInitSpec(this, _frameToId, new WeakMap());
      _classPrivateFieldSet(_id3, this, id);
      _classPrivateFieldSet(_source, this, source);
      _classPrivateFieldGet(_frameToId, this).set(mainFrame, id);
    }
    get id() {
      return _classPrivateFieldGet(_id3, this);
    }
    get source() {
      return _classPrivateFieldGet(_source, this);
    }
    getIdForFrame(frame) {
      return _classPrivateFieldGet(_frameToId, this).get(frame);
    }
    setIdForFrame(frame, identifier) {
      _classPrivateFieldGet(_frameToId, this).set(frame, identifier);
    }
  }

  class DeviceRequestPromptDevice {
    constructor(id, name) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "name", void 0);
      this.id = id;
      this.name = name;
    }
  }
    constructor(client, timeoutSettings, firstEvent) {
      _classPrivateMethodInitSpec(this, _DeviceRequestPrompt_brand);
      _classPrivateFieldInitSpec(this, _client6, void 0);
      _classPrivateFieldInitSpec(this, _timeoutSettings, void 0);
      _classPrivateFieldInitSpec(this, _id4, void 0);
      _classPrivateFieldInitSpec(this, _handled2, false);
      _classPrivateFieldInitSpec(this, _updateDevicesHandle, _assertClassBrand(_DeviceRequestPrompt_brand, this, _updateDevices).bind(this));
      _classPrivateFieldInitSpec(this, _waitForDevicePromises, new Set());
      _defineProperty(this, "devices", []);
      _classPrivateFieldSet(_client6, this, client);
      _classPrivateFieldSet(_timeoutSettings, this, timeoutSettings);
      _classPrivateFieldSet(_id4, this, firstEvent.id);
      _classPrivateFieldGet(_client6, this).on('DeviceAccess.deviceRequestPrompted', _classPrivateFieldGet(_updateDevicesHandle, this));
      _classPrivateFieldGet(_client6, this).on('Target.detachedFromTarget', () => {
        _classPrivateFieldSet(_client6, this, null);
      });
      _assertClassBrand(_DeviceRequestPrompt_brand, this, _updateDevices).call(this, firstEvent);
    }
    async waitForDevice(filter, options = {}) {
      for (const device of this.devices) {
        if (filter(device)) {
          return device;
        }
      }
      const {
        timeout = _classPrivateFieldGet(_timeoutSettings, this).timeout()
      } = options;
      const deferred = Deferred.create({
        message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout}ms exceeded`,
        timeout
      });
      if (options.signal) {
        options.signal.addEventListener('abort', () => {
          deferred.reject(options.signal?.reason);
        }, {
          once: true
        });
      }
      const handle = {
        filter,
        promise: deferred
      };
      _classPrivateFieldGet(_waitForDevicePromises, this).add(handle);
      try {
        return await deferred.valueOrThrow();
      } finally {
        _classPrivateFieldGet(_waitForDevicePromises, this).delete(handle);
      }
    }
    async select(device) {
      assert(_classPrivateFieldGet(_client6, this) !== null, 'Cannot select device through detached session!');
      assert(this.devices.includes(device), 'Cannot select unknown device!');
      assert(!_classPrivateFieldGet(_handled2, this), 'Cannot select DeviceRequestPrompt which is already handled!');
      _classPrivateFieldGet(_client6, this).off('DeviceAccess.deviceRequestPrompted', _classPrivateFieldGet(_updateDevicesHandle, this));
      _classPrivateFieldSet(_handled2, this, true);
      return await _classPrivateFieldGet(_client6, this).send('DeviceAccess.selectPrompt', {
        id: _classPrivateFieldGet(_id4, this),
        deviceId: device.id
      });
    }
    async cancel() {
      assert(_classPrivateFieldGet(_client6, this) !== null, 'Cannot cancel prompt through detached session!');
      assert(!_classPrivateFieldGet(_handled2, this), 'Cannot cancel DeviceRequestPrompt which is already handled!');
      _classPrivateFieldGet(_client6, this).off('DeviceAccess.deviceRequestPrompted', _classPrivateFieldGet(_updateDevicesHandle, this));
      _classPrivateFieldSet(_handled2, this, true);
      return await _classPrivateFieldGet(_client6, this).send('DeviceAccess.cancelPrompt', {
        id: _classPrivateFieldGet(_id4, this)
      });
    }
  }
  function _updateDevices(event) {
    if (event.id !== _classPrivateFieldGet(_id4, this)) {
      return;
    }
    for (const rawDevice of event.devices) {
      if (this.devices.some(device => {
        return device.id === rawDevice.id;
      })) {
        continue;
      }
      const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
      this.devices.push(newDevice);
      for (const waitForDevicePromise of _classPrivateFieldGet(_waitForDevicePromises, this)) {
        if (waitForDevicePromise.filter(newDevice)) {
          waitForDevicePromise.promise.resolve(newDevice);
        }
      }
    }
  }
  class DeviceRequestPromptManager {
    constructor(client, timeoutSettings) {
      _classPrivateMethodInitSpec(this, _DeviceRequestPromptManager_brand);
      _classPrivateFieldInitSpec(this, _client7, void 0);
      _classPrivateFieldInitSpec(this, _timeoutSettings2, void 0);
      _classPrivateFieldInitSpec(this, _deviceRequestPromptDeferreds, new Set());
      _classPrivateFieldSet(_client7, this, client);
      _classPrivateFieldSet(_timeoutSettings2, this, timeoutSettings);
      _classPrivateFieldGet(_client7, this).on('DeviceAccess.deviceRequestPrompted', event => {
        _assertClassBrand(_DeviceRequestPromptManager_brand, this, _onDeviceRequestPrompted).call(this, event);
      });
      _classPrivateFieldGet(_client7, this).on('Target.detachedFromTarget', () => {
        _classPrivateFieldSet(_client7, this, null);
      });
    }
    async waitForDevicePrompt(options = {}) {
      assert(_classPrivateFieldGet(_client7, this) !== null, 'Cannot wait for device prompt through detached session!');
      const needsEnable = _classPrivateFieldGet(_deviceRequestPromptDeferreds, this).size === 0;
      let enablePromise;
      if (needsEnable) {
        enablePromise = _classPrivateFieldGet(_client7, this).send('DeviceAccess.enable');
      }
      const {
        timeout = _classPrivateFieldGet(_timeoutSettings2, this).timeout()
      } = options;
      const deferred = Deferred.create({
        message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout}ms exceeded`,
        timeout
      });
      if (options.signal) {
        options.signal.addEventListener('abort', () => {
          deferred.reject(options.signal?.reason);
        }, {
          once: true
        });
      }
      _classPrivateFieldGet(_deviceRequestPromptDeferreds, this).add(deferred);
      try {
        const [result] = await Promise.all([deferred.valueOrThrow(), enablePromise]);
        return result;
      } finally {
        _classPrivateFieldGet(_deviceRequestPromptDeferreds, this).delete(deferred);
      }
    }
  }

  function _onDeviceRequestPrompted(event) {
    if (!_classPrivateFieldGet(_deviceRequestPromptDeferreds, this).size) {
      return;
    }
    assert(_classPrivateFieldGet(_client7, this) !== null);
    const devicePrompt = new DeviceRequestPrompt(_classPrivateFieldGet(_client7, this), _classPrivateFieldGet(_timeoutSettings2, this), event);
    for (const promise of _classPrivateFieldGet(_deviceRequestPromptDeferreds, this)) {
      promise.resolve(devicePrompt);
    }
    _classPrivateFieldGet(_deviceRequestPromptDeferreds, this).clear();
  }
  function createEvaluationError(details) {
    let name;
    let message;
    if (!details.exception) {
      name = 'Error';
      message = details.text;
    } else if ((details.exception.type !== 'object' || details.exception.subtype !== 'error') && !details.exception.objectId) {
      return valueFromRemoteObject(details.exception);
    } else {
      const detail = getErrorDetails(details);
      name = detail.name;
      message = detail.message;
    }
    const messageHeight = message.split('\n').length;
    const error = new Error(message);
    error.name = name;
    const stackLines = error.stack.split('\n');
    const messageLines = stackLines.splice(0, messageHeight);
    
    stackLines.shift();
    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
      for (const frame of details.stackTrace.callFrames.reverse()) {
        if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
          const url = PuppeteerURL.parse(frame.url);
          stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
        } else {
          stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
        }
        if (stackLines.length >= Error.stackTraceLimit) {
          break;
        }
      }
    }
    error.stack = [...messageLines, ...stackLines].join('\n');
    return error;
  }
  const getErrorDetails = details => {
    let name = '';
    let message;
    const lines = details.exception?.description?.split('\n    at ') ?? [];
    const size = Math.min(details.stackTrace?.callFrames.length ?? 0, lines.length - 1);
    lines.splice(-size, size);
    if (details.exception?.className) {
      name = details.exception.className;
    }
    message = lines.join('\n');
    if (name && message.startsWith(`${name}: `)) {
      message = message.slice(name.length + 2);
    }
    return {
      message,
      name
    };
  };
  function createClientError(details) {
    let name;
    let message;
    if (!details.exception) {
      name = 'Error';
      message = details.text;
    } else if ((details.exception.type !== 'object' || details.exception.subtype !== 'error') && !details.exception.objectId) {
      return valueFromRemoteObject(details.exception);
    } else {
      const detail = getErrorDetails(details);
      name = detail.name;
      message = detail.message;
    }
    const error = new Error(message);
    error.name = name;
    const messageHeight = error.message.split('\n').length;
    const messageLines = error.stack.split('\n').splice(0, messageHeight);
    const stackLines = [];
    if (details.stackTrace) {
      for (const frame of details.stackTrace.callFrames) {
        
        stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
        if (stackLines.length >= Error.stackTraceLimit) {
          break;
        }
      }
    }
    error.stack = [...messageLines, ...stackLines].join('\n');
    return error;
  }
  function valueFromRemoteObject(remoteObject) {
    assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');
    if (remoteObject.unserializableValue) {
      if (remoteObject.type === 'bigint') {
        return BigInt(remoteObject.unserializableValue.replace('n', ''));
      }
      switch (remoteObject.unserializableValue) {
        case '-0':
          return -0;
        case 'NaN':
          return NaN;
        case 'Infinity':
          return Infinity;
        case '-Infinity':
          return -Infinity;
        default:
          throw new Error('Unsupported unserializable value: ' + remoteObject.unserializableValue);
      }
    }
    return remoteObject.value;
  }
  function addPageBinding(type, name, prefix) {
    
    
    
    
    if (globalThis[name]) {
      return;
    }
    
    Object.assign(globalThis, {
      [name](...args) {
        
        
        const callPuppeteer = globalThis[name];
        callPuppeteer.args ??= new Map();
        callPuppeteer.callbacks ??= new Map();
        const seq = (callPuppeteer.lastSeq ?? 0) + 1;
        callPuppeteer.lastSeq = seq;
        callPuppeteer.args.set(seq, args);
        
        
        globalThis[prefix + name](JSON.stringify({
          type,
          name,
          seq,
          args,
          isTrivial: !args.some(value => {
            return value instanceof Node;
          })
        }));
        return new Promise((resolve, reject) => {
          callPuppeteer.callbacks.set(seq, {
            resolve(value) {
              callPuppeteer.args.delete(seq);
              resolve(value);
            },
            reject(value) {
              callPuppeteer.args.delete(seq);
              reject(value);
            }
          });
        });
      }
    });
  }
  const CDP_BINDING_PREFIX = 'puppeteer_';
  function pageBindingInitString(type, name) {
    return evaluationString(addPageBinding, type, name, CDP_BINDING_PREFIX);
  }

    asElement() {
      return null;
    }
    async dispose() {
      if (_classPrivateFieldGet(_disposed4, this)) {
        return;
      }
      _classPrivateFieldSet(_disposed4, this, true);
      await releaseObject(this.client, _classPrivateFieldGet(_remoteObject, this));
    }
    toString() {
      if (!_classPrivateFieldGet(_remoteObject, this).objectId) {
        return 'JSHandle:' + valueFromRemoteObject(_classPrivateFieldGet(_remoteObject, this));
      }
      const type = _classPrivateFieldGet(_remoteObject, this).subtype || _classPrivateFieldGet(_remoteObject, this).type;
      return 'JSHandle@' + type;
    }
    get id() {
      return _classPrivateFieldGet(_remoteObject, this).objectId;
    }
    remoteObject() {
      return _classPrivateFieldGet(_remoteObject, this);
    }
    async getProperties() {
      
      
      const response = await this.client.send('Runtime.getProperties', {
        objectId: _classPrivateFieldGet(_remoteObject, this).objectId,
        ownProperties: true
      });
      const result = new Map();
      for (const property of response.result) {
        if (!property.enumerable || !property.value) {
          continue;
        }
        result.set(property.name, _classPrivateFieldGet(_world2, this).createCdpHandle(property.value));
      }
      return result;
    }
  }
  async function releaseObject(client, remoteObject) {
    if (!remoteObject.objectId) {
      return;
    }
    await client.send('Runtime.releaseObject', {
      objectId: remoteObject.objectId
    }).catch(error => {
      
      
      debugError(error);
    });
  }

  var __runInitializers$1 = undefined && undefined.__runInitializers || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate$1 = undefined && undefined.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind,
      key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _,
      done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? {
        get: descriptor.get,
        set: descriptor.set
      } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field") initializers.unshift(_);else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  const NON_ELEMENT_NODE_ROLES = new Set(['StaticText', 'InlineTextBox']);
  let CdpElementHandle = ((_CdpElementHandle, _backendNodeId, _CdpElementHandle_brand) => {
    let _classSuper = ElementHandle;
    let _instanceExtraInitializers = [];
    let _contentFrame_decorators;
    let _scrollIntoView_decorators;
    let _uploadFile_decorators;
    let _autofill_decorators;
        if (files.length === 0) {
          
          
          await this.evaluate(element => {
            element.files = new DataTransfer().files;
            
            element.dispatchEvent(new Event('input', {
              bubbles: true,
              composed: true
            }));
            element.dispatchEvent(new Event('change', {
              bubbles: true
            }));
          });
          return;
        }
        const {
          node: {
            backendNodeId
          }
        } = await this.client.send('DOM.describeNode', {
          objectId: this.id
        });
        await this.client.send('DOM.setFileInputFiles', {
          objectId: this.id,
          files,
          backendNodeId
        });
      }
      async autofill(data) {
        const nodeInfo = await this.client.send('DOM.describeNode', {
          objectId: this.handle.id
        });
        const fieldId = nodeInfo.node.backendNodeId;
        const frameId = this.frame._id;
        await this.client.send('Autofill.trigger', {
          fieldId,
          frameId,
          card: data.creditCard
        });
      }
      async *queryAXTree(name, role) {
        const {
          nodes
        } = await this.client.send('Accessibility.queryAXTree', {
          objectId: this.id,
          accessibleName: name,
          role
        });
        const results = nodes.filter(node => {
          if (node.ignored) {
            return false;
          }
          if (!node.role) {
            return false;
          }
          if (NON_ELEMENT_NODE_ROLES.has(node.role.value)) {
            return false;
          }
          return true;
        });
        return yield* AsyncIterableUtil.map(results, node => {
          return this.realm.adoptBackendNode(node.backendDOMNodeId);
        });
      }
      async backendNodeId() {
        if (_classPrivateFieldGet(_backendNodeId, this)) {
          return _classPrivateFieldGet(_backendNodeId, this);
        }
        const {
          node
        } = await this.client.send('DOM.describeNode', {
          objectId: this.handle.id
        });
        _classPrivateFieldSet(_backendNodeId, this, node.backendNodeId);
        return _classPrivateFieldGet(_backendNodeId, this);
      }
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _contentFrame_decorators = [throwIfDisposed()];
      _scrollIntoView_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _uploadFile_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _autofill_decorators = [throwIfDisposed()];
      __esDecorate$1(_CdpElementHandle, null, _contentFrame_decorators, {
        kind: "method",
        name: "contentFrame",
        static: false,
        private: false,
        access: {
          has: obj => "contentFrame" in obj,
          get: obj => obj.contentFrame
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$1(_CdpElementHandle, null, _scrollIntoView_decorators, {
        kind: "method",
        name: "scrollIntoView",
        static: false,
        private: false,
        access: {
          has: obj => "scrollIntoView" in obj,
          get: obj => obj.scrollIntoView
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$1(_CdpElementHandle, null, _uploadFile_decorators, {
        kind: "method",
        name: "uploadFile",
        static: false,
        private: false,
        access: {
          has: obj => "uploadFile" in obj,
          get: obj => obj.uploadFile
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate$1(_CdpElementHandle, null, _autofill_decorators, {
        kind: "method",
        name: "autofill",
        static: false,
        private: false,
        access: {
          has: obj => "autofill" in obj,
          get: obj => obj.autofill
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_CdpElementHandle, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
    })(), _CdpElementHandle;
    function _get_frameManager(_this13) {
      return _this13.frame._frameManager;
    }
  })();

  var __addDisposableResource$2 = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$2 = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  const ariaQuerySelectorBinding = new Binding('__ariaQuerySelector', ARIAQueryHandler.queryOne, '');
  const ariaQuerySelectorAllBinding = new Binding('__ariaQuerySelectorAll', async (element, selector) => {
    const results = ARIAQueryHandler.queryAll(element, selector);
    return await element.realm.evaluateHandle((...elements) => {
      return elements;
    }, ...(await AsyncIterableUtil.collect(results)));
  }, '');
  class ExecutionContext extends EventEmitter {
    constructor(client, contextPayload, world) {
      super();
      _classPrivateMethodInitSpec(this, _ExecutionContext_brand);
      _classPrivateFieldInitSpec(this, _client8, void 0);
      _classPrivateFieldInitSpec(this, _world3, void 0);
      _classPrivateFieldInitSpec(this, _id5, void 0);
      _classPrivateFieldInitSpec(this, _name3, void 0);
      _classPrivateFieldInitSpec(this, _disposables, new DisposableStack());
      
      _classPrivateFieldInitSpec(this, _bindings, new Map());
      
      
      _classPrivateFieldInitSpec(this, _mutex, new Mutex());
      _classPrivateFieldInitSpec(this, _bindingsInstalled, false);
      _classPrivateFieldInitSpec(this, _puppeteerUtil, void 0);
      _classPrivateFieldSet(_client8, this, client);
      _classPrivateFieldSet(_world3, this, world);
      _classPrivateFieldSet(_id5, this, contextPayload.id);
      if (contextPayload.name) {
        _classPrivateFieldSet(_name3, this, contextPayload.name);
      }
      const clientEmitter = _classPrivateFieldGet(_disposables, this).use(new EventEmitter(_classPrivateFieldGet(_client8, this)));
      clientEmitter.on('Runtime.bindingCalled', _assertClassBrand(_ExecutionContext_brand, this, _onBindingCalled).bind(this));
      clientEmitter.on('Runtime.executionContextDestroyed', async event => {
        if (event.executionContextId === _classPrivateFieldGet(_id5, this)) {
          this[disposeSymbol]();
        }
      });
      clientEmitter.on('Runtime.executionContextsCleared', async () => {
        this[disposeSymbol]();
      });
      clientEmitter.on('Runtime.consoleAPICalled', _assertClassBrand(_ExecutionContext_brand, this, _onConsoleAPI).bind(this));
      clientEmitter.on(exports.CDPSessionEvent.Disconnected, () => {
        this[disposeSymbol]();
      });
    }
    get id() {
      return _classPrivateFieldGet(_id5, this);
    }
    get puppeteerUtil() {
      let promise = Promise.resolve();
      if (!_classPrivateFieldGet(_bindingsInstalled, this)) {
        promise = Promise.all([_assertClassBrand(_ExecutionContext_brand, this, _addBindingWithoutThrowing).call(this, ariaQuerySelectorBinding), _assertClassBrand(_ExecutionContext_brand, this, _addBindingWithoutThrowing).call(this, ariaQuerySelectorAllBinding)]);
        _classPrivateFieldSet(_bindingsInstalled, this, true);
      }
      scriptInjector.inject(script => {
        if (_classPrivateFieldGet(_puppeteerUtil, this)) {
          void _classPrivateFieldGet(_puppeteerUtil, this).then(handle => {
            void handle.dispose();
          });
        }
        _classPrivateFieldSet(_puppeteerUtil, this, promise.then(() => {
          return this.evaluateHandle(script);
        }));
      }, !_classPrivateFieldGet(_puppeteerUtil, this));
      return _classPrivateFieldGet(_puppeteerUtil, this);
    }
    async evaluate(pageFunction, ...args) {
      return await _assertClassBrand(_ExecutionContext_brand, this, _evaluate).call(this, true, pageFunction, ...args);
    }
    async evaluateHandle(pageFunction, ...args) {
      return await _assertClassBrand(_ExecutionContext_brand, this, _evaluate).call(this, false, pageFunction, ...args);
    }
    [disposeSymbol]() {
      _classPrivateFieldGet(_disposables, this).dispose();
      this.emit('disposed', undefined);
    }
  }
  async function _addBinding(binding) {
    const env_1 = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      if (_classPrivateFieldGet(_bindings, this).has(binding.name)) {
        return;
      }
      const _ = __addDisposableResource$2(env_1, await _classPrivateFieldGet(_mutex, this).acquire(), false);
      try {
        await _classPrivateFieldGet(_client8, this).send('Runtime.addBinding', _classPrivateFieldGet(_name3, this) ? {
          name: CDP_BINDING_PREFIX + binding.name,
          executionContextName: _classPrivateFieldGet(_name3, this)
        } : {
          name: CDP_BINDING_PREFIX + binding.name,
          executionContextId: _classPrivateFieldGet(_id5, this)
        });
        await this.evaluate(addPageBinding, 'internal', binding.name, CDP_BINDING_PREFIX);
        _classPrivateFieldGet(_bindings, this).set(binding.name, binding);
      } catch (error) {
        
        
        
        if (error instanceof Error) {
          
          if (error.message.includes('Execution context was destroyed')) {
            return;
          }
          
          if (error.message.includes('Cannot find context with specified id')) {
            return;
          }
        }
        debugError(error);
      }
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources$2(env_1);
    }
  }
  async function _onBindingCalled(event) {
    if (event.executionContextId !== _classPrivateFieldGet(_id5, this)) {
      return;
    }
    let payload;
    try {
      payload = JSON.parse(event.payload);
    } catch {
      
      
      return;
    }
    const {
      type,
      name,
      seq,
      args,
      isTrivial
    } = payload;
    if (type !== 'internal') {
      this.emit('bindingcalled', event);
      return;
    }
    if (!_classPrivateFieldGet(_bindings, this).has(name)) {
      this.emit('bindingcalled', event);
      return;
    }
    try {
      const binding = _classPrivateFieldGet(_bindings, this).get(name);
      await binding?.run(this, seq, args, isTrivial);
    } catch (err) {
      debugError(err);
    }
  }
  function _onConsoleAPI(event) {
    if (event.executionContextId !== _classPrivateFieldGet(_id5, this)) {
      return;
    }
    this.emit('consoleapicalled', event);
  }
  async function _addBindingWithoutThrowing(binding) {
    try {
      await _assertClassBrand(_ExecutionContext_brand, this, _addBinding).call(this, binding);
    } catch (err) {
      
      
      debugError(err);
    }
  }
  async function _evaluate(returnByValue, pageFunction, ...args) {
    const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ?? PuppeteerURL.INTERNAL_URL);
    if (isString(pageFunction)) {
      const contextId = _classPrivateFieldGet(_id5, this);
      const expression = pageFunction;
      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : `${expression}\n${sourceUrlComment}\n`;
      const {
        exceptionDetails,
        result: remoteObject
      } = await _classPrivateFieldGet(_client8, this).send('Runtime.evaluate', {
        expression: expressionWithSourceUrl,
        contextId,
        returnByValue,
        awaitPromise: true,
        userGesture: true
      }).catch(rewriteError);
      if (exceptionDetails) {
        throw createEvaluationError(exceptionDetails);
      }
      return returnByValue ? valueFromRemoteObject(remoteObject) : _classPrivateFieldGet(_world3, this).createCdpHandle(remoteObject);
    }
    const functionDeclaration = stringifyFunction(pageFunction);
    const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}\n${sourceUrlComment}\n`;
    let callFunctionOnPromise;
    try {
      callFunctionOnPromise = _classPrivateFieldGet(_client8, this).send('Runtime.callFunctionOn', {
        functionDeclaration: functionDeclarationWithSourceUrl,
        executionContextId: _classPrivateFieldGet(_id5, this),
        
        
        arguments: args.some(arg => {
          return arg instanceof LazyArg;
        }) ? await Promise.all(args.map(arg => {
          return convertArgumentAsync(this, arg);
        })) : args.map(arg => {
          return convertArgument(this, arg);
        }),
        returnByValue,
        awaitPromise: true,
        userGesture: true
      });
    } catch (error) {
      if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON')) {
        error.message += ' Recursive objects are not allowed.';
      }
      throw error;
    }
    const {
      exceptionDetails,
      result: remoteObject
    } = await callFunctionOnPromise.catch(rewriteError);
    if (exceptionDetails) {
      throw createEvaluationError(exceptionDetails);
    }
    return returnByValue ? valueFromRemoteObject(remoteObject) : _classPrivateFieldGet(_world3, this).createCdpHandle(remoteObject);
    async function convertArgumentAsync(context, arg) {
      if (arg instanceof LazyArg) {
        arg = await arg.get(context);
      }
      return convertArgument(context, arg);
    }
    function convertArgument(context, arg) {
      if (typeof arg === 'bigint') {
        return {
          unserializableValue: `${arg.toString()}n`
        };
      }
      if (Object.is(arg, -0)) {
        return {
          unserializableValue: '-0'
        };
      }
      if (Object.is(arg, Infinity)) {
        return {
          unserializableValue: 'Infinity'
        };
      }
      if (Object.is(arg, -Infinity)) {
        return {
          unserializableValue: '-Infinity'
        };
      }
      if (Object.is(arg, NaN)) {
        return {
          unserializableValue: 'NaN'
        };
      }
      const objectHandle = arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle) ? arg : null;
      if (objectHandle) {
        if (objectHandle.realm !== _classPrivateFieldGet(_world3, context)) {
          throw new Error('JSHandles can be evaluated only in the context they were created!');
        }
        if (objectHandle.disposed) {
          throw new Error('JSHandle is disposed!');
        }
        if (objectHandle.remoteObject().unserializableValue) {
          return {
            unserializableValue: objectHandle.remoteObject().unserializableValue
          };
        }
        if (!objectHandle.remoteObject().objectId) {
          return {
            value: objectHandle.remoteObject().value
          };
        }
        return {
          objectId: objectHandle.remoteObject().objectId
        };
      }
      return {
        value: arg
      };
    }
  }
  const rewriteError = error => {
    if (error.message.includes('Object reference chain is too long')) {
      return {
        result: {
          type: 'undefined'
        }
      };
    }
    if (error.message.includes("Object couldn't be returned by value")) {
      return {
        result: {
          type: 'undefined'
        }
      };
    }
    if (error.message.endsWith('Cannot find context with specified id') || error.message.endsWith('Inspected target navigated or closed')) {
      throw new Error('Execution context was destroyed, most likely because of a navigation.');
    }
    throw error;
  };

  
  exports.FrameManagerEvent = void 0;
  (function (FrameManagerEvent) {
    FrameManagerEvent.FrameAttached = Symbol('FrameManager.FrameAttached');
    FrameManagerEvent.FrameNavigated = Symbol('FrameManager.FrameNavigated');
    FrameManagerEvent.FrameDetached = Symbol('FrameManager.FrameDetached');
    FrameManagerEvent.FrameSwapped = Symbol('FrameManager.FrameSwapped');
    FrameManagerEvent.LifecycleEvent = Symbol('FrameManager.LifecycleEvent');
    FrameManagerEvent.FrameNavigatedWithinDocument = Symbol('FrameManager.FrameNavigatedWithinDocument');
    FrameManagerEvent.ConsoleApiCalled = Symbol('FrameManager.ConsoleApiCalled');
    FrameManagerEvent.BindingCalled = Symbol('FrameManager.BindingCalled');
  })(exports.FrameManagerEvent || (exports.FrameManagerEvent = {}));

  class IsolatedWorld extends Realm {
    constructor(frameOrWorker, timeoutSettings) {
      super(timeoutSettings);
      _classPrivateMethodInitSpec(this, _IsolatedWorld_brand);
      _classPrivateFieldInitSpec(this, _context, void 0);
      _classPrivateFieldInitSpec(this, _emitter2, new EventEmitter());
      _classPrivateFieldInitSpec(this, _frameOrWorker, void 0);
      _classPrivateFieldSet(_frameOrWorker, this, frameOrWorker);
    }
    get environment() {
      return _classPrivateFieldGet(_frameOrWorker, this);
    }
    get client() {
      return _classPrivateFieldGet(_frameOrWorker, this).client;
    }
    get emitter() {
      return _classPrivateFieldGet(_emitter2, this);
    }
    setContext(context) {
      _classPrivateFieldGet(_context, this)?.[disposeSymbol]();
      context.once('disposed', _assertClassBrand(_IsolatedWorld_brand, this, _onContextDisposed).bind(this));
      context.on('consoleapicalled', _assertClassBrand(_IsolatedWorld_brand, this, _onContextConsoleApiCalled).bind(this));
      context.on('bindingcalled', _assertClassBrand(_IsolatedWorld_brand, this, _onContextBindingCalled).bind(this));
      _classPrivateFieldSet(_context, this, context);
      _classPrivateFieldGet(_emitter2, this).emit('context', context);
      void this.taskManager.rerunAll();
    }
    hasContext() {
      return !!_classPrivateFieldGet(_context, this);
    }
    get context() {
      return _classPrivateFieldGet(_context, this);
    }
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      
      
      
      let context = _assertClassBrand(_IsolatedWorld_brand, this, _executionContext).call(this);
      if (!context) {
        context = await _assertClassBrand(_IsolatedWorld_brand, this, _waitForExecutionContext).call(this);
      }
      return await context.evaluateHandle(pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      
      
      
      let context = _assertClassBrand(_IsolatedWorld_brand, this, _executionContext).call(this);
      if (!context) {
        context = await _assertClassBrand(_IsolatedWorld_brand, this, _waitForExecutionContext).call(this);
      }
      return await context.evaluate(pageFunction, ...args);
    }
    async adoptBackendNode(backendNodeId) {
      
      
      
      let context = _assertClassBrand(_IsolatedWorld_brand, this, _executionContext).call(this);
      if (!context) {
        context = await _assertClassBrand(_IsolatedWorld_brand, this, _waitForExecutionContext).call(this);
      }
      const {
        object
      } = await this.client.send('DOM.resolveNode', {
        backendNodeId: backendNodeId,
        executionContextId: context.id
      });
      return this.createCdpHandle(object);
    }
    async adoptHandle(handle) {
      if (handle.realm === this) {
        
        
        return await handle.evaluateHandle(value => {
          return value;
        });
      }
      const nodeInfo = await this.client.send('DOM.describeNode', {
        objectId: handle.id
      });
      return await this.adoptBackendNode(nodeInfo.node.backendNodeId);
    }
    async transferHandle(handle) {
      if (handle.realm === this) {
        return handle;
      }
      
      if (handle.remoteObject().objectId === undefined) {
        return handle;
      }
      const info = await this.client.send('DOM.describeNode', {
        objectId: handle.remoteObject().objectId
      });
      const newHandle = await this.adoptBackendNode(info.node.backendNodeId);
      await handle.dispose();
      return newHandle;
    }
    createCdpHandle(remoteObject) {
      if (remoteObject.subtype === 'node') {
        return new CdpElementHandle(this, remoteObject);
      }
      return new CdpJSHandle(this, remoteObject);
    }
    [disposeSymbol]() {
      _classPrivateFieldGet(_context, this)?.[disposeSymbol]();
      _classPrivateFieldGet(_emitter2, this).emit('disposed', undefined);
      super[disposeSymbol]();
      _classPrivateFieldGet(_emitter2, this).removeAllListeners();
    }
  }

  function _onContextDisposed() {
    _classPrivateFieldSet(_context, this, undefined);
    if ('clearDocumentHandle' in _classPrivateFieldGet(_frameOrWorker, this)) {
      _classPrivateFieldGet(_frameOrWorker, this).clearDocumentHandle();
    }
  }
  function _onContextConsoleApiCalled(event) {
    _classPrivateFieldGet(_emitter2, this).emit('consoleapicalled', event);
  }
  function _onContextBindingCalled(event) {
    _classPrivateFieldGet(_emitter2, this).emit('bindingcalled', event);
  }
  function _executionContext() {
    if (this.disposed) {
      throw new Error(`Execution context is not available in detached frame or worker "${this.environment.url()}" (are you trying to evaluate?)`);
    }
    return _classPrivateFieldGet(_context, this);
  }
  async function _waitForExecutionContext() {
    const error = new Error('Execution context was destroyed');
    const result = await firstValueFrom(fromEmitterEvent(_classPrivateFieldGet(_emitter2, this), 'context').pipe(raceWith(fromEmitterEvent(_classPrivateFieldGet(_emitter2, this), 'disposed').pipe(map(() => {
      
      throw error;
    })), timeout(this.timeoutSettings.timeout()))));
    return result;
  }
  const MAIN_WORLD = Symbol('mainWorld');
  const PUPPETEER_WORLD = Symbol('puppeteerWorld');

  const puppeteerToProtocolLifecycle = new Map([['load', 'load'], ['domcontentloaded', 'DOMContentLoaded'], ['networkidle0', 'networkIdle'], ['networkidle2', 'networkAlmostIdle']]);
  class LifecycleWatcher {
    constructor(networkManager, _frame3, waitUntil, timeout, signal) {
      _classPrivateMethodInitSpec(this, _LifecycleWatcher_brand);
      _classPrivateFieldInitSpec(this, _expectedLifecycle, void 0);
      _classPrivateFieldInitSpec(this, _frame2, void 0);
      _classPrivateFieldInitSpec(this, _timeout3, void 0);
      _classPrivateFieldInitSpec(this, _navigationRequest, null);
      _classPrivateFieldInitSpec(this, _subscriptions2, new DisposableStack());
      _classPrivateFieldInitSpec(this, _initialLoaderId, void 0);
      _classPrivateFieldInitSpec(this, _terminationDeferred, void 0);
      _classPrivateFieldInitSpec(this, _sameDocumentNavigationDeferred, Deferred.create());
      _classPrivateFieldInitSpec(this, _lifecycleDeferred, Deferred.create());
      _classPrivateFieldInitSpec(this, _newDocumentNavigationDeferred, Deferred.create());
      _classPrivateFieldInitSpec(this, _hasSameDocumentNavigation, void 0);
      _classPrivateFieldInitSpec(this, _swapped, void 0);
      _classPrivateFieldInitSpec(this, _navigationResponseReceived, void 0);
      if (Array.isArray(waitUntil)) {
        waitUntil = waitUntil.slice();
      } else if (typeof waitUntil === 'string') {
        waitUntil = [waitUntil];
      }
      _classPrivateFieldSet(_initialLoaderId, this, _frame3._loaderId);
      _classPrivateFieldSet(_expectedLifecycle, this, waitUntil.map(value => {
        const protocolEvent = puppeteerToProtocolLifecycle.get(value);
        assert(protocolEvent, 'Unknown value for options.waitUntil: ' + value);
        return protocolEvent;
      }));
      signal?.addEventListener('abort', () => {
        _classPrivateFieldGet(_terminationDeferred, this).reject(signal.reason);
      });
      _classPrivateFieldSet(_frame2, this, _frame3);
      _classPrivateFieldSet(_timeout3, this, timeout);
      const frameManagerEmitter = _classPrivateFieldGet(_subscriptions2, this).use(new EventEmitter(_frame3._frameManager));
      frameManagerEmitter.on(exports.FrameManagerEvent.LifecycleEvent, _assertClassBrand(_LifecycleWatcher_brand, this, _checkLifecycleComplete).bind(this));
      const frameEmitter = _classPrivateFieldGet(_subscriptions2, this).use(new EventEmitter(_frame3));
      frameEmitter.on(exports.FrameEvent.FrameNavigatedWithinDocument, _assertClassBrand(_LifecycleWatcher_brand, this, _navigatedWithinDocument).bind(this));
      frameEmitter.on(exports.FrameEvent.FrameNavigated, _assertClassBrand(_LifecycleWatcher_brand, this, _navigated).bind(this));
      frameEmitter.on(exports.FrameEvent.FrameSwapped, _assertClassBrand(_LifecycleWatcher_brand, this, _frameSwapped).bind(this));
      frameEmitter.on(exports.FrameEvent.FrameSwappedByActivation, _assertClassBrand(_LifecycleWatcher_brand, this, _frameSwapped).bind(this));
      frameEmitter.on(exports.FrameEvent.FrameDetached, _assertClassBrand(_LifecycleWatcher_brand, this, _onFrameDetached).bind(this));
      const networkManagerEmitter = _classPrivateFieldGet(_subscriptions2, this).use(new EventEmitter(networkManager));
      networkManagerEmitter.on(exports.NetworkManagerEvent.Request, _assertClassBrand(_LifecycleWatcher_brand, this, _onRequest).bind(this));
      networkManagerEmitter.on(exports.NetworkManagerEvent.Response, _assertClassBrand(_LifecycleWatcher_brand, this, _onResponse).bind(this));
      networkManagerEmitter.on(exports.NetworkManagerEvent.RequestFailed, _assertClassBrand(_LifecycleWatcher_brand, this, _onRequestFailed).bind(this));
      _classPrivateFieldSet(_terminationDeferred, this, Deferred.create({
        timeout: _classPrivateFieldGet(_timeout3, this),
        message: `Navigation timeout of ${_classPrivateFieldGet(_timeout3, this)} ms exceeded`
      }));
      _assertClassBrand(_LifecycleWatcher_brand, this, _checkLifecycleComplete).call(this);
    }
    async navigationResponse() {
      
      await _classPrivateFieldGet(_navigationResponseReceived, this)?.valueOrThrow();
      return _classPrivateFieldGet(_navigationRequest, this) ? _classPrivateFieldGet(_navigationRequest, this).response() : null;
    }
    sameDocumentNavigationPromise() {
      return _classPrivateFieldGet(_sameDocumentNavigationDeferred, this).valueOrThrow();
    }
    newDocumentNavigationPromise() {
      return _classPrivateFieldGet(_newDocumentNavigationDeferred, this).valueOrThrow();
    }
    lifecyclePromise() {
      return _classPrivateFieldGet(_lifecycleDeferred, this).valueOrThrow();
    }
    terminationPromise() {
      return _classPrivateFieldGet(_terminationDeferred, this).valueOrThrow();
    }
    dispose() {
      _classPrivateFieldGet(_subscriptions2, this).dispose();
      _classPrivateFieldGet(_terminationDeferred, this).resolve(new Error('LifecycleWatcher disposed'));
    }
  }

  function _onRequest(request) {
    if (request.frame() !== _classPrivateFieldGet(_frame2, this) || !request.isNavigationRequest()) {
      return;
    }
    _classPrivateFieldSet(_navigationRequest, this, request);
    
    
    
    _classPrivateFieldGet(_navigationResponseReceived, this)?.resolve();
    _classPrivateFieldSet(_navigationResponseReceived, this, Deferred.create());
    if (request.response() !== null) {
      _classPrivateFieldGet(_navigationResponseReceived, this)?.resolve();
    }
  }
  function _onRequestFailed(request) {
    if (_classPrivateFieldGet(_navigationRequest, this)?.id !== request.id) {
      return;
    }
    _classPrivateFieldGet(_navigationResponseReceived, this)?.resolve();
  }
  function _onResponse(response) {
    if (_classPrivateFieldGet(_navigationRequest, this)?.id !== response.request().id) {
      return;
    }
    _classPrivateFieldGet(_navigationResponseReceived, this)?.resolve();
  }
  function _onFrameDetached(frame) {
    if (_classPrivateFieldGet(_frame2, this) === frame) {
      _classPrivateFieldGet(_terminationDeferred, this).resolve(new Error('Navigating frame was detached'));
      return;
    }
    _assertClassBrand(_LifecycleWatcher_brand, this, _checkLifecycleComplete).call(this);
  }
  function _navigatedWithinDocument() {
    _classPrivateFieldSet(_hasSameDocumentNavigation, this, true);
    _assertClassBrand(_LifecycleWatcher_brand, this, _checkLifecycleComplete).call(this);
  }
  function _navigated(navigationType) {
    if (navigationType === 'BackForwardCacheRestore') {
      return _assertClassBrand(_LifecycleWatcher_brand, this, _frameSwapped).call(this);
    }
    _assertClassBrand(_LifecycleWatcher_brand, this, _checkLifecycleComplete).call(this);
  }
  function _frameSwapped() {
    _classPrivateFieldSet(_swapped, this, true);
    _assertClassBrand(_LifecycleWatcher_brand, this, _checkLifecycleComplete).call(this);
  }
  function _checkLifecycleComplete() {
    
    if (!checkLifecycle(_classPrivateFieldGet(_frame2, this), _classPrivateFieldGet(_expectedLifecycle, this))) {
      return;
    }
    _classPrivateFieldGet(_lifecycleDeferred, this).resolve();
    if (_classPrivateFieldGet(_hasSameDocumentNavigation, this)) {
      _classPrivateFieldGet(_sameDocumentNavigationDeferred, this).resolve(undefined);
    }
    if (_classPrivateFieldGet(_swapped, this) || _classPrivateFieldGet(_frame2, this)._loaderId !== _classPrivateFieldGet(_initialLoaderId, this)) {
      _classPrivateFieldGet(_newDocumentNavigationDeferred, this).resolve(undefined);
    }
    function checkLifecycle(frame, expectedLifecycle) {
      for (const event of expectedLifecycle) {
        if (!frame._lifecycleEvents.has(event)) {
          return false;
        }
      }
      for (const child of frame.childFrames()) {
        if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {
          return false;
        }
      }
      return true;
    }
  }
  var __runInitializers = undefined && undefined.__runInitializers || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate = undefined && undefined.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind,
      key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _,
      done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? {
        get: descriptor.get,
        set: descriptor.set
      } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_ = accept(result.get)) descriptor.get = _;
        if (_ = accept(result.set)) descriptor.set = _;
        if (_ = accept(result.init)) initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field") initializers.unshift(_);else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  let CdpFrame = ((_ref3, _CdpFrame, _url3, _detached2, _client9, _CdpFrame_brand) => {
    let _classSuper = Frame;
    let _instanceExtraInitializers = [];
    let _goto_decorators;
    let _waitForNavigation_decorators;
    let _setContent_decorators;
    let _addPreloadScript_decorators;
    let _addExposedFunctionBinding_decorators;
    let _removeExposedFunctionBinding_decorators;
    let _waitForDevicePrompt_decorators;
      _client() {
        return _classPrivateFieldGet(_client9, this);
      }
      updateId(id) {
        this._id = id;
      }
      updateClient(client) {
        _classPrivateFieldSet(_client9, this, client);
      }
      page() {
        return this._frameManager.page();
      }
      async goto(url, options = {}) {
        const {
          referer = this._frameManager.networkManager.extraHTTPHeaders()['referer'],
          referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()['referer-policy'],
          waitUntil = ['load'],
          timeout = this._frameManager.timeoutSettings.navigationTimeout()
        } = options;
        let ensureNewDocumentNavigation = false;
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout);
        let error = await Deferred.race([navigate(_classPrivateFieldGet(_client9, this), url, referer, referrerPolicy, this._id), watcher.terminationPromise()]);
        if (!error) {
          error = await Deferred.race([watcher.terminationPromise(), ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()]);
        }
        try {
          if (error) {
            throw error;
          }
          return await watcher.navigationResponse();
        } finally {
          watcher.dispose();
        }
        async function navigate(client, url, referrer, referrerPolicy, frameId) {
          try {
            const response = await client.send('Page.navigate', {
              url,
              referrer,
              frameId,
              referrerPolicy
            });
            ensureNewDocumentNavigation = !!response.loaderId;
            if (response.errorText === 'net::ERR_HTTP_RESPONSE_CODE_FAILURE') {
              return null;
            }
            return response.errorText ? new Error(`${response.errorText} at ${url}`) : null;
          } catch (error) {
            if (isErrorLike(error)) {
              return error;
            }
            throw error;
          }
        }
      }
      async waitForNavigation(options = {}) {
        const {
          waitUntil = ['load'],
          timeout = this._frameManager.timeoutSettings.navigationTimeout(),
          signal
        } = options;
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout, signal);
        const error = await Deferred.race([watcher.terminationPromise(), ...(options.ignoreSameDocumentNavigation ? [] : [watcher.sameDocumentNavigationPromise()]), watcher.newDocumentNavigationPromise()]);
        try {
          if (error) {
            throw error;
          }
          const result = await Deferred.race([watcher.terminationPromise(), watcher.navigationResponse()]);
          if (result instanceof Error) {
            throw error;
          }
          return result || null;
        } finally {
          watcher.dispose();
        }
      }
      get client() {
        return _classPrivateFieldGet(_client9, this);
      }
      mainRealm() {
        return this.worlds[MAIN_WORLD];
      }
      isolatedRealm() {
        return this.worlds[PUPPETEER_WORLD];
      }
      async setContent(html, options = {}) {
        const {
          waitUntil = ['load'],
          timeout = this._frameManager.timeoutSettings.navigationTimeout()
        } = options;
        
        
        await this.setFrameContent(html);
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout);
        const error = await Deferred.race([watcher.terminationPromise(), watcher.lifecyclePromise()]);
        watcher.dispose();
        if (error) {
          throw error;
        }
      }
      url() {
        return _classPrivateFieldGet(_url3, this);
      }
      parentFrame() {
        return this._frameManager._frameTree.parentFrame(this._id) || null;
      }
      childFrames() {
        return this._frameManager._frameTree.childFrames(this._id);
      }
      async addPreloadScript(preloadScript) {
        const parentFrame = this.parentFrame();
        if (parentFrame && _classPrivateFieldGet(_client9, this) === parentFrame.client) {
          return;
        }
        if (preloadScript.getIdForFrame(this)) {
          return;
        }
        const {
          identifier
        } = await _classPrivateFieldGet(_client9, this).send('Page.addScriptToEvaluateOnNewDocument', {
          source: preloadScript.source
        });
        preloadScript.setIdForFrame(this, identifier);
      }
      async addExposedFunctionBinding(binding) {
        
        
        if (this !== this._frameManager.mainFrame() && !this._hasStartedLoading) {
          return;
        }
        await Promise.all([_classPrivateFieldGet(_client9, this).send('Runtime.addBinding', {
          name: CDP_BINDING_PREFIX + binding.name
        }), this.evaluate(binding.initSource).catch(debugError)]);
      }
      async removeExposedFunctionBinding(binding) {
        
        
        if (this !== this._frameManager.mainFrame() && !this._hasStartedLoading) {
          return;
        }
        await Promise.all([_classPrivateFieldGet(_client9, this).send('Runtime.removeBinding', {
          name: CDP_BINDING_PREFIX + binding.name
        }), this.evaluate(name => {
          
          
          globalThis[name] = undefined;
        }, binding.name).catch(debugError)]);
      }
      async waitForDevicePrompt(options = {}) {
        return await _assertClassBrand(_CdpFrame_brand, this, _deviceRequestPromptManager).call(this).waitForDevicePrompt(options);
      }
      _navigated(framePayload) {
        this._name = framePayload.name;
        _classPrivateFieldSet(_url3, this, `${framePayload.url}${framePayload.urlFragment || ''}`);
      }
      _navigatedWithinDocument(url) {
        _classPrivateFieldSet(_url3, this, url);
      }
      _onLifecycleEvent(loaderId, name) {
        if (name === 'init') {
          this._loaderId = loaderId;
          this._lifecycleEvents.clear();
        }
        this._lifecycleEvents.add(name);
      }
      _onLoadingStopped() {
        this._lifecycleEvents.add('DOMContentLoaded');
        this._lifecycleEvents.add('load');
      }
      _onLoadingStarted() {
        this._hasStartedLoading = true;
      }
      get detached() {
        return _classPrivateFieldGet(_detached2, this);
      }
      [_ref3]() {
        if (_classPrivateFieldGet(_detached2, this)) {
          return;
        }
        _classPrivateFieldSet(_detached2, this, true);
        this.worlds[MAIN_WORLD][disposeSymbol]();
        this.worlds[PUPPETEER_WORLD][disposeSymbol]();
      }
      exposeFunction() {
        throw new UnsupportedOperation();
      }
      async frameElement() {
        const parent = this.parentFrame();
        if (!parent) {
          return null;
        }
        const {
          backendNodeId
        } = await parent.client.send('DOM.getFrameOwner', {
          frameId: this._id
        });
        return await parent.mainRealm().adoptBackendNode(backendNodeId);
      }
    }, (() => {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate(_CdpFrame, null, _goto_decorators, {
        kind: "method",
        name: "goto",
        static: false,
        private: false,
        access: {
          has: obj => "goto" in obj,
          get: obj => obj.goto
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate(_CdpFrame, null, _waitForNavigation_decorators, {
        kind: "method",
        name: "waitForNavigation",
        static: false,
        private: false,
        access: {
          has: obj => "waitForNavigation" in obj,
          get: obj => obj.waitForNavigation
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate(_CdpFrame, null, _setContent_decorators, {
        kind: "method",
        name: "setContent",
        static: false,
        private: false,
        access: {
          has: obj => "setContent" in obj,
          get: obj => obj.setContent
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate(_CdpFrame, null, _addPreloadScript_decorators, {
        kind: "method",
        name: "addPreloadScript",
        static: false,
        private: false,
        access: {
          has: obj => "addPreloadScript" in obj,
          get: obj => obj.addPreloadScript
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate(_CdpFrame, null, _addExposedFunctionBinding_decorators, {
        kind: "method",
        name: "addExposedFunctionBinding",
        static: false,
        private: false,
        access: {
          has: obj => "addExposedFunctionBinding" in obj,
          get: obj => obj.addExposedFunctionBinding
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate(_CdpFrame, null, _removeExposedFunctionBinding_decorators, {
        kind: "method",
        name: "removeExposedFunctionBinding",
        static: false,
        private: false,
        access: {
          has: obj => "removeExposedFunctionBinding" in obj,
          get: obj => obj.removeExposedFunctionBinding
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate(_CdpFrame, null, _waitForDevicePrompt_decorators, {
        kind: "method",
        name: "waitForDevicePrompt",
        static: false,
        private: false,
        access: {
          has: obj => "waitForDevicePrompt" in obj,
          get: obj => obj.waitForDevicePrompt
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(_CdpFrame, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
    })(), _CdpFrame;
    function _onMainWorldConsoleApiCalled(event) {
      this._frameManager.emit(exports.FrameManagerEvent.ConsoleApiCalled, [this.worlds[MAIN_WORLD], event]);
    }
    function _onMainWorldBindingCalled(event) {
      this._frameManager.emit(exports.FrameManagerEvent.BindingCalled, [this.worlds[MAIN_WORLD], event]);
    }
    function _deviceRequestPromptManager() {
      return this._frameManager._deviceRequestPromptManager(_classPrivateFieldGet(_client9, this));
    }
  })();

  class FrameTree {
    constructor() {
      _classPrivateFieldInitSpec(this, _frames, new Map());
      
      _classPrivateFieldInitSpec(this, _parentIds, new Map());
      
      _classPrivateFieldInitSpec(this, _childIds, new Map());
      _classPrivateFieldInitSpec(this, _mainFrame, void 0);
      _classPrivateFieldInitSpec(this, _isMainFrameStale, false);
      _classPrivateFieldInitSpec(this, _waitRequests, new Map());
    }
    getMainFrame() {
      return _classPrivateFieldGet(_mainFrame, this);
    }
    getById(frameId) {
      return _classPrivateFieldGet(_frames, this).get(frameId);
    }
    waitForFrame(frameId) {
      const frame = this.getById(frameId);
      if (frame) {
        return Promise.resolve(frame);
      }
      const deferred = Deferred.create();
      const callbacks = _classPrivateFieldGet(_waitRequests, this).get(frameId) || new Set();
      callbacks.add(deferred);
      return deferred.valueOrThrow();
    }
    frames() {
      return Array.from(_classPrivateFieldGet(_frames, this).values());
    }
    addFrame(frame) {
      _classPrivateFieldGet(_frames, this).set(frame._id, frame);
      if (frame._parentId) {
        _classPrivateFieldGet(_parentIds, this).set(frame._id, frame._parentId);
        if (!_classPrivateFieldGet(_childIds, this).has(frame._parentId)) {
          _classPrivateFieldGet(_childIds, this).set(frame._parentId, new Set());
        }
        _classPrivateFieldGet(_childIds, this).get(frame._parentId).add(frame._id);
      } else if (!_classPrivateFieldGet(_mainFrame, this) || _classPrivateFieldGet(_isMainFrameStale, this)) {
        _classPrivateFieldSet(_mainFrame, this, frame);
        _classPrivateFieldSet(_isMainFrameStale, this, false);
      }
      _classPrivateFieldGet(_waitRequests, this).get(frame._id)?.forEach(request => {
        return request.resolve(frame);
      });
    }
    removeFrame(frame) {
      _classPrivateFieldGet(_frames, this).delete(frame._id);
      _classPrivateFieldGet(_parentIds, this).delete(frame._id);
      if (frame._parentId) {
        _classPrivateFieldGet(_childIds, this).get(frame._parentId)?.delete(frame._id);
      } else {
        _classPrivateFieldSet(_isMainFrameStale, this, true);
      }
    }
    childFrames(frameId) {
      const childIds = _classPrivateFieldGet(_childIds, this).get(frameId);
      if (!childIds) {
        return [];
      }
      return Array.from(childIds).map(id => {
        return this.getById(id);
      }).filter(frame => {
        return frame !== undefined;
      });
    }
    parentFrame(frameId) {
      const parentId = _classPrivateFieldGet(_parentIds, this).get(frameId);
      return parentId ? this.getById(parentId) : undefined;
    }
  }

  class CdpHTTPRequest extends HTTPRequest {
    get client() {
      return _classPrivateFieldGet(_client10, this);
    }
    set client(newClient) {
      _classPrivateFieldSet(_client10, this, newClient);
    }
    constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {
      super();
      _defineProperty(this, "id", void 0);
      _classPrivateFieldInitSpec(this, _client10, void 0);
      _classPrivateFieldInitSpec(this, _isNavigationRequest, void 0);
      _classPrivateFieldInitSpec(this, _url4, void 0);
      _classPrivateFieldInitSpec(this, _resourceType, void 0);
      _classPrivateFieldInitSpec(this, _method, void 0);
      _classPrivateFieldInitSpec(this, _hasPostData, false);
      _classPrivateFieldInitSpec(this, _postData, void 0);
      _classPrivateFieldInitSpec(this, _headers, {});
      _classPrivateFieldInitSpec(this, _frame4, void 0);
      _classPrivateFieldInitSpec(this, _initiator, void 0);
      _classPrivateFieldSet(_client10, this, client);
      this.id = data.requestId;
      _classPrivateFieldSet(_isNavigationRequest, this, data.requestId === data.loaderId && data.type === 'Document');
      this._interceptionId = interceptionId;
      _classPrivateFieldSet(_url4, this, data.request.url + (data.request.urlFragment ?? ''));
      _classPrivateFieldSet(_resourceType, this, (data.type || 'other').toLowerCase());
      _classPrivateFieldSet(_method, this, data.request.method);
      _classPrivateFieldSet(_postData, this, data.request.postData);
      _classPrivateFieldSet(_hasPostData, this, data.request.hasPostData ?? false);
      _classPrivateFieldSet(_frame4, this, frame);
      this._redirectChain = redirectChain;
      _classPrivateFieldSet(_initiator, this, data.initiator);
      this.interception.enabled = allowInterception;
      for (const [key, value] of Object.entries(data.request.headers)) {
        _classPrivateFieldGet(_headers, this)[key.toLowerCase()] = value;
      }
    }
    url() {
      return _classPrivateFieldGet(_url4, this);
    }
    resourceType() {
      return _classPrivateFieldGet(_resourceType, this);
    }
    method() {
      return _classPrivateFieldGet(_method, this);
    }
    postData() {
      return _classPrivateFieldGet(_postData, this);
    }
    hasPostData() {
      return _classPrivateFieldGet(_hasPostData, this);
    }
    async fetchPostData() {
      try {
        const result = await _classPrivateFieldGet(_client10, this).send('Network.getRequestPostData', {
          requestId: this.id
        });
        return result.postData;
      } catch (err) {
        debugError(err);
        return;
      }
    }
    headers() {
      return _classPrivateFieldGet(_headers, this);
    }
    response() {
      return this._response;
    }
    frame() {
      return _classPrivateFieldGet(_frame4, this);
    }
    isNavigationRequest() {
      return _classPrivateFieldGet(_isNavigationRequest, this);
    }
    initiator() {
      return _classPrivateFieldGet(_initiator, this);
    }
    redirectChain() {
      return this._redirectChain.slice();
    }
    failure() {
      if (!this._failureText) {
        return null;
      }
      return {
        errorText: this._failureText
      };
    }
    async _continue(overrides = {}) {
      const {
        url,
        method,
        postData,
        headers
      } = overrides;
      this.interception.handled = true;
      const postDataBinaryBase64 = postData ? stringToBase64(postData) : undefined;
      if (this._interceptionId === undefined) {
        throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.continueRequest');
      }
      await _classPrivateFieldGet(_client10, this).send('Fetch.continueRequest', {
        requestId: this._interceptionId,
        url,
        method,
        postData: postDataBinaryBase64,
        headers: headers ? headersArray(headers) : undefined
      }).catch(error => {
        this.interception.handled = false;
        return handleError(error);
      });
    }
    async _respond(response) {
      this.interception.handled = true;
      let parsedBody;
      if (response.body) {
        parsedBody = HTTPRequest.getResponse(response.body);
      }
      const responseHeaders = {};
      if (response.headers) {
        for (const header of Object.keys(response.headers)) {
          const value = response.headers[header];
          responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map(item => {
            return String(item);
          }) : String(value);
        }
      }
      if (response.contentType) {
        responseHeaders['content-type'] = response.contentType;
      }
      if (parsedBody?.contentLength && !('content-length' in responseHeaders)) {
        responseHeaders['content-length'] = String(parsedBody.contentLength);
      }
      const status = response.status || 200;
      if (this._interceptionId === undefined) {
        throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest');
      }
      await _classPrivateFieldGet(_client10, this).send('Fetch.fulfillRequest', {
        requestId: this._interceptionId,
        responseCode: status,
        responsePhrase: STATUS_TEXTS[status],
        responseHeaders: headersArray(responseHeaders),
        body: parsedBody?.base64
      }).catch(error => {
        this.interception.handled = false;
        return handleError(error);
      });
    }
    async _abort(errorReason) {
      this.interception.handled = true;
      if (this._interceptionId === undefined) {
        throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.failRequest');
      }
      await _classPrivateFieldGet(_client10, this).send('Fetch.failRequest', {
        requestId: this._interceptionId,
        errorReason: errorReason || 'Failed'
      }).catch(handleError);
    }
  }

  class SecurityDetails {
    constructor(securityPayload) {
      _classPrivateFieldInitSpec(this, _subjectName, void 0);
      _classPrivateFieldInitSpec(this, _issuer, void 0);
      _classPrivateFieldInitSpec(this, _validFrom, void 0);
      _classPrivateFieldInitSpec(this, _validTo, void 0);
      _classPrivateFieldInitSpec(this, _protocol, void 0);
      _classPrivateFieldInitSpec(this, _sanList, void 0);
      _classPrivateFieldSet(_subjectName, this, securityPayload.subjectName);
      _classPrivateFieldSet(_issuer, this, securityPayload.issuer);
      _classPrivateFieldSet(_validFrom, this, securityPayload.validFrom);
      _classPrivateFieldSet(_validTo, this, securityPayload.validTo);
      _classPrivateFieldSet(_protocol, this, securityPayload.protocol);
      _classPrivateFieldSet(_sanList, this, securityPayload.sanList);
    }
    issuer() {
      return _classPrivateFieldGet(_issuer, this);
    }
    validFrom() {
      return _classPrivateFieldGet(_validFrom, this);
    }
    validTo() {
      return _classPrivateFieldGet(_validTo, this);
    }
    protocol() {
      return _classPrivateFieldGet(_protocol, this);
    }
    subjectName() {
      return _classPrivateFieldGet(_subjectName, this);
    }
    subjectAlternativeNames() {
      return _classPrivateFieldGet(_sanList, this);
    }
  }

  class CdpHTTPResponse extends HTTPResponse {
    constructor(request, responsePayload, _extraInfo) {
      super();
      _classPrivateMethodInitSpec(this, _CdpHTTPResponse_brand);
      _classPrivateFieldInitSpec(this, _request, void 0);
      _classPrivateFieldInitSpec(this, _contentPromise, null);
      _classPrivateFieldInitSpec(this, _bodyLoadedDeferred, Deferred.create());
      _classPrivateFieldInitSpec(this, _remoteAddress, void 0);
      _classPrivateFieldInitSpec(this, _status, void 0);
      _classPrivateFieldInitSpec(this, _statusText, void 0);
      _classPrivateFieldInitSpec(this, _fromDiskCache, void 0);
      _classPrivateFieldInitSpec(this, _fromServiceWorker, void 0);
      _classPrivateFieldInitSpec(this, _headers2, {});
      _classPrivateFieldInitSpec(this, _securityDetails, void 0);
      _classPrivateFieldInitSpec(this, _timing, void 0);
      _classPrivateFieldSet(_request, this, request);
      _classPrivateFieldSet(_remoteAddress, this, {
        ip: responsePayload.remoteIPAddress,
        port: responsePayload.remotePort
      });
      _classPrivateFieldSet(_statusText, this, _assertClassBrand(_CdpHTTPResponse_brand, this, _parseStatusTextFromExtraInfo).call(this, _extraInfo) || responsePayload.statusText);
      _classPrivateFieldSet(_fromDiskCache, this, !!responsePayload.fromDiskCache);
      _classPrivateFieldSet(_fromServiceWorker, this, !!responsePayload.fromServiceWorker);
      _classPrivateFieldSet(_status, this, _extraInfo ? _extraInfo.statusCode : responsePayload.status);
      const headers = _extraInfo ? _extraInfo.headers : responsePayload.headers;
      for (const [key, value] of Object.entries(headers)) {
        _classPrivateFieldGet(_headers2, this)[key.toLowerCase()] = value;
      }
      _classPrivateFieldSet(_securityDetails, this, responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null);
      _classPrivateFieldSet(_timing, this, responsePayload.timing || null);
    }
    _resolveBody(err) {
      if (err) {
        return _classPrivateFieldGet(_bodyLoadedDeferred, this).reject(err);
      }
      return _classPrivateFieldGet(_bodyLoadedDeferred, this).resolve();
    }
    remoteAddress() {
      return _classPrivateFieldGet(_remoteAddress, this);
    }
    url() {
      return _classPrivateFieldGet(_request, this).url();
    }
    status() {
      return _classPrivateFieldGet(_status, this);
    }
    statusText() {
      return _classPrivateFieldGet(_statusText, this);
    }
    headers() {
      return _classPrivateFieldGet(_headers2, this);
    }
    securityDetails() {
      return _classPrivateFieldGet(_securityDetails, this);
    }
    timing() {
      return _classPrivateFieldGet(_timing, this);
    }
    content() {
      if (!_classPrivateFieldGet(_contentPromise, this)) {
        _classPrivateFieldSet(_contentPromise, this, _classPrivateFieldGet(_bodyLoadedDeferred, this).valueOrThrow().then(async () => {
          try {
            
            
            const response = await _classPrivateFieldGet(_request, this).client.send('Network.getResponseBody', {
              requestId: _classPrivateFieldGet(_request, this).id
            });
            return stringToTypedArray(response.body, response.base64Encoded);
          } catch (error) {
            if (error instanceof ProtocolError && error.originalMessage === 'No resource with given identifier found') {
              throw new ProtocolError('Could not load body for this request. This might happen if the request is a preflight request.');
            }
            throw error;
          }
        }));
      }
      return _classPrivateFieldGet(_contentPromise, this);
    }
    request() {
      return _classPrivateFieldGet(_request, this);
    }
    fromCache() {
      return _classPrivateFieldGet(_fromDiskCache, this) || _classPrivateFieldGet(_request, this)._fromMemoryCache;
    }
    fromServiceWorker() {
      return _classPrivateFieldGet(_fromServiceWorker, this);
    }
    frame() {
      return _classPrivateFieldGet(_request, this).frame();
    }
  }

  function _parseStatusTextFromExtraInfo(extraInfo) {
    if (!extraInfo || !extraInfo.headersText) {
      return;
    }
    const firstLine = extraInfo.headersText.split('\r', 1)[0];
    if (!firstLine || firstLine.length > 1_000) {
      return;
    }
    const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
    if (!match) {
      return;
    }
    const statusText = match[1];
    if (!statusText) {
      return;
    }
    return statusText;
  }
  class NetworkEventManager {
    constructor() {
      _classPrivateFieldInitSpec(this, _requestWillBeSentMap, new Map());
      _classPrivateFieldInitSpec(this, _requestPausedMap, new Map());
      _classPrivateFieldInitSpec(this, _httpRequestsMap, new Map());
      _classPrivateFieldInitSpec(this, _responseReceivedExtraInfoMap, new Map());
      _classPrivateFieldInitSpec(this, _queuedRedirectInfoMap, new Map());
      _classPrivateFieldInitSpec(this, _queuedEventGroupMap, new Map());
    }
    forget(networkRequestId) {
      _classPrivateFieldGet(_requestWillBeSentMap, this).delete(networkRequestId);
      _classPrivateFieldGet(_requestPausedMap, this).delete(networkRequestId);
      _classPrivateFieldGet(_queuedEventGroupMap, this).delete(networkRequestId);
      _classPrivateFieldGet(_queuedRedirectInfoMap, this).delete(networkRequestId);
      _classPrivateFieldGet(_responseReceivedExtraInfoMap, this).delete(networkRequestId);
    }
    responseExtraInfo(networkRequestId) {
      if (!_classPrivateFieldGet(_responseReceivedExtraInfoMap, this).has(networkRequestId)) {
        _classPrivateFieldGet(_responseReceivedExtraInfoMap, this).set(networkRequestId, []);
      }
      return _classPrivateFieldGet(_responseReceivedExtraInfoMap, this).get(networkRequestId);
    }
    queuedRedirectInfo(fetchRequestId) {
      if (!_classPrivateFieldGet(_queuedRedirectInfoMap, this).has(fetchRequestId)) {
        _classPrivateFieldGet(_queuedRedirectInfoMap, this).set(fetchRequestId, []);
      }
      return _classPrivateFieldGet(_queuedRedirectInfoMap, this).get(fetchRequestId);
    }
    queueRedirectInfo(fetchRequestId, redirectInfo) {
      this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
    }
    takeQueuedRedirectInfo(fetchRequestId) {
      return this.queuedRedirectInfo(fetchRequestId).shift();
    }
    inFlightRequestsCount() {
      let inFlightRequestCounter = 0;
      for (const request of _classPrivateFieldGet(_httpRequestsMap, this).values()) {
        if (!request.response()) {
          inFlightRequestCounter++;
        }
      }
      return inFlightRequestCounter;
    }
    storeRequestWillBeSent(networkRequestId, event) {
      _classPrivateFieldGet(_requestWillBeSentMap, this).set(networkRequestId, event);
    }
    getRequestWillBeSent(networkRequestId) {
      return _classPrivateFieldGet(_requestWillBeSentMap, this).get(networkRequestId);
    }
    forgetRequestWillBeSent(networkRequestId) {
      _classPrivateFieldGet(_requestWillBeSentMap, this).delete(networkRequestId);
    }
    getRequestPaused(networkRequestId) {
      return _classPrivateFieldGet(_requestPausedMap, this).get(networkRequestId);
    }
    forgetRequestPaused(networkRequestId) {
      _classPrivateFieldGet(_requestPausedMap, this).delete(networkRequestId);
    }
    storeRequestPaused(networkRequestId, event) {
      _classPrivateFieldGet(_requestPausedMap, this).set(networkRequestId, event);
    }
    getRequest(networkRequestId) {
      return _classPrivateFieldGet(_httpRequestsMap, this).get(networkRequestId);
    }
    storeRequest(networkRequestId, request) {
      _classPrivateFieldGet(_httpRequestsMap, this).set(networkRequestId, request);
    }
    forgetRequest(networkRequestId) {
      _classPrivateFieldGet(_httpRequestsMap, this).delete(networkRequestId);
    }
    getQueuedEventGroup(networkRequestId) {
      return _classPrivateFieldGet(_queuedEventGroupMap, this).get(networkRequestId);
    }
    queueEventGroup(networkRequestId, event) {
      _classPrivateFieldGet(_queuedEventGroupMap, this).set(networkRequestId, event);
    }
    forgetQueuedEventGroup(networkRequestId) {
      _classPrivateFieldGet(_queuedEventGroupMap, this).delete(networkRequestId);
    }
    printState() {
      function replacer(_key, value) {
        if (value instanceof Map) {
          return {
            dataType: 'Map',
            value: Array.from(value.entries()) 
          };
        } else if (value instanceof CdpHTTPRequest) {
          return {
            dataType: 'CdpHTTPRequest',
            value: `${value.id}: ${value.url()}`
          };
        }
        {
          return value;
        }
      }
      console.log('httpRequestsMap', JSON.stringify(_classPrivateFieldGet(_httpRequestsMap, this), replacer, 2));
      console.log('requestWillBeSentMap', JSON.stringify(_classPrivateFieldGet(_requestWillBeSentMap, this), replacer, 2));
      console.log('requestWillBeSentMap', JSON.stringify(_classPrivateFieldGet(_responseReceivedExtraInfoMap, this), replacer, 2));
      console.log('requestWillBeSentMap', JSON.stringify(_classPrivateFieldGet(_requestPausedMap, this), replacer, 2));
    }
  }

  class NetworkManager extends EventEmitter {
    constructor(frameManager) {
      super();
      _classPrivateMethodInitSpec(this, _NetworkManager_brand);
      _classPrivateFieldInitSpec(this, _frameManager, void 0);
      _classPrivateFieldInitSpec(this, _networkEventManager, new NetworkEventManager());
      _classPrivateFieldInitSpec(this, _extraHTTPHeaders, void 0);
      _classPrivateFieldInitSpec(this, _credentials, null);
      _classPrivateFieldInitSpec(this, _attemptedAuthentications, new Set());
      _classPrivateFieldInitSpec(this, _userRequestInterceptionEnabled, false);
      _classPrivateFieldInitSpec(this, _protocolRequestInterceptionEnabled, false);
      _classPrivateFieldInitSpec(this, _userCacheDisabled, void 0);
      _classPrivateFieldInitSpec(this, _emulatedNetworkConditions, void 0);
      _classPrivateFieldInitSpec(this, _userAgent, void 0);
      _classPrivateFieldInitSpec(this, _userAgentMetadata, void 0);
      _classPrivateFieldInitSpec(this, _handlers3, [['Fetch.requestPaused', _assertClassBrand(_NetworkManager_brand, this, _onRequestPaused)], ['Fetch.authRequired', _assertClassBrand(_NetworkManager_brand, this, _onAuthRequired)], ['Network.requestWillBeSent', _assertClassBrand(_NetworkManager_brand, this, _onRequestWillBeSent)], ['Network.requestServedFromCache', _assertClassBrand(_NetworkManager_brand, this, _onRequestServedFromCache)], ['Network.responseReceived', _assertClassBrand(_NetworkManager_brand, this, _onResponseReceived)], ['Network.loadingFinished', _assertClassBrand(_NetworkManager_brand, this, _onLoadingFinished)], ['Network.loadingFailed', _assertClassBrand(_NetworkManager_brand, this, _onLoadingFailed)], ['Network.responseReceivedExtraInfo', _assertClassBrand(_NetworkManager_brand, this, _onResponseReceivedExtraInfo)], [exports.CDPSessionEvent.Disconnected, _assertClassBrand(_NetworkManager_brand, this, _removeClient)]]);
      _classPrivateFieldInitSpec(this, _clients, new Map());
      _classPrivateFieldSet(_frameManager, this, frameManager);
    }
    async addClient(client) {
      if (_classPrivateFieldGet(_clients, this).has(client)) {
        return;
      }
      const subscriptions = new DisposableStack();
      _classPrivateFieldGet(_clients, this).set(client, subscriptions);
      const clientEmitter = subscriptions.use(new EventEmitter(client));
      for (const [event, handler] of _classPrivateFieldGet(_handlers3, this)) {
        clientEmitter.on(event, arg => {
          return handler.bind(this)(client, arg);
        });
      }
      await Promise.all([client.send('Network.enable'), _assertClassBrand(_NetworkManager_brand, this, _applyExtraHTTPHeaders).call(this, client), _assertClassBrand(_NetworkManager_brand, this, _applyNetworkConditions).call(this, client), _assertClassBrand(_NetworkManager_brand, this, _applyProtocolCacheDisabled).call(this, client), _assertClassBrand(_NetworkManager_brand, this, _applyProtocolRequestInterception).call(this, client), _assertClassBrand(_NetworkManager_brand, this, _applyUserAgent).call(this, client)]);
    }
    async authenticate(credentials) {
      _classPrivateFieldSet(_credentials, this, credentials);
      const enabled = _classPrivateFieldGet(_userRequestInterceptionEnabled, this) || !!_classPrivateFieldGet(_credentials, this);
      if (enabled === _classPrivateFieldGet(_protocolRequestInterceptionEnabled, this)) {
        return;
      }
      _classPrivateFieldSet(_protocolRequestInterceptionEnabled, this, enabled);
      await _assertClassBrand(_NetworkManager_brand, this, _applyToAllClients).call(this, _assertClassBrand(_NetworkManager_brand, this, _applyProtocolRequestInterception).bind(this));
    }
    async setExtraHTTPHeaders(headers) {
      const extraHTTPHeaders = {};
      for (const [key, value] of Object.entries(headers)) {
        assert(isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
        extraHTTPHeaders[key.toLowerCase()] = value;
      }
      _classPrivateFieldSet(_extraHTTPHeaders, this, extraHTTPHeaders);
      await _assertClassBrand(_NetworkManager_brand, this, _applyToAllClients).call(this, _assertClassBrand(_NetworkManager_brand, this, _applyExtraHTTPHeaders).bind(this));
    }
    extraHTTPHeaders() {
      return Object.assign({}, _classPrivateFieldGet(_extraHTTPHeaders, this));
    }
    inFlightRequestsCount() {
      return _classPrivateFieldGet(_networkEventManager, this).inFlightRequestsCount();
    }
    async setOfflineMode(value) {
      if (!_classPrivateFieldGet(_emulatedNetworkConditions, this)) {
        _classPrivateFieldSet(_emulatedNetworkConditions, this, {
          offline: false,
          upload: -1,
          download: -1,
          latency: 0
        });
      }
      _classPrivateFieldGet(_emulatedNetworkConditions, this).offline = value;
      await _assertClassBrand(_NetworkManager_brand, this, _applyToAllClients).call(this, _assertClassBrand(_NetworkManager_brand, this, _applyNetworkConditions).bind(this));
    }
    async emulateNetworkConditions(networkConditions) {
      if (!_classPrivateFieldGet(_emulatedNetworkConditions, this)) {
        _classPrivateFieldSet(_emulatedNetworkConditions, this, {
          offline: false,
          upload: -1,
          download: -1,
          latency: 0
        });
      }
      _classPrivateFieldGet(_emulatedNetworkConditions, this).upload = networkConditions ? networkConditions.upload : -1;
      _classPrivateFieldGet(_emulatedNetworkConditions, this).download = networkConditions ? networkConditions.download : -1;
      _classPrivateFieldGet(_emulatedNetworkConditions, this).latency = networkConditions ? networkConditions.latency : 0;
      await _assertClassBrand(_NetworkManager_brand, this, _applyToAllClients).call(this, _assertClassBrand(_NetworkManager_brand, this, _applyNetworkConditions).bind(this));
    }
    async setUserAgent(userAgent, userAgentMetadata) {
      _classPrivateFieldSet(_userAgent, this, userAgent);
      _classPrivateFieldSet(_userAgentMetadata, this, userAgentMetadata);
      await _assertClassBrand(_NetworkManager_brand, this, _applyToAllClients).call(this, _assertClassBrand(_NetworkManager_brand, this, _applyUserAgent).bind(this));
    }
    async setCacheEnabled(enabled) {
      _classPrivateFieldSet(_userCacheDisabled, this, !enabled);
      await _assertClassBrand(_NetworkManager_brand, this, _applyToAllClients).call(this, _assertClassBrand(_NetworkManager_brand, this, _applyProtocolCacheDisabled).bind(this));
    }
    async setRequestInterception(value) {
      _classPrivateFieldSet(_userRequestInterceptionEnabled, this, value);
      const enabled = _classPrivateFieldGet(_userRequestInterceptionEnabled, this) || !!_classPrivateFieldGet(_credentials, this);
      if (enabled === _classPrivateFieldGet(_protocolRequestInterceptionEnabled, this)) {
        return;
      }
      _classPrivateFieldSet(_protocolRequestInterceptionEnabled, this, enabled);
      await _assertClassBrand(_NetworkManager_brand, this, _applyToAllClients).call(this, _assertClassBrand(_NetworkManager_brand, this, _applyProtocolRequestInterception).bind(this));
    }
  }

  async function _removeClient(client) {
    _classPrivateFieldGet(_clients, this).get(client)?.dispose();
    _classPrivateFieldGet(_clients, this).delete(client);
  }
  async function _applyExtraHTTPHeaders(client) {
    if (_classPrivateFieldGet(_extraHTTPHeaders, this) === undefined) {
      return;
    }
    await client.send('Network.setExtraHTTPHeaders', {
      headers: _classPrivateFieldGet(_extraHTTPHeaders, this)
    });
  }
  async function _applyToAllClients(fn) {
    await Promise.all(Array.from(_classPrivateFieldGet(_clients, this).keys()).map(client => {
      return fn(client);
    }));
  }
  async function _applyNetworkConditions(client) {
    if (_classPrivateFieldGet(_emulatedNetworkConditions, this) === undefined) {
      return;
    }
    await client.send('Network.emulateNetworkConditions', {
      offline: _classPrivateFieldGet(_emulatedNetworkConditions, this).offline,
      latency: _classPrivateFieldGet(_emulatedNetworkConditions, this).latency,
      uploadThroughput: _classPrivateFieldGet(_emulatedNetworkConditions, this).upload,
      downloadThroughput: _classPrivateFieldGet(_emulatedNetworkConditions, this).download
    });
  }
  async function _applyUserAgent(client) {
    if (_classPrivateFieldGet(_userAgent, this) === undefined) {
      return;
    }
    await client.send('Network.setUserAgentOverride', {
      userAgent: _classPrivateFieldGet(_userAgent, this),
      userAgentMetadata: _classPrivateFieldGet(_userAgentMetadata, this)
    });
  }
  async function _applyProtocolRequestInterception(client) {
    if (_classPrivateFieldGet(_userCacheDisabled, this) === undefined) {
      _classPrivateFieldSet(_userCacheDisabled, this, false);
    }
    if (_classPrivateFieldGet(_protocolRequestInterceptionEnabled, this)) {
      await Promise.all([_assertClassBrand(_NetworkManager_brand, this, _applyProtocolCacheDisabled).call(this, client), client.send('Fetch.enable', {
        handleAuthRequests: true,
        patterns: [{
          urlPattern: '*'
        }]
      })]);
    } else {
      await Promise.all([_assertClassBrand(_NetworkManager_brand, this, _applyProtocolCacheDisabled).call(this, client), client.send('Fetch.disable')]);
    }
  }
  async function _applyProtocolCacheDisabled(client) {
    if (_classPrivateFieldGet(_userCacheDisabled, this) === undefined) {
      return;
    }
    await client.send('Network.setCacheDisabled', {
      cacheDisabled: _classPrivateFieldGet(_userCacheDisabled, this)
    });
  }
  function _onRequestWillBeSent(client, event) {
    
    if (_classPrivateFieldGet(_userRequestInterceptionEnabled, this) && !event.request.url.startsWith('data:')) {
      const {
        requestId: networkRequestId
      } = event;
      _classPrivateFieldGet(_networkEventManager, this).storeRequestWillBeSent(networkRequestId, event);
      const requestPausedEvent = _classPrivateFieldGet(_networkEventManager, this).getRequestPaused(networkRequestId);
      if (requestPausedEvent) {
        const {
          requestId: fetchRequestId
        } = requestPausedEvent;
        _assertClassBrand(_NetworkManager_brand, this, _patchRequestEventHeaders).call(this, event, requestPausedEvent);
        _assertClassBrand(_NetworkManager_brand, this, _onRequest2).call(this, client, event, fetchRequestId);
        _classPrivateFieldGet(_networkEventManager, this).forgetRequestPaused(networkRequestId);
      }
      return;
    }
    _assertClassBrand(_NetworkManager_brand, this, _onRequest2).call(this, client, event, undefined);
  }
  function _onAuthRequired(client, event) {
    let response = 'Default';
    if (_classPrivateFieldGet(_attemptedAuthentications, this).has(event.requestId)) {
      response = 'CancelAuth';
    } else if (_classPrivateFieldGet(_credentials, this)) {
      response = 'ProvideCredentials';
      _classPrivateFieldGet(_attemptedAuthentications, this).add(event.requestId);
    }
    const {
      username,
      password
    } = _classPrivateFieldGet(_credentials, this) || {
      username: undefined,
      password: undefined
    };
    client.send('Fetch.continueWithAuth', {
      requestId: event.requestId,
      authChallengeResponse: {
        response,
        username,
        password
      }
    }).catch(debugError);
  }
  function _onRequestPaused(client, event) {
    if (!_classPrivateFieldGet(_userRequestInterceptionEnabled, this) && _classPrivateFieldGet(_protocolRequestInterceptionEnabled, this)) {
      client.send('Fetch.continueRequest', {
        requestId: event.requestId
      }).catch(debugError);
    }
    const {
      networkId: networkRequestId,
      requestId: fetchRequestId
    } = event;
    if (!networkRequestId) {
      _assertClassBrand(_NetworkManager_brand, this, _onRequestWithoutNetworkInstrumentation).call(this, client, event);
      return;
    }
    const requestWillBeSentEvent = (() => {
      const requestWillBeSentEvent = _classPrivateFieldGet(_networkEventManager, this).getRequestWillBeSent(networkRequestId);
      
      if (requestWillBeSentEvent && (requestWillBeSentEvent.request.url !== event.request.url || requestWillBeSentEvent.request.method !== event.request.method)) {
        _classPrivateFieldGet(_networkEventManager, this).forgetRequestWillBeSent(networkRequestId);
        return;
      }
      return requestWillBeSentEvent;
    })();
    if (requestWillBeSentEvent) {
      _assertClassBrand(_NetworkManager_brand, this, _patchRequestEventHeaders).call(this, requestWillBeSentEvent, event);
      _assertClassBrand(_NetworkManager_brand, this, _onRequest2).call(this, client, requestWillBeSentEvent, fetchRequestId);
    } else {
      _classPrivateFieldGet(_networkEventManager, this).storeRequestPaused(networkRequestId, event);
    }
  }
  function _patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {
    requestWillBeSentEvent.request.headers = {
      ...requestWillBeSentEvent.request.headers,
      
      ...requestPausedEvent.request.headers
    };
  }
  function _onRequestWithoutNetworkInstrumentation(client, event) {
    
    
    const frame = event.frameId ? _classPrivateFieldGet(_frameManager, this).frame(event.frameId) : null;
    const request = new CdpHTTPRequest(client, frame, event.requestId, _classPrivateFieldGet(_userRequestInterceptionEnabled, this), event, []);
    this.emit(exports.NetworkManagerEvent.Request, request);
    void request.finalizeInterceptions();
  }
  function _onRequest2(client, event, fetchRequestId, fromMemoryCache = false) {
    let redirectChain = [];
    if (event.redirectResponse) {
      
      
      
      
      
      
      
      let redirectResponseExtraInfo = null;
      if (event.redirectHasExtraInfo) {
        redirectResponseExtraInfo = _classPrivateFieldGet(_networkEventManager, this).responseExtraInfo(event.requestId).shift();
        if (!redirectResponseExtraInfo) {
          _classPrivateFieldGet(_networkEventManager, this).queueRedirectInfo(event.requestId, {
            event,
            fetchRequestId
          });
          return;
        }
      }
      const request = _classPrivateFieldGet(_networkEventManager, this).getRequest(event.requestId);
      
      
      if (request) {
        _assertClassBrand(_NetworkManager_brand, this, _handleRequestRedirect).call(this, client, request, event.redirectResponse, redirectResponseExtraInfo);
        redirectChain = request._redirectChain;
      }
    }
    const frame = event.frameId ? _classPrivateFieldGet(_frameManager, this).frame(event.frameId) : null;
    const request = new CdpHTTPRequest(client, frame, fetchRequestId, _classPrivateFieldGet(_userRequestInterceptionEnabled, this), event, redirectChain);
    request._fromMemoryCache = fromMemoryCache;
    _classPrivateFieldGet(_networkEventManager, this).storeRequest(event.requestId, request);
    this.emit(exports.NetworkManagerEvent.Request, request);
    void request.finalizeInterceptions();
  }
  function _onRequestServedFromCache(client, event) {
    const requestWillBeSentEvent = _classPrivateFieldGet(_networkEventManager, this).getRequestWillBeSent(event.requestId);
    let request = _classPrivateFieldGet(_networkEventManager, this).getRequest(event.requestId);
    
    if (request) {
      request._fromMemoryCache = true;
    }
    
    
    if (!request && requestWillBeSentEvent) {
      _assertClassBrand(_NetworkManager_brand, this, _onRequest2).call(this, client, requestWillBeSentEvent, undefined, true);
      request = _classPrivateFieldGet(_networkEventManager, this).getRequest(event.requestId);
    }
    if (!request) {
      debugError(new Error(`Request ${event.requestId} was served from cache but we could not find the corresponding request object`));
      return;
    }
    this.emit(exports.NetworkManagerEvent.RequestServedFromCache, request);
  }
  function _handleRequestRedirect(_client, request, responsePayload, extraInfo) {
    const response = new CdpHTTPResponse(request, responsePayload, extraInfo);
    request._response = response;
    request._redirectChain.push(request);
    response._resolveBody(new Error('Response body is unavailable for redirect responses'));
    _assertClassBrand(_NetworkManager_brand, this, _forgetRequest).call(this, request, false);
    this.emit(exports.NetworkManagerEvent.Response, response);
    this.emit(exports.NetworkManagerEvent.RequestFinished, request);
  }
  function _emitResponseEvent(_client, responseReceived, extraInfo) {
    const request = _classPrivateFieldGet(_networkEventManager, this).getRequest(responseReceived.requestId);
    
    if (!request) {
      return;
    }
    const extraInfos = _classPrivateFieldGet(_networkEventManager, this).responseExtraInfo(responseReceived.requestId);
    if (extraInfos.length) {
      debugError(new Error('Unexpected extraInfo events for request ' + responseReceived.requestId));
    }
    
    
    
    if (responseReceived.response.fromDiskCache) {
      extraInfo = null;
    }
    const response = new CdpHTTPResponse(request, responseReceived.response, extraInfo);
    request._response = response;
    this.emit(exports.NetworkManagerEvent.Response, response);
  }
  function _onResponseReceived(client, event) {
    const request = _classPrivateFieldGet(_networkEventManager, this).getRequest(event.requestId);
    let extraInfo = null;
    if (request && !request._fromMemoryCache && event.hasExtraInfo) {
      extraInfo = _classPrivateFieldGet(_networkEventManager, this).responseExtraInfo(event.requestId).shift();
      if (!extraInfo) {
        
        _classPrivateFieldGet(_networkEventManager, this).queueEventGroup(event.requestId, {
          responseReceivedEvent: event
        });
        return;
      }
    }
    _assertClassBrand(_NetworkManager_brand, this, _emitResponseEvent).call(this, client, event, extraInfo);
  }
  function _onResponseReceivedExtraInfo(client, event) {
    
    
    
    const redirectInfo = _classPrivateFieldGet(_networkEventManager, this).takeQueuedRedirectInfo(event.requestId);
    if (redirectInfo) {
      _classPrivateFieldGet(_networkEventManager, this).responseExtraInfo(event.requestId).push(event);
      _assertClassBrand(_NetworkManager_brand, this, _onRequest2).call(this, client, redirectInfo.event, redirectInfo.fetchRequestId);
      return;
    }
    
    
    const queuedEvents = _classPrivateFieldGet(_networkEventManager, this).getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      _classPrivateFieldGet(_networkEventManager, this).forgetQueuedEventGroup(event.requestId);
      _assertClassBrand(_NetworkManager_brand, this, _emitResponseEvent).call(this, client, queuedEvents.responseReceivedEvent, event);
      if (queuedEvents.loadingFinishedEvent) {
        _assertClassBrand(_NetworkManager_brand, this, _emitLoadingFinished).call(this, client, queuedEvents.loadingFinishedEvent);
      }
      if (queuedEvents.loadingFailedEvent) {
        _assertClassBrand(_NetworkManager_brand, this, _emitLoadingFailed).call(this, client, queuedEvents.loadingFailedEvent);
      }
      return;
    }
    
    _classPrivateFieldGet(_networkEventManager, this).responseExtraInfo(event.requestId).push(event);
  }
  function _forgetRequest(request, events) {
    const requestId = request.id;
    const interceptionId = request._interceptionId;
    _classPrivateFieldGet(_networkEventManager, this).forgetRequest(requestId);
    if (interceptionId !== undefined) {
      _classPrivateFieldGet(_attemptedAuthentications, this).delete(interceptionId);
    }
    if (events) {
      _classPrivateFieldGet(_networkEventManager, this).forget(requestId);
    }
  }
  function _onLoadingFinished(client, event) {
    
    
    const queuedEvents = _classPrivateFieldGet(_networkEventManager, this).getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      queuedEvents.loadingFinishedEvent = event;
    } else {
      _assertClassBrand(_NetworkManager_brand, this, _emitLoadingFinished).call(this, client, event);
    }
  }
  function _emitLoadingFinished(client, event) {
    const request = _classPrivateFieldGet(_networkEventManager, this).getRequest(event.requestId);
    
    
    if (!request) {
      return;
    }
    _assertClassBrand(_NetworkManager_brand, this, _maybeReassignOOPIFRequestClient).call(this, client, request);
    
    
    if (request.response()) {
      request.response()?._resolveBody();
    }
    _assertClassBrand(_NetworkManager_brand, this, _forgetRequest).call(this, request, true);
    this.emit(exports.NetworkManagerEvent.RequestFinished, request);
  }
  function _onLoadingFailed(client, event) {
    
    
    const queuedEvents = _classPrivateFieldGet(_networkEventManager, this).getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      queuedEvents.loadingFailedEvent = event;
    } else {
      _assertClassBrand(_NetworkManager_brand, this, _emitLoadingFailed).call(this, client, event);
    }
  }
  function _emitLoadingFailed(client, event) {
    const request = _classPrivateFieldGet(_networkEventManager, this).getRequest(event.requestId);
    
    
    if (!request) {
      return;
    }
    _assertClassBrand(_NetworkManager_brand, this, _maybeReassignOOPIFRequestClient).call(this, client, request);
    request._failureText = event.errorText;
    const response = request.response();
    if (response) {
      response._resolveBody();
    }
    _assertClassBrand(_NetworkManager_brand, this, _forgetRequest).call(this, request, true);
    this.emit(exports.NetworkManagerEvent.RequestFailed, request);
  }
  function _maybeReassignOOPIFRequestClient(client, request) {
    
    
    
    
    
    if (client !== request.client && request.isNavigationRequest()) {
      request.client = client;
    }
  }
  const TIME_FOR_WAITING_FOR_SWAP = 100; 
      _classPrivateMethodInitSpec(this, _FrameManager_brand);
      _classPrivateFieldInitSpec(this, _page, void 0);
      _classPrivateFieldInitSpec(this, _networkManager, void 0);
      _classPrivateFieldInitSpec(this, _timeoutSettings3, void 0);
      _classPrivateFieldInitSpec(this, _isolatedWorlds, new Set());
      _classPrivateFieldInitSpec(this, _client11, void 0);
      _classPrivateFieldInitSpec(this, _scriptsToEvaluateOnNewDocument, new Map());
      _classPrivateFieldInitSpec(this, _bindings2, new Set());
      _defineProperty(this, "_frameTree", new FrameTree());
      _classPrivateFieldInitSpec(this, _frameNavigatedReceived, new Set());
      _classPrivateFieldInitSpec(this, _deviceRequestPromptManagerMap, new WeakMap());
      _classPrivateFieldInitSpec(this, _frameTreeHandled, void 0);
      _classPrivateFieldSet(_client11, this, client);
      _classPrivateFieldSet(_page, this, page);
      _classPrivateFieldSet(_networkManager, this, new NetworkManager(this));
      _classPrivateFieldSet(_timeoutSettings3, this, timeoutSettings);
      this.setupEventListeners(_classPrivateFieldGet(_client11, this));
      client.once(exports.CDPSessionEvent.Disconnected, () => {
        _assertClassBrand(_FrameManager_brand, this, _onClientDisconnect).call(this).catch(debugError);
      });
    }
    async swapFrameTree(client) {
      _classPrivateFieldSet(_client11, this, client);
      const frame = this._frameTree.getMainFrame();
      if (frame) {
        _classPrivateFieldGet(_frameNavigatedReceived, this).add(_classPrivateFieldGet(_client11, this).target()._targetId);
        this._frameTree.removeFrame(frame);
        frame.updateId(_classPrivateFieldGet(_client11, this).target()._targetId);
        this._frameTree.addFrame(frame);
        frame.updateClient(client);
      }
      this.setupEventListeners(client);
      client.once(exports.CDPSessionEvent.Disconnected, () => {
        _assertClassBrand(_FrameManager_brand, this, _onClientDisconnect).call(this).catch(debugError);
      });
      await this.initialize(client, frame);
      await _classPrivateFieldGet(_networkManager, this).addClient(client);
      if (frame) {
        frame.emit(exports.FrameEvent.FrameSwappedByActivation, undefined);
      }
    }
    async registerSpeculativeSession(client) {
      await _classPrivateFieldGet(_networkManager, this).addClient(client);
    }
    setupEventListeners(session) {
      session.on('Page.frameAttached', async event => {
        await _classPrivateFieldGet(_frameTreeHandled, this)?.valueOrThrow();
        _assertClassBrand(_FrameManager_brand, this, _onFrameAttached).call(this, session, event.frameId, event.parentFrameId);
      });
      session.on('Page.frameNavigated', async event => {
        _classPrivateFieldGet(_frameNavigatedReceived, this).add(event.frame.id);
        await _classPrivateFieldGet(_frameTreeHandled, this)?.valueOrThrow();
        void _assertClassBrand(_FrameManager_brand, this, _onFrameNavigated).call(this, event.frame, event.type);
      });
      session.on('Page.navigatedWithinDocument', async event => {
        await _classPrivateFieldGet(_frameTreeHandled, this)?.valueOrThrow();
        _assertClassBrand(_FrameManager_brand, this, _onFrameNavigatedWithinDocument).call(this, event.frameId, event.url);
      });
      session.on('Page.frameDetached', async event => {
        await _classPrivateFieldGet(_frameTreeHandled, this)?.valueOrThrow();
        _assertClassBrand(_FrameManager_brand, this, _onFrameDetached2).call(this, event.frameId, event.reason);
      });
      session.on('Page.frameStartedLoading', async event => {
        await _classPrivateFieldGet(_frameTreeHandled, this)?.valueOrThrow();
        _assertClassBrand(_FrameManager_brand, this, _onFrameStartedLoading).call(this, event.frameId);
      });
      session.on('Page.frameStoppedLoading', async event => {
        await _classPrivateFieldGet(_frameTreeHandled, this)?.valueOrThrow();
        _assertClassBrand(_FrameManager_brand, this, _onFrameStoppedLoading).call(this, event.frameId);
      });
      session.on('Runtime.executionContextCreated', async event => {
        await _classPrivateFieldGet(_frameTreeHandled, this)?.valueOrThrow();
        _assertClassBrand(_FrameManager_brand, this, _onExecutionContextCreated).call(this, event.context, session);
      });
      session.on('Page.lifecycleEvent', async event => {
        await _classPrivateFieldGet(_frameTreeHandled, this)?.valueOrThrow();
        _assertClassBrand(_FrameManager_brand, this, _onLifecycleEvent).call(this, event);
      });
    }
    async initialize(client, frame) {
      try {
        _classPrivateFieldGet(_frameTreeHandled, this)?.resolve();
        _classPrivateFieldSet(_frameTreeHandled, this, Deferred.create());
        
        
        
        
        await Promise.all([_classPrivateFieldGet(_networkManager, this).addClient(client), client.send('Page.enable'), client.send('Page.getFrameTree').then(({
          frameTree
        }) => {
          _assertClassBrand(_FrameManager_brand, this, _handleFrameTree).call(this, client, frameTree);
          _classPrivateFieldGet(_frameTreeHandled, this)?.resolve();
        }), client.send('Page.setLifecycleEventsEnabled', {
          enabled: true
        }), client.send('Runtime.enable').then(() => {
          return _assertClassBrand(_FrameManager_brand, this, _createIsolatedWorld).call(this, client, UTILITY_WORLD_NAME);
        }), ...(frame ? Array.from(_classPrivateFieldGet(_scriptsToEvaluateOnNewDocument, this).values()) : []).map(script => {
          return frame?.addPreloadScript(script);
        }), ...(frame ? Array.from(_classPrivateFieldGet(_bindings2, this).values()) : []).map(binding => {
          return frame?.addExposedFunctionBinding(binding);
        })]);
      } catch (error) {
        _classPrivateFieldGet(_frameTreeHandled, this)?.resolve();
        
        if (isErrorLike(error) && isTargetClosedError(error)) {
          return;
        }
        throw error;
      }
    }
    page() {
      return _classPrivateFieldGet(_page, this);
    }
    mainFrame() {
      const mainFrame = this._frameTree.getMainFrame();
      assert(mainFrame, 'Requesting main frame too early!');
      return mainFrame;
    }
    frames() {
      return Array.from(this._frameTree.frames());
    }
    frame(frameId) {
      return this._frameTree.getById(frameId) || null;
    }
    async addExposedFunctionBinding(binding) {
      _classPrivateFieldGet(_bindings2, this).add(binding);
      await Promise.all(this.frames().map(async frame => {
        return await frame.addExposedFunctionBinding(binding);
      }));
    }
    async removeExposedFunctionBinding(binding) {
      _classPrivateFieldGet(_bindings2, this).delete(binding);
      await Promise.all(this.frames().map(async frame => {
        return await frame.removeExposedFunctionBinding(binding);
      }));
    }
    async evaluateOnNewDocument(source) {
      const {
        identifier
      } = await this.mainFrame()._client().send('Page.addScriptToEvaluateOnNewDocument', {
        source
      });
      const preloadScript = new CdpPreloadScript(this.mainFrame(), identifier, source);
      _classPrivateFieldGet(_scriptsToEvaluateOnNewDocument, this).set(identifier, preloadScript);
      await Promise.all(this.frames().map(async frame => {
        return await frame.addPreloadScript(preloadScript);
      }));
      return {
        identifier
      };
    }
    async removeScriptToEvaluateOnNewDocument(identifier) {
      const preloadScript = _classPrivateFieldGet(_scriptsToEvaluateOnNewDocument, this).get(identifier);
      if (!preloadScript) {
        throw new Error(`Script to evaluate on new document with id ${identifier} not found`);
      }
      _classPrivateFieldGet(_scriptsToEvaluateOnNewDocument, this).delete(identifier);
      await Promise.all(this.frames().map(frame => {
        const identifier = preloadScript.getIdForFrame(frame);
        if (!identifier) {
          return;
        }
        return frame._client().send('Page.removeScriptToEvaluateOnNewDocument', {
          identifier
        }).catch(debugError);
      }));
    }
    onAttachedToTarget(target) {
      if (target._getTargetInfo().type !== 'iframe') {
        return;
      }
      const frame = this.frame(target._getTargetInfo().targetId);
      if (frame) {
        frame.updateClient(target._session());
      }
      this.setupEventListeners(target._session());
      void this.initialize(target._session(), frame);
    }
    _deviceRequestPromptManager(client) {
      let manager = _classPrivateFieldGet(_deviceRequestPromptManagerMap, this).get(client);
      if (manager === undefined) {
        manager = new DeviceRequestPromptManager(client, _classPrivateFieldGet(_timeoutSettings3, this));
        _classPrivateFieldGet(_deviceRequestPromptManagerMap, this).set(client, manager);
      }
      return manager;
    }
  }

  async function _onClientDisconnect() {
    const mainFrame = this._frameTree.getMainFrame();
    if (!mainFrame) {
      return;
    }
    if (!_classPrivateFieldGet(_page, this).browser().connected) {
      
      
      _assertClassBrand(_FrameManager_brand, this, _removeFramesRecursively).call(this, mainFrame);
      return;
    }
    for (const child of mainFrame.childFrames()) {
      _assertClassBrand(_FrameManager_brand, this, _removeFramesRecursively).call(this, child);
    }
    const swapped = Deferred.create({
      timeout: TIME_FOR_WAITING_FOR_SWAP,
      message: 'Frame was not swapped'
    });
    mainFrame.once(exports.FrameEvent.FrameSwappedByActivation, () => {
      swapped.resolve();
    });
    try {
      await swapped.valueOrThrow();
    } catch {
      _assertClassBrand(_FrameManager_brand, this, _removeFramesRecursively).call(this, mainFrame);
    }
  }
  function _onLifecycleEvent(event) {
    const frame = this.frame(event.frameId);
    if (!frame) {
      return;
    }
    frame._onLifecycleEvent(event.loaderId, event.name);
    this.emit(exports.FrameManagerEvent.LifecycleEvent, frame);
    frame.emit(exports.FrameEvent.LifecycleEvent, undefined);
  }
  function _onFrameStartedLoading(frameId) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._onLoadingStarted();
  }
  function _onFrameStoppedLoading(frameId) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._onLoadingStopped();
    this.emit(exports.FrameManagerEvent.LifecycleEvent, frame);
    frame.emit(exports.FrameEvent.LifecycleEvent, undefined);
  }
  function _handleFrameTree(session, frameTree) {
    if (frameTree.frame.parentId) {
      _assertClassBrand(_FrameManager_brand, this, _onFrameAttached).call(this, session, frameTree.frame.id, frameTree.frame.parentId);
    }
    if (!_classPrivateFieldGet(_frameNavigatedReceived, this).has(frameTree.frame.id)) {
      void _assertClassBrand(_FrameManager_brand, this, _onFrameNavigated).call(this, frameTree.frame, 'Navigation');
    } else {
      _classPrivateFieldGet(_frameNavigatedReceived, this).delete(frameTree.frame.id);
    }
    if (!frameTree.childFrames) {
      return;
    }
    for (const child of frameTree.childFrames) {
      _assertClassBrand(_FrameManager_brand, this, _handleFrameTree).call(this, session, child);
    }
  }
  function _onFrameAttached(session, frameId, parentFrameId) {
    let frame = this.frame(frameId);
    if (frame) {
      const parentFrame = this.frame(parentFrameId);
      if (session && parentFrame && frame.client !== parentFrame?.client) {
        
        
        
        frame.updateClient(session);
      }
      return;
    }
    frame = new CdpFrame(this, frameId, parentFrameId, session);
    this._frameTree.addFrame(frame);
    this.emit(exports.FrameManagerEvent.FrameAttached, frame);
  }
  async function _onFrameNavigated(framePayload, navigationType) {
    const frameId = framePayload.id;
    const isMainFrame = !framePayload.parentId;
    let frame = this._frameTree.getById(frameId);
    
    if (frame) {
      for (const child of frame.childFrames()) {
        _assertClassBrand(_FrameManager_brand, this, _removeFramesRecursively).call(this, child);
      }
    }
    
    if (isMainFrame) {
      if (frame) {
        
        this._frameTree.removeFrame(frame);
        frame._id = frameId;
      } else {
        
        frame = new CdpFrame(this, frameId, undefined, _classPrivateFieldGet(_client11, this));
      }
      this._frameTree.addFrame(frame);
    }
    frame = await this._frameTree.waitForFrame(frameId);
    frame._navigated(framePayload);
    this.emit(exports.FrameManagerEvent.FrameNavigated, frame);
    frame.emit(exports.FrameEvent.FrameNavigated, navigationType);
  }
  async function _createIsolatedWorld(session, name) {
    const key = `${session.id()}:${name}`;
    if (_classPrivateFieldGet(_isolatedWorlds, this).has(key)) {
      return;
    }
    await session.send('Page.addScriptToEvaluateOnNewDocument', {
      source: `
      worldName: name
    });
    await Promise.all(this.frames().filter(frame => {
      return frame.client === session;
    }).map(frame => {
      
      
      return session.send('Page.createIsolatedWorld', {
        frameId: frame._id,
        worldName: name,
        grantUniveralAccess: true
      }).catch(debugError);
    }));
    _classPrivateFieldGet(_isolatedWorlds, this).add(key);
  }
  function _onFrameNavigatedWithinDocument(frameId, url) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._navigatedWithinDocument(url);
    this.emit(exports.FrameManagerEvent.FrameNavigatedWithinDocument, frame);
    frame.emit(exports.FrameEvent.FrameNavigatedWithinDocument, undefined);
    this.emit(exports.FrameManagerEvent.FrameNavigated, frame);
    frame.emit(exports.FrameEvent.FrameNavigated, 'Navigation');
  }
  function _onFrameDetached2(frameId, reason) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    switch (reason) {
      case 'remove':
        
        
        
        _assertClassBrand(_FrameManager_brand, this, _removeFramesRecursively).call(this, frame);
        break;
      case 'swap':
        this.emit(exports.FrameManagerEvent.FrameSwapped, frame);
        frame.emit(exports.FrameEvent.FrameSwapped, undefined);
        break;
    }
  }
  function _onExecutionContextCreated(contextPayload, session) {
    const auxData = contextPayload.auxData;
    const frameId = auxData && auxData.frameId;
    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;
    let world;
    if (frame) {
      
      if (frame.client !== session) {
        return;
      }
      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {
        world = frame.worlds[MAIN_WORLD];
      } else if (contextPayload.name === UTILITY_WORLD_NAME) {
        
        
        
        world = frame.worlds[PUPPETEER_WORLD];
      }
    }
    
    if (!world) {
      return;
    }
    const context = new ExecutionContext(frame?.client || _classPrivateFieldGet(_client11, this), contextPayload, world);
    world.setContext(context);
  }
  function _removeFramesRecursively(frame) {
    for (const child of frame.childFrames()) {
      _assertClassBrand(_FrameManager_brand, this, _removeFramesRecursively).call(this, child);
    }
    frame[disposeSymbol]();
    this._frameTree.removeFrame(frame);
    this.emit(exports.FrameManagerEvent.FrameDetached, frame);
    frame.emit(exports.FrameEvent.FrameDetached, frame);
  }
  const _keyDefinitions = {
    '0': {
      keyCode: 48,
      key: '0',
      code: 'Digit0'
    },
    '1': {
      keyCode: 49,
      key: '1',
      code: 'Digit1'
    },
    '2': {
      keyCode: 50,
      key: '2',
      code: 'Digit2'
    },
    '3': {
      keyCode: 51,
      key: '3',
      code: 'Digit3'
    },
    '4': {
      keyCode: 52,
      key: '4',
      code: 'Digit4'
    },
    '5': {
      keyCode: 53,
      key: '5',
      code: 'Digit5'
    },
    '6': {
      keyCode: 54,
      key: '6',
      code: 'Digit6'
    },
    '7': {
      keyCode: 55,
      key: '7',
      code: 'Digit7'
    },
    '8': {
      keyCode: 56,
      key: '8',
      code: 'Digit8'
    },
    '9': {
      keyCode: 57,
      key: '9',
      code: 'Digit9'
    },
    Power: {
      key: 'Power',
      code: 'Power'
    },
    Eject: {
      key: 'Eject',
      code: 'Eject'
    },
    Abort: {
      keyCode: 3,
      code: 'Abort',
      key: 'Cancel'
    },
    Help: {
      keyCode: 6,
      code: 'Help',
      key: 'Help'
    },
    Backspace: {
      keyCode: 8,
      code: 'Backspace',
      key: 'Backspace'
    },
    Tab: {
      keyCode: 9,
      code: 'Tab',
      key: 'Tab'
    },
    Numpad5: {
      keyCode: 12,
      shiftKeyCode: 101,
      key: 'Clear',
      code: 'Numpad5',
      shiftKey: '5',
      location: 3
    },
    NumpadEnter: {
      keyCode: 13,
      code: 'NumpadEnter',
      key: 'Enter',
      text: '\r',
      location: 3
    },
    Enter: {
      keyCode: 13,
      code: 'Enter',
      key: 'Enter',
      text: '\r'
    },
    '\r': {
      keyCode: 13,
      code: 'Enter',
      key: 'Enter',
      text: '\r'
    },
    '\n': {
      keyCode: 13,
      code: 'Enter',
      key: 'Enter',
      text: '\r'
    },
    ShiftLeft: {
      keyCode: 16,
      code: 'ShiftLeft',
      key: 'Shift',
      location: 1
    },
    ShiftRight: {
      keyCode: 16,
      code: 'ShiftRight',
      key: 'Shift',
      location: 2
    },
    ControlLeft: {
      keyCode: 17,
      code: 'ControlLeft',
      key: 'Control',
      location: 1
    },
    ControlRight: {
      keyCode: 17,
      code: 'ControlRight',
      key: 'Control',
      location: 2
    },
    AltLeft: {
      keyCode: 18,
      code: 'AltLeft',
      key: 'Alt',
      location: 1
    },
    AltRight: {
      keyCode: 18,
      code: 'AltRight',
      key: 'Alt',
      location: 2
    },
    Pause: {
      keyCode: 19,
      code: 'Pause',
      key: 'Pause'
    },
    CapsLock: {
      keyCode: 20,
      code: 'CapsLock',
      key: 'CapsLock'
    },
    Escape: {
      keyCode: 27,
      code: 'Escape',
      key: 'Escape'
    },
    Convert: {
      keyCode: 28,
      code: 'Convert',
      key: 'Convert'
    },
    NonConvert: {
      keyCode: 29,
      code: 'NonConvert',
      key: 'NonConvert'
    },
    Space: {
      keyCode: 32,
      code: 'Space',
      key: ' '
    },
    Numpad9: {
      keyCode: 33,
      shiftKeyCode: 105,
      key: 'PageUp',
      code: 'Numpad9',
      shiftKey: '9',
      location: 3
    },
    PageUp: {
      keyCode: 33,
      code: 'PageUp',
      key: 'PageUp'
    },
    Numpad3: {
      keyCode: 34,
      shiftKeyCode: 99,
      key: 'PageDown',
      code: 'Numpad3',
      shiftKey: '3',
      location: 3
    },
    PageDown: {
      keyCode: 34,
      code: 'PageDown',
      key: 'PageDown'
    },
    End: {
      keyCode: 35,
      code: 'End',
      key: 'End'
    },
    Numpad1: {
      keyCode: 35,
      shiftKeyCode: 97,
      key: 'End',
      code: 'Numpad1',
      shiftKey: '1',
      location: 3
    },
    Home: {
      keyCode: 36,
      code: 'Home',
      key: 'Home'
    },
    Numpad7: {
      keyCode: 36,
      shiftKeyCode: 103,
      key: 'Home',
      code: 'Numpad7',
      shiftKey: '7',
      location: 3
    },
    ArrowLeft: {
      keyCode: 37,
      code: 'ArrowLeft',
      key: 'ArrowLeft'
    },
    Numpad4: {
      keyCode: 37,
      shiftKeyCode: 100,
      key: 'ArrowLeft',
      code: 'Numpad4',
      shiftKey: '4',
      location: 3
    },
    Numpad8: {
      keyCode: 38,
      shiftKeyCode: 104,
      key: 'ArrowUp',
      code: 'Numpad8',
      shiftKey: '8',
      location: 3
    },
    ArrowUp: {
      keyCode: 38,
      code: 'ArrowUp',
      key: 'ArrowUp'
    },
    ArrowRight: {
      keyCode: 39,
      code: 'ArrowRight',
      key: 'ArrowRight'
    },
    Numpad6: {
      keyCode: 39,
      shiftKeyCode: 102,
      key: 'ArrowRight',
      code: 'Numpad6',
      shiftKey: '6',
      location: 3
    },
    Numpad2: {
      keyCode: 40,
      shiftKeyCode: 98,
      key: 'ArrowDown',
      code: 'Numpad2',
      shiftKey: '2',
      location: 3
    },
    ArrowDown: {
      keyCode: 40,
      code: 'ArrowDown',
      key: 'ArrowDown'
    },
    Select: {
      keyCode: 41,
      code: 'Select',
      key: 'Select'
    },
    Open: {
      keyCode: 43,
      code: 'Open',
      key: 'Execute'
    },
    PrintScreen: {
      keyCode: 44,
      code: 'PrintScreen',
      key: 'PrintScreen'
    },
    Insert: {
      keyCode: 45,
      code: 'Insert',
      key: 'Insert'
    },
    Numpad0: {
      keyCode: 45,
      shiftKeyCode: 96,
      key: 'Insert',
      code: 'Numpad0',
      shiftKey: '0',
      location: 3
    },
    Delete: {
      keyCode: 46,
      code: 'Delete',
      key: 'Delete'
    },
    NumpadDecimal: {
      keyCode: 46,
      shiftKeyCode: 110,
      code: 'NumpadDecimal',
      key: '\u0000',
      shiftKey: '.',
      location: 3
    },
    Digit0: {
      keyCode: 48,
      code: 'Digit0',
      shiftKey: ')',
      key: '0'
    },
    Digit1: {
      keyCode: 49,
      code: 'Digit1',
      shiftKey: '!',
      key: '1'
    },
    Digit2: {
      keyCode: 50,
      code: 'Digit2',
      shiftKey: '@',
      key: '2'
    },
    Digit3: {
      keyCode: 51,
      code: 'Digit3',
      shiftKey: '#',
      key: '3'
    },
    Digit4: {
      keyCode: 52,
      code: 'Digit4',
      shiftKey: '$',
      key: '4'
    },
    Digit5: {
      keyCode: 53,
      code: 'Digit5',
      shiftKey: '%',
      key: '5'
    },
    Digit6: {
      keyCode: 54,
      code: 'Digit6',
      shiftKey: '^',
      key: '6'
    },
    Digit7: {
      keyCode: 55,
      code: 'Digit7',
      shiftKey: '&',
      key: '7'
    },
    Digit8: {
      keyCode: 56,
      code: 'Digit8',
      shiftKey: '*',
      key: '8'
    },
    Digit9: {
      keyCode: 57,
      code: 'Digit9',
      shiftKey: '(',
      key: '9'
    },
    KeyA: {
      keyCode: 65,
      code: 'KeyA',
      shiftKey: 'A',
      key: 'a'
    },
    KeyB: {
      keyCode: 66,
      code: 'KeyB',
      shiftKey: 'B',
      key: 'b'
    },
    KeyC: {
      keyCode: 67,
      code: 'KeyC',
      shiftKey: 'C',
      key: 'c'
    },
    KeyD: {
      keyCode: 68,
      code: 'KeyD',
      shiftKey: 'D',
      key: 'd'
    },
    KeyE: {
      keyCode: 69,
      code: 'KeyE',
      shiftKey: 'E',
      key: 'e'
    },
    KeyF: {
      keyCode: 70,
      code: 'KeyF',
      shiftKey: 'F',
      key: 'f'
    },
    KeyG: {
      keyCode: 71,
      code: 'KeyG',
      shiftKey: 'G',
      key: 'g'
    },
    KeyH: {
      keyCode: 72,
      code: 'KeyH',
      shiftKey: 'H',
      key: 'h'
    },
    KeyI: {
      keyCode: 73,
      code: 'KeyI',
      shiftKey: 'I',
      key: 'i'
    },
    KeyJ: {
      keyCode: 74,
      code: 'KeyJ',
      shiftKey: 'J',
      key: 'j'
    },
    KeyK: {
      keyCode: 75,
      code: 'KeyK',
      shiftKey: 'K',
      key: 'k'
    },
    KeyL: {
      keyCode: 76,
      code: 'KeyL',
      shiftKey: 'L',
      key: 'l'
    },
    KeyM: {
      keyCode: 77,
      code: 'KeyM',
      shiftKey: 'M',
      key: 'm'
    },
    KeyN: {
      keyCode: 78,
      code: 'KeyN',
      shiftKey: 'N',
      key: 'n'
    },
    KeyO: {
      keyCode: 79,
      code: 'KeyO',
      shiftKey: 'O',
      key: 'o'
    },
    KeyP: {
      keyCode: 80,
      code: 'KeyP',
      shiftKey: 'P',
      key: 'p'
    },
    KeyQ: {
      keyCode: 81,
      code: 'KeyQ',
      shiftKey: 'Q',
      key: 'q'
    },
    KeyR: {
      keyCode: 82,
      code: 'KeyR',
      shiftKey: 'R',
      key: 'r'
    },
    KeyS: {
      keyCode: 83,
      code: 'KeyS',
      shiftKey: 'S',
      key: 's'
    },
    KeyT: {
      keyCode: 84,
      code: 'KeyT',
      shiftKey: 'T',
      key: 't'
    },
    KeyU: {
      keyCode: 85,
      code: 'KeyU',
      shiftKey: 'U',
      key: 'u'
    },
    KeyV: {
      keyCode: 86,
      code: 'KeyV',
      shiftKey: 'V',
      key: 'v'
    },
    KeyW: {
      keyCode: 87,
      code: 'KeyW',
      shiftKey: 'W',
      key: 'w'
    },
    KeyX: {
      keyCode: 88,
      code: 'KeyX',
      shiftKey: 'X',
      key: 'x'
    },
    KeyY: {
      keyCode: 89,
      code: 'KeyY',
      shiftKey: 'Y',
      key: 'y'
    },
    KeyZ: {
      keyCode: 90,
      code: 'KeyZ',
      shiftKey: 'Z',
      key: 'z'
    },
    MetaLeft: {
      keyCode: 91,
      code: 'MetaLeft',
      key: 'Meta',
      location: 1
    },
    MetaRight: {
      keyCode: 92,
      code: 'MetaRight',
      key: 'Meta',
      location: 2
    },
    ContextMenu: {
      keyCode: 93,
      code: 'ContextMenu',
      key: 'ContextMenu'
    },
    NumpadMultiply: {
      keyCode: 106,
      code: 'NumpadMultiply',
      key: '*',
      location: 3
    },
    NumpadAdd: {
      keyCode: 107,
      code: 'NumpadAdd',
      key: '+',
      location: 3
    },
    NumpadSubtract: {
      keyCode: 109,
      code: 'NumpadSubtract',
      key: '-',
      location: 3
    },
    NumpadDivide: {
      keyCode: 111,
      code: 'NumpadDivide',
      key: '/',
      location: 3
    },
    F1: {
      keyCode: 112,
      code: 'F1',
      key: 'F1'
    },
    F2: {
      keyCode: 113,
      code: 'F2',
      key: 'F2'
    },
    F3: {
      keyCode: 114,
      code: 'F3',
      key: 'F3'
    },
    F4: {
      keyCode: 115,
      code: 'F4',
      key: 'F4'
    },
    F5: {
      keyCode: 116,
      code: 'F5',
      key: 'F5'
    },
    F6: {
      keyCode: 117,
      code: 'F6',
      key: 'F6'
    },
    F7: {
      keyCode: 118,
      code: 'F7',
      key: 'F7'
    },
    F8: {
      keyCode: 119,
      code: 'F8',
      key: 'F8'
    },
    F9: {
      keyCode: 120,
      code: 'F9',
      key: 'F9'
    },
    F10: {
      keyCode: 121,
      code: 'F10',
      key: 'F10'
    },
    F11: {
      keyCode: 122,
      code: 'F11',
      key: 'F11'
    },
    F12: {
      keyCode: 123,
      code: 'F12',
      key: 'F12'
    },
    F13: {
      keyCode: 124,
      code: 'F13',
      key: 'F13'
    },
    F14: {
      keyCode: 125,
      code: 'F14',
      key: 'F14'
    },
    F15: {
      keyCode: 126,
      code: 'F15',
      key: 'F15'
    },
    F16: {
      keyCode: 127,
      code: 'F16',
      key: 'F16'
    },
    F17: {
      keyCode: 128,
      code: 'F17',
      key: 'F17'
    },
    F18: {
      keyCode: 129,
      code: 'F18',
      key: 'F18'
    },
    F19: {
      keyCode: 130,
      code: 'F19',
      key: 'F19'
    },
    F20: {
      keyCode: 131,
      code: 'F20',
      key: 'F20'
    },
    F21: {
      keyCode: 132,
      code: 'F21',
      key: 'F21'
    },
    F22: {
      keyCode: 133,
      code: 'F22',
      key: 'F22'
    },
    F23: {
      keyCode: 134,
      code: 'F23',
      key: 'F23'
    },
    F24: {
      keyCode: 135,
      code: 'F24',
      key: 'F24'
    },
    NumLock: {
      keyCode: 144,
      code: 'NumLock',
      key: 'NumLock'
    },
    ScrollLock: {
      keyCode: 145,
      code: 'ScrollLock',
      key: 'ScrollLock'
    },
    AudioVolumeMute: {
      keyCode: 173,
      code: 'AudioVolumeMute',
      key: 'AudioVolumeMute'
    },
    AudioVolumeDown: {
      keyCode: 174,
      code: 'AudioVolumeDown',
      key: 'AudioVolumeDown'
    },
    AudioVolumeUp: {
      keyCode: 175,
      code: 'AudioVolumeUp',
      key: 'AudioVolumeUp'
    },
    MediaTrackNext: {
      keyCode: 176,
      code: 'MediaTrackNext',
      key: 'MediaTrackNext'
    },
    MediaTrackPrevious: {
      keyCode: 177,
      code: 'MediaTrackPrevious',
      key: 'MediaTrackPrevious'
    },
    MediaStop: {
      keyCode: 178,
      code: 'MediaStop',
      key: 'MediaStop'
    },
    MediaPlayPause: {
      keyCode: 179,
      code: 'MediaPlayPause',
      key: 'MediaPlayPause'
    },
    Semicolon: {
      keyCode: 186,
      code: 'Semicolon',
      shiftKey: ':',
      key: ';'
    },
    Equal: {
      keyCode: 187,
      code: 'Equal',
      shiftKey: '+',
      key: '='
    },
    NumpadEqual: {
      keyCode: 187,
      code: 'NumpadEqual',
      key: '=',
      location: 3
    },
    Comma: {
      keyCode: 188,
      code: 'Comma',
      shiftKey: '<',
      key: ','
    },
    Minus: {
      keyCode: 189,
      code: 'Minus',
      shiftKey: '_',
      key: '-'
    },
    Period: {
      keyCode: 190,
      code: 'Period',
      shiftKey: '>',
      key: '.'
    },
    Slash: {
      keyCode: 191,
      code: 'Slash',
      shiftKey: '?',
      key: '/'
    },
    Backquote: {
      keyCode: 192,
      code: 'Backquote',
      shiftKey: '~',
      key: '`'
    },
    BracketLeft: {
      keyCode: 219,
      code: 'BracketLeft',
      shiftKey: '{',
      key: '['
    },
    Backslash: {
      keyCode: 220,
      code: 'Backslash',
      shiftKey: '|',
      key: '\\'
    },
    BracketRight: {
      keyCode: 221,
      code: 'BracketRight',
      shiftKey: '}',
      key: ']'
    },
    Quote: {
      keyCode: 222,
      code: 'Quote',
      shiftKey: '"',
      key: "'"
    },
    AltGraph: {
      keyCode: 225,
      code: 'AltGraph',
      key: 'AltGraph'
    },
    Props: {
      keyCode: 247,
      code: 'Props',
      key: 'CrSel'
    },
    Cancel: {
      keyCode: 3,
      key: 'Cancel',
      code: 'Abort'
    },
    Clear: {
      keyCode: 12,
      key: 'Clear',
      code: 'Numpad5',
      location: 3
    },
    Shift: {
      keyCode: 16,
      key: 'Shift',
      code: 'ShiftLeft',
      location: 1
    },
    Control: {
      keyCode: 17,
      key: 'Control',
      code: 'ControlLeft',
      location: 1
    },
    Alt: {
      keyCode: 18,
      key: 'Alt',
      code: 'AltLeft',
      location: 1
    },
    Accept: {
      keyCode: 30,
      key: 'Accept'
    },
    ModeChange: {
      keyCode: 31,
      key: 'ModeChange'
    },
    ' ': {
      keyCode: 32,
      key: ' ',
      code: 'Space'
    },
    Print: {
      keyCode: 42,
      key: 'Print'
    },
    Execute: {
      keyCode: 43,
      key: 'Execute',
      code: 'Open'
    },
    '\u0000': {
      keyCode: 46,
      key: '\u0000',
      code: 'NumpadDecimal',
      location: 3
    },
    a: {
      keyCode: 65,
      key: 'a',
      code: 'KeyA'
    },
    b: {
      keyCode: 66,
      key: 'b',
      code: 'KeyB'
    },
    c: {
      keyCode: 67,
      key: 'c',
      code: 'KeyC'
    },
    d: {
      keyCode: 68,
      key: 'd',
      code: 'KeyD'
    },
    e: {
      keyCode: 69,
      key: 'e',
      code: 'KeyE'
    },
    f: {
      keyCode: 70,
      key: 'f',
      code: 'KeyF'
    },
    g: {
      keyCode: 71,
      key: 'g',
      code: 'KeyG'
    },
    h: {
      keyCode: 72,
      key: 'h',
      code: 'KeyH'
    },
    i: {
      keyCode: 73,
      key: 'i',
      code: 'KeyI'
    },
    j: {
      keyCode: 74,
      key: 'j',
      code: 'KeyJ'
    },
    k: {
      keyCode: 75,
      key: 'k',
      code: 'KeyK'
    },
    l: {
      keyCode: 76,
      key: 'l',
      code: 'KeyL'
    },
    m: {
      keyCode: 77,
      key: 'm',
      code: 'KeyM'
    },
    n: {
      keyCode: 78,
      key: 'n',
      code: 'KeyN'
    },
    o: {
      keyCode: 79,
      key: 'o',
      code: 'KeyO'
    },
    p: {
      keyCode: 80,
      key: 'p',
      code: 'KeyP'
    },
    q: {
      keyCode: 81,
      key: 'q',
      code: 'KeyQ'
    },
    r: {
      keyCode: 82,
      key: 'r',
      code: 'KeyR'
    },
    s: {
      keyCode: 83,
      key: 's',
      code: 'KeyS'
    },
    t: {
      keyCode: 84,
      key: 't',
      code: 'KeyT'
    },
    u: {
      keyCode: 85,
      key: 'u',
      code: 'KeyU'
    },
    v: {
      keyCode: 86,
      key: 'v',
      code: 'KeyV'
    },
    w: {
      keyCode: 87,
      key: 'w',
      code: 'KeyW'
    },
    x: {
      keyCode: 88,
      key: 'x',
      code: 'KeyX'
    },
    y: {
      keyCode: 89,
      key: 'y',
      code: 'KeyY'
    },
    z: {
      keyCode: 90,
      key: 'z',
      code: 'KeyZ'
    },
    Meta: {
      keyCode: 91,
      key: 'Meta',
      code: 'MetaLeft',
      location: 1
    },
    '*': {
      keyCode: 106,
      key: '*',
      code: 'NumpadMultiply',
      location: 3
    },
    '+': {
      keyCode: 107,
      key: '+',
      code: 'NumpadAdd',
      location: 3
    },
    '-': {
      keyCode: 109,
      key: '-',
      code: 'NumpadSubtract',
      location: 3
    },
    '/': {
      keyCode: 111,
      key: '/',
      code: 'NumpadDivide',
      location: 3
    },
    ';': {
      keyCode: 186,
      key: ';',
      code: 'Semicolon'
    },
    '=': {
      keyCode: 187,
      key: '=',
      code: 'Equal'
    },
    ',': {
      keyCode: 188,
      key: ',',
      code: 'Comma'
    },
    '.': {
      keyCode: 190,
      key: '.',
      code: 'Period'
    },
    '`': {
      keyCode: 192,
      key: '`',
      code: 'Backquote'
    },
    '[': {
      keyCode: 219,
      key: '[',
      code: 'BracketLeft'
    },
    '\\': {
      keyCode: 220,
      key: '\\',
      code: 'Backslash'
    },
    ']': {
      keyCode: 221,
      key: ']',
      code: 'BracketRight'
    },
    "'": {
      keyCode: 222,
      key: "'",
      code: 'Quote'
    },
    Attn: {
      keyCode: 246,
      key: 'Attn'
    },
    CrSel: {
      keyCode: 247,
      key: 'CrSel',
      code: 'Props'
    },
    ExSel: {
      keyCode: 248,
      key: 'ExSel'
    },
    EraseEof: {
      keyCode: 249,
      key: 'EraseEof'
    },
    Play: {
      keyCode: 250,
      key: 'Play'
    },
    ZoomOut: {
      keyCode: 251,
      key: 'ZoomOut'
    },
    ')': {
      keyCode: 48,
      key: ')',
      code: 'Digit0'
    },
    '!': {
      keyCode: 49,
      key: '!',
      code: 'Digit1'
    },
    '@': {
      keyCode: 50,
      key: '@',
      code: 'Digit2'
    },
    '#': {
      keyCode: 51,
      key: '#',
      code: 'Digit3'
    },
    $: {
      keyCode: 52,
      key: '$',
      code: 'Digit4'
    },
    '%': {
      keyCode: 53,
      key: '%',
      code: 'Digit5'
    },
    '^': {
      keyCode: 54,
      key: '^',
      code: 'Digit6'
    },
    '&': {
      keyCode: 55,
      key: '&',
      code: 'Digit7'
    },
    '(': {
      keyCode: 57,
      key: '(',
      code: 'Digit9'
    },
    A: {
      keyCode: 65,
      key: 'A',
      code: 'KeyA'
    },
    B: {
      keyCode: 66,
      key: 'B',
      code: 'KeyB'
    },
    C: {
      keyCode: 67,
      key: 'C',
      code: 'KeyC'
    },
    D: {
      keyCode: 68,
      key: 'D',
      code: 'KeyD'
    },
    E: {
      keyCode: 69,
      key: 'E',
      code: 'KeyE'
    },
    F: {
      keyCode: 70,
      key: 'F',
      code: 'KeyF'
    },
    G: {
      keyCode: 71,
      key: 'G',
      code: 'KeyG'
    },
    H: {
      keyCode: 72,
      key: 'H',
      code: 'KeyH'
    },
    I: {
      keyCode: 73,
      key: 'I',
      code: 'KeyI'
    },
    J: {
      keyCode: 74,
      key: 'J',
      code: 'KeyJ'
    },
    K: {
      keyCode: 75,
      key: 'K',
      code: 'KeyK'
    },
    L: {
      keyCode: 76,
      key: 'L',
      code: 'KeyL'
    },
    M: {
      keyCode: 77,
      key: 'M',
      code: 'KeyM'
    },
    N: {
      keyCode: 78,
      key: 'N',
      code: 'KeyN'
    },
    O: {
      keyCode: 79,
      key: 'O',
      code: 'KeyO'
    },
    P: {
      keyCode: 80,
      key: 'P',
      code: 'KeyP'
    },
    Q: {
      keyCode: 81,
      key: 'Q',
      code: 'KeyQ'
    },
    R: {
      keyCode: 82,
      key: 'R',
      code: 'KeyR'
    },
    S: {
      keyCode: 83,
      key: 'S',
      code: 'KeyS'
    },
    T: {
      keyCode: 84,
      key: 'T',
      code: 'KeyT'
    },
    U: {
      keyCode: 85,
      key: 'U',
      code: 'KeyU'
    },
    V: {
      keyCode: 86,
      key: 'V',
      code: 'KeyV'
    },
    W: {
      keyCode: 87,
      key: 'W',
      code: 'KeyW'
    },
    X: {
      keyCode: 88,
      key: 'X',
      code: 'KeyX'
    },
    Y: {
      keyCode: 89,
      key: 'Y',
      code: 'KeyY'
    },
    Z: {
      keyCode: 90,
      key: 'Z',
      code: 'KeyZ'
    },
    ':': {
      keyCode: 186,
      key: ':',
      code: 'Semicolon'
    },
    '<': {
      keyCode: 188,
      key: '<',
      code: 'Comma'
    },
    _: {
      keyCode: 189,
      key: '_',
      code: 'Minus'
    },
    '>': {
      keyCode: 190,
      key: '>',
      code: 'Period'
    },
    '?': {
      keyCode: 191,
      key: '?',
      code: 'Slash'
    },
    '~': {
      keyCode: 192,
      key: '~',
      code: 'Backquote'
    },
    '{': {
      keyCode: 219,
      key: '{',
      code: 'BracketLeft'
    },
    '|': {
      keyCode: 220,
      key: '|',
      code: 'Backslash'
    },
    '}': {
      keyCode: 221,
      key: '}',
      code: 'BracketRight'
    },
    '"': {
      keyCode: 222,
      key: '"',
      code: 'Quote'
    },
    SoftLeft: {
      key: 'SoftLeft',
      code: 'SoftLeft',
      location: 4
    },
    SoftRight: {
      key: 'SoftRight',
      code: 'SoftRight',
      location: 4
    },
    Camera: {
      keyCode: 44,
      key: 'Camera',
      code: 'Camera',
      location: 4
    },
    Call: {
      key: 'Call',
      code: 'Call',
      location: 4
    },
    EndCall: {
      keyCode: 95,
      key: 'EndCall',
      code: 'EndCall',
      location: 4
    },
    VolumeDown: {
      keyCode: 182,
      key: 'VolumeDown',
      code: 'VolumeDown',
      location: 4
    },
    VolumeUp: {
      keyCode: 183,
      key: 'VolumeUp',
      code: 'VolumeUp',
      location: 4
    }
  };

      case MouseButton.Right:
      case MouseButton.Back:
    }
  };
  const getButtonFromPressedButtons = buttons => {
      return MouseButton.Right;
      return MouseButton.Back;
      });
      
      _classPrivateFieldInitSpec(this, _transactions, []);
      _classPrivateFieldSet(_client13, this, client);
      _classPrivateFieldSet(_keyboard, this, keyboard);
    }
    updateClient(client) {
      _classPrivateFieldSet(_client13, this, client);
    }
    async reset() {
      const actions = [];
  function _get_state(_this14) {
    return Object.assign({
      ..._classPrivateFieldGet(_state2, _this14)
    }, ..._classPrivateFieldGet(_transactions, _this14));
  }
  function _createTransaction() {
    const transaction = {};
    _classPrivateFieldGet(_transactions, this).push(transaction);
    const popTransaction = () => {
      _classPrivateFieldGet(_transactions, this).splice(_classPrivateFieldGet(_transactions, this).indexOf(transaction), 1);
    };
    return {
      update: updates => {
        Object.assign(transaction, updates);
      },
      commit: () => {
        _classPrivateFieldSet(_state2, this, {
          ..._classPrivateFieldGet(_state2, this),
          ...transaction
        });
        popTransaction();
      },
      rollback: popTransaction
    };
  }
  async function _withTransaction(action) {
    const {
      update,
      commit,
      rollback
    } = _assertClassBrand(_CdpMouse_brand, this, _createTransaction).call(this);
    try {
      await action(update);
      commit();
    } catch (error) {
      rollback();
      throw error;
    }
  }
  class CdpTouchscreen extends Touchscreen {
    constructor(client, keyboard) {
      super();
      _classPrivateFieldInitSpec(this, _client15, void 0);
      _classPrivateFieldInitSpec(this, _keyboard3, void 0);
      _classPrivateFieldSet(_client15, this, client);
      _classPrivateFieldSet(_keyboard3, this, keyboard);
    }
    updateClient(client) {
      _classPrivateFieldSet(_client15, this, client);
      this.touches.forEach(t => {
        t.updateClient(client);
      });
    }
    async touchStart(x, y) {
      const id = this.idGenerator();
      const touchPoint = {
        x: Math.round(x),
        y: Math.round(y),
        radiusX: 0.5,
        radiusY: 0.5,
        force: 0.5,
        id
      };
      const touch = new CdpTouchHandle(_classPrivateFieldGet(_client15, this), this, _classPrivateFieldGet(_keyboard3, this), touchPoint);
      await touch.start();
      this.touches.push(touch);
      return touch;
    }
  }

    constructor(client) {
      _classPrivateFieldInitSpec(this, _client16, void 0);
      _classPrivateFieldInitSpec(this, _recording, false);
      _classPrivateFieldInitSpec(this, _path, void 0);
      _classPrivateFieldSet(_client16, this, client);
    }
    updateClient(client) {
      _classPrivateFieldSet(_client16, this, client);
    }
    async start(options = {}) {
      assert(!_classPrivateFieldGet(_recording, this), 'Cannot start recording trace while already recording trace.');
      const defaultCategories = ['-*', 'devtools.timeline', 'v8.execute', 'disabled-by-default-devtools.timeline', 'disabled-by-default-devtools.timeline.frame', 'toplevel', 'blink.console', 'blink.user_timing', 'latencyInfo', 'disabled-by-default-devtools.timeline.stack', 'disabled-by-default-v8.cpu_profiler'];
      const {
        path,
        screenshots = false,
        categories = defaultCategories
      } = options;
      if (screenshots) {
        categories.push('disabled-by-default-devtools.screenshot');
      }
      const excludedCategories = categories.filter(cat => {
        return cat.startsWith('-');
      }).map(cat => {
        return cat.slice(1);
      });
      const includedCategories = categories.filter(cat => {
        return !cat.startsWith('-');
      });
      _classPrivateFieldSet(_path, this, path);
      _classPrivateFieldSet(_recording, this, true);
      await _classPrivateFieldGet(_client16, this).send('Tracing.start', {
        transferMode: 'ReturnAsStream',
        traceConfig: {
          excludedCategories,
          includedCategories
        }
      });
    }
    async stop() {
      const contentDeferred = Deferred.create();
      _classPrivateFieldGet(_client16, this).once('Tracing.tracingComplete', async event => {
        try {
          assert(event.stream, 'Missing "stream"');
          const readable = await getReadableFromProtocolStream(_classPrivateFieldGet(_client16, this), event.stream);
          const typedArray = await getReadableAsTypedArray(readable, _classPrivateFieldGet(_path, this));
          contentDeferred.resolve(typedArray ?? undefined);
        } catch (error) {
          if (isErrorLike(error)) {
            contentDeferred.reject(error);
          } else {
            contentDeferred.reject(new Error(`Unknown error: ${error}`));
          }
        }
      });
      await _classPrivateFieldGet(_client16, this).send('Tracing.end');
      _classPrivateFieldSet(_recording, this, false);
      return await contentDeferred.valueOrThrow();
    }
  }

  class CdpWebWorker extends WebWorker {
    constructor(client, url, targetId, targetType, consoleAPICalled, exceptionThrown) {
      super(url);
      _classPrivateFieldInitSpec(this, _world4, void 0);
      _classPrivateFieldInitSpec(this, _client17, void 0);
      _classPrivateFieldInitSpec(this, _id6, void 0);
      _classPrivateFieldInitSpec(this, _targetType2, void 0);
      _classPrivateFieldSet(_id6, this, targetId);
      _classPrivateFieldSet(_client17, this, client);
      _classPrivateFieldSet(_targetType2, this, targetType);
      _classPrivateFieldSet(_world4, this, new IsolatedWorld(this, new TimeoutSettings()));
      _classPrivateFieldGet(_client17, this).once('Runtime.executionContextCreated', async event => {
        _classPrivateFieldGet(_world4, this).setContext(new ExecutionContext(client, event.context, _classPrivateFieldGet(_world4, this)));
      });
      _classPrivateFieldGet(_world4, this).emitter.on('consoleapicalled', async event => {
        try {
          return consoleAPICalled(event.type, event.args.map(object => {
            return new CdpJSHandle(_classPrivateFieldGet(_world4, this), object);
          }), event.stackTrace);
        } catch (err) {
          debugError(err);
        }
      });
      _classPrivateFieldGet(_client17, this).on('Runtime.exceptionThrown', exceptionThrown);
      _classPrivateFieldGet(_client17, this).once(exports.CDPSessionEvent.Disconnected, () => {
        _classPrivateFieldGet(_world4, this).dispose();
      });
      
      _classPrivateFieldGet(_client17, this).send('Runtime.enable').catch(debugError);
    }
    mainRealm() {
      return _classPrivateFieldGet(_world4, this);
    }
    get client() {
      return _classPrivateFieldGet(_client17, this);
    }
    async close() {
      switch (_classPrivateFieldGet(_targetType2, this)) {
        case exports.TargetType.SERVICE_WORKER:
        case exports.TargetType.SHARED_WORKER:
          {
            
            
            await this.client.connection()?.send('Target.closeTarget', {
              targetId: _classPrivateFieldGet(_id6, this)
            });
            await this.client.connection()?.send('Target.detachFromTarget', {
              sessionId: this.client.id()
            });
            break;
          }
        default:
          await this.evaluate(() => {
            self.close();
          });
      }
    }
  }

  var __addDisposableResource$1 = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources$1 = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  function convertConsoleMessageLevel(method) {
    switch (method) {
      case 'warning':
        return 'warn';
      default:
        return method;
    }
  }
  class CdpPage extends Page {
    static async _create(client, target, defaultViewport) {
      const page = new CdpPage(client, target);
      await _assertClassBrand(_CdpPage_brand, page, _initialize).call(page);
      if (defaultViewport) {
        try {
          await page.setViewport(defaultViewport);
        } catch (err) {
          if (isErrorLike(err) && isTargetClosedError(err)) {
            debugError(err);
          } else {
            throw err;
          }
        }
      }
      return page;
    }
    constructor(client, _target2) {
      super();
      _classPrivateMethodInitSpec(this, _CdpPage_brand);
      _classPrivateFieldInitSpec(this, _closed2, false);
      _classPrivateFieldInitSpec(this, _targetManager, void 0);
      _classPrivateFieldInitSpec(this, _primaryTargetClient, void 0);
      _classPrivateFieldInitSpec(this, _primaryTarget, void 0);
      _classPrivateFieldInitSpec(this, _tabTargetClient, void 0);
      _classPrivateFieldInitSpec(this, _tabTarget, void 0);
      _classPrivateFieldInitSpec(this, _keyboard4, void 0);
      _classPrivateFieldInitSpec(this, _mouse, void 0);
      _classPrivateFieldInitSpec(this, _touchscreen, void 0);
      _classPrivateFieldInitSpec(this, _frameManager2, void 0);
      _classPrivateFieldInitSpec(this, _emulationManager, void 0);
      _classPrivateFieldInitSpec(this, _tracing, void 0);
      _classPrivateFieldInitSpec(this, _bindings3, new Map());
      _classPrivateFieldInitSpec(this, _exposedFunctions, new Map());
      _classPrivateFieldInitSpec(this, _coverage, void 0);
      _classPrivateFieldInitSpec(this, _viewport, void 0);
      _classPrivateFieldInitSpec(this, _workers, new Map());
      _classPrivateFieldInitSpec(this, _fileChooserDeferreds, new Set());
      _classPrivateFieldInitSpec(this, _sessionCloseDeferred, Deferred.create());
      _classPrivateFieldInitSpec(this, _serviceWorkerBypassed, false);
      _classPrivateFieldInitSpec(this, _userDragInterceptionEnabled, false);
      _classPrivateFieldInitSpec(this, _onDetachedFromTarget, target => {
        const sessionId = target._session()?.id();
        const worker = _classPrivateFieldGet(_workers, this).get(sessionId);
        if (!worker) {
          return;
        }
        _classPrivateFieldGet(_workers, this).delete(sessionId);
        }
        session.on(exports.CDPSessionEvent.Ready, _classPrivateFieldGet(_onAttachedToTarget, this));
      });
      _classPrivateFieldSet(_primaryTargetClient, this, client);
      _classPrivateFieldSet(_tabTargetClient, this, client.parentSession());
      assert(_classPrivateFieldGet(_tabTargetClient, this), 'Tab target session is not defined.');
      _classPrivateFieldSet(_tabTarget, this, _classPrivateFieldGet(_tabTargetClient, this).target());
      assert(_classPrivateFieldGet(_tabTarget, this), 'Tab target is not defined.');
      _classPrivateFieldSet(_primaryTarget, this, _target2);
      _classPrivateFieldSet(_targetManager, this, _target2._targetManager());
      _classPrivateFieldSet(_keyboard4, this, new CdpKeyboard(client));
      _classPrivateFieldSet(_mouse, this, new CdpMouse(client, _classPrivateFieldGet(_keyboard4, this)));
      _classPrivateFieldSet(_touchscreen, this, new CdpTouchscreen(client, _classPrivateFieldGet(_keyboard4, this)));
      _classPrivateFieldSet(_frameManager2, this, new FrameManager(client, this, this._timeoutSettings));
      _classPrivateFieldSet(_emulationManager, this, new EmulationManager(client));
      _classPrivateFieldSet(_tracing, this, new Tracing(client));
      _classPrivateFieldSet(_coverage, this, new Coverage(client));
      _classPrivateFieldSet(_viewport, this, null);
      const frameManagerEmitter = new EventEmitter(_classPrivateFieldGet(_frameManager2, this));
      frameManagerEmitter.on(exports.FrameManagerEvent.FrameAttached, frame => {
      });
      frameManagerEmitter.on(exports.FrameManagerEvent.FrameNavigated, frame => {
      });
      networkManagerEmitter.on(exports.NetworkManagerEvent.RequestServedFromCache, request => {
      });
      networkManagerEmitter.on(exports.NetworkManagerEvent.RequestFailed, request => {
      });
      _classPrivateFieldGet(_tabTargetClient, this).on(exports.CDPSessionEvent.Swapped, _assertClassBrand(_CdpPage_brand, this, _onActivation).bind(this));
      _classPrivateFieldGet(_tabTargetClient, this).on(exports.CDPSessionEvent.Ready, _assertClassBrand(_CdpPage_brand, this, _onSecondaryTarget).bind(this));
    async waitForDevicePrompt(options = {}) {
      return await this.mainFrame().waitForDevicePrompt(options);
    }
  }
  function _attachExistingTargets() {
    const queue = [];
    for (const childTarget of _classPrivateFieldGet(_targetManager, this).getChildTargets(_classPrivateFieldGet(_primaryTarget, this))) {
      queue.push(childTarget);
    }
    let idx = 0;
    while (idx < queue.length) {
      const next = queue[idx];
      idx++;
      const session = next._session();
      if (session) {
        _classPrivateFieldGet(_onAttachedToTarget, this).call(this, session);
      }
      for (const childTarget of _classPrivateFieldGet(_targetManager, this).getChildTargets(next)) {
        queue.push(childTarget);
      }
    }
  }
  async function _onActivation(newSession) {
    
    assert(newSession instanceof CdpCDPSession, 'CDPSession is not instance of CdpCDPSession');
    _classPrivateFieldSet(_primaryTargetClient, this, newSession);
    _classPrivateFieldSet(_primaryTarget, this, newSession.target());
    assert(_classPrivateFieldGet(_primaryTarget, this), 'Missing target on swap');
    _classPrivateFieldGet(_keyboard4, this).updateClient(newSession);
    _classPrivateFieldGet(_mouse, this).updateClient(newSession);
    _classPrivateFieldGet(_touchscreen, this).updateClient(newSession);
    _classPrivateFieldGet(_emulationManager, this).updateClient(newSession);
    _classPrivateFieldGet(_tracing, this).updateClient(newSession);
    _classPrivateFieldGet(_coverage, this).updateClient(newSession);
    await _classPrivateFieldGet(_frameManager2, this).swapFrameTree(newSession);
    _assertClassBrand(_CdpPage_brand, this, _setupPrimaryTargetListeners).call(this);
  }
  async function _onSecondaryTarget(session) {
    assert(session instanceof CdpCDPSession);
    if (session.target()._subtype() !== 'prerender') {
      return;
    }
    _classPrivateFieldGet(_frameManager2, this).registerSpeculativeSession(session).catch(debugError);
    _classPrivateFieldGet(_emulationManager, this).registerSpeculativeSession(session).catch(debugError);
  }
  function _setupPrimaryTargetListeners() {
    const clientEmitter = new EventEmitter(_classPrivateFieldGet(_primaryTargetClient, this));
    clientEmitter.on(exports.CDPSessionEvent.Ready, _classPrivateFieldGet(_onAttachedToTarget, this));
    clientEmitter.on(exports.CDPSessionEvent.Disconnected, () => {
      _classPrivateFieldGet(_sessionCloseDeferred, this).reject(new TargetCloseError('Target closed'));
    });
    clientEmitter.on('Page.domContentEventFired', () => {
    });
    clientEmitter.on('Page.javascriptDialogOpening', _assertClassBrand(_CdpPage_brand, this, _onDialog).bind(this));
    clientEmitter.on('Runtime.exceptionThrown', _assertClassBrand(_CdpPage_brand, this, _handleException).bind(this));
    clientEmitter.on('Inspector.targetCrashed', _assertClassBrand(_CdpPage_brand, this, _onTargetCrashed).bind(this));
    clientEmitter.on('Performance.metrics', _assertClassBrand(_CdpPage_brand, this, _emitMetrics).bind(this));
    clientEmitter.on('Log.entryAdded', _assertClassBrand(_CdpPage_brand, this, _onLogEntryAdded).bind(this));
    clientEmitter.on('Page.fileChooserOpened', _assertClassBrand(_CdpPage_brand, this, _onFileChooser).bind(this));
  }
  async function _initialize() {
    try {
      await Promise.all([_classPrivateFieldGet(_frameManager2, this).initialize(_classPrivateFieldGet(_primaryTargetClient, this)), _classPrivateFieldGet(_primaryTargetClient, this).send('Performance.enable'), _classPrivateFieldGet(_primaryTargetClient, this).send('Log.enable')]);
    } catch (err) {
      if (isErrorLike(err) && isTargetClosedError(err)) {
        debugError(err);
      } else {
        throw err;
      }
    }
  }
  async function _onFileChooser(event) {
    const env_1 = {
      stack: [],
      error: void 0,
      hasError: false
    };
    try {
      if (!_classPrivateFieldGet(_fileChooserDeferreds, this).size) {
        return;
      }
      const frame = _classPrivateFieldGet(_frameManager2, this).frame(event.frameId);
      assert(frame, 'This should never happen.');
      
      const handle = __addDisposableResource$1(env_1, await frame.worlds[MAIN_WORLD].adoptBackendNode(event.backendNodeId), false);
      const fileChooser = new FileChooser(handle.move(), event);
      for (const promise of _classPrivateFieldGet(_fileChooserDeferreds, this)) {
        promise.resolve(fileChooser);
      }
      _classPrivateFieldGet(_fileChooserDeferreds, this).clear();
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources$1(env_1);
    }
  }
  function _onTargetCrashed() {
        url,
        lineNumber
      }]));
    }
  }
  function _emitMetrics(event) {
  }
  function _onConsoleAPI2(world, event) {
    const values = event.args.map(arg => {
      return world.createCdpHandle(arg);
    });
    _assertClassBrand(_CdpPage_brand, this, _addConsoleMessage).call(this, convertConsoleMessageLevel(event.type), values, event.stackTrace);
  }
  async function _onBindingCalled2(world, event) {
    let payload;
    try {
      payload = JSON.parse(event.payload);
    } catch {
      
      
      return;
    }
    const {
      type,
      name,
      seq,
      args,
      isTrivial
    } = payload;
    if (type !== 'exposedFun') {
      return;
    }
    const context = world.context;
    if (!context) {
      return;
    }
    const binding = _classPrivateFieldGet(_bindings3, this).get(name);
    await binding?.run(context, seq, args, isTrivial);
  }
  function _addConsoleMessage(eventType, args, stackTrace) {
  }
  function _onDialog(event) {
    const type = validateDialogType(event.type);
    const dialog = new CdpDialog(_classPrivateFieldGet(_primaryTargetClient, this), type, event.message, event.defaultPrompt);
  function getIntersectionRect(clip, viewport) {
    
    const x = Math.max(clip.x, viewport.x);
    const y = Math.max(clip.y, viewport.y);
    return {
      x,
      y,
      width: Math.max(Math.min(clip.x + clip.width, viewport.x + viewport.width) - x, 0),
      height: Math.max(Math.min(clip.y + clip.height, viewport.y + viewport.height) - y, 0)
    };
  }
  function convertCookiesPartitionKeyFromPuppeteerToCdp(partitionKey) {
    if (partitionKey === undefined) {
      return undefined;
    }
    if (typeof partitionKey === 'string') {
      return {
        topLevelSite: partitionKey,
        hasCrossSiteAncestor: false
      };
    }
    return {
      topLevelSite: partitionKey.sourceOrigin,
      hasCrossSiteAncestor: partitionKey.hasCrossSiteAncestor ?? false
    };
  }

  var __addDisposableResource = undefined && undefined.__addDisposableResource || function (env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function () {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({
        value: value,
        dispose: dispose,
        async: async
      });
    } else if (async) {
      env.stack.push({
        async: true
      });
    }
    return value;
  };
  var __disposeResources = undefined && undefined.__disposeResources || function (SuppressedError) {
    return function (env) {
      function fail(e) {
        env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r,
        s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
                fail(e);
                return next();
              });
            } else s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  });
  exports.InitializationStatus = void 0;
  (function (InitializationStatus) {
    InitializationStatus["SUCCESS"] = "success";
    InitializationStatus["ABORTED"] = "aborted";
  })(exports.InitializationStatus || (exports.InitializationStatus = {}));
  class CdpTarget extends Target {
    constructor(targetInfo, session, browserContext, targetManager, sessionFactory) {
      super();
      _classPrivateFieldInitSpec(this, _browserContext, void 0);
      _classPrivateFieldInitSpec(this, _session, void 0);
      _classPrivateFieldInitSpec(this, _targetInfo, void 0);
      _classPrivateFieldInitSpec(this, _targetManager2, void 0);
      _classPrivateFieldInitSpec(this, _sessionFactory, void 0);
      _classPrivateFieldInitSpec(this, _childTargets, new Set());
      _defineProperty(this, "_initializedDeferred", Deferred.create());
      _defineProperty(this, "_isClosedDeferred", Deferred.create());
      _defineProperty(this, "_targetId", void 0);
      _classPrivateFieldSet(_session, this, session);
      _classPrivateFieldSet(_targetManager2, this, targetManager);
      _classPrivateFieldSet(_targetInfo, this, targetInfo);
      _classPrivateFieldSet(_browserContext, this, browserContext);
      this._targetId = targetInfo.targetId;
      _classPrivateFieldSet(_sessionFactory, this, sessionFactory);
      if (_classPrivateFieldGet(_session, this)) {
        _classPrivateFieldGet(_session, this).setTarget(this);
      }
    }
    async asPage() {
      const session = this._session();
      if (!session) {
        return await this.createCDPSession().then(client => {
          return CdpPage._create(client, this, null);
        });
      }
      return await CdpPage._create(session, this, null);
    }
    _subtype() {
      return _classPrivateFieldGet(_targetInfo, this).subtype;
    }
    _session() {
      return _classPrivateFieldGet(_session, this);
    }
    _addChildTarget(target) {
      _classPrivateFieldGet(_childTargets, this).add(target);
    }
    _removeChildTarget(target) {
      _classPrivateFieldGet(_childTargets, this).delete(target);
    }
    _childTargets() {
      return _classPrivateFieldGet(_childTargets, this);
    }
    _sessionFactory() {
      if (!_classPrivateFieldGet(_sessionFactory, this)) {
        throw new Error('sessionFactory is not initialized');
      }
      return _classPrivateFieldGet(_sessionFactory, this);
    }
    createCDPSession() {
      if (!_classPrivateFieldGet(_sessionFactory, this)) {
        throw new Error('sessionFactory is not initialized');
      }
      return _classPrivateFieldGet(_sessionFactory, this).call(this, false).then(session => {
        session.setTarget(this);
        return session;
      });
    }
    url() {
      return _classPrivateFieldGet(_targetInfo, this).url;
    }
    type() {
      const type = _classPrivateFieldGet(_targetInfo, this).type;
      switch (type) {
        case 'page':
          return exports.TargetType.PAGE;
        case 'background_page':
          return exports.TargetType.BACKGROUND_PAGE;
        case 'service_worker':
          return exports.TargetType.SERVICE_WORKER;
        case 'shared_worker':
          return exports.TargetType.SHARED_WORKER;
        case 'browser':
          return exports.TargetType.BROWSER;
        case 'webview':
          return exports.TargetType.WEBVIEW;
        case 'tab':
          return exports.TargetType.TAB;
        default:
          return exports.TargetType.OTHER;
      }
    }
    _targetManager() {
      if (!_classPrivateFieldGet(_targetManager2, this)) {
        throw new Error('targetManager is not initialized');
      }
      return _classPrivateFieldGet(_targetManager2, this);
    }
    _getTargetInfo() {
      return _classPrivateFieldGet(_targetInfo, this);
    }
    browser() {
      if (!_classPrivateFieldGet(_browserContext, this)) {
        throw new Error('browserContext is not initialized');
      }
      return _classPrivateFieldGet(_browserContext, this).browser();
    }
    browserContext() {
      if (!_classPrivateFieldGet(_browserContext, this)) {
        throw new Error('browserContext is not initialized');
      }
      return _classPrivateFieldGet(_browserContext, this);
    }
    opener() {
      const {
        openerId
      } = _classPrivateFieldGet(_targetInfo, this);
      if (!openerId) {
        return;
      }
      return this.browser().targets().find(target => {
        return target._targetId === openerId;
      });
    }
    _targetInfoChanged(targetInfo) {
      _classPrivateFieldSet(_targetInfo, this, targetInfo);
      this._checkIfInitialized();
    }
    _initialize() {
      this._initializedDeferred.resolve(exports.InitializationStatus.SUCCESS);
    }
    _isTargetExposed() {
      return this.type() !== exports.TargetType.TAB && !this._subtype();
    }
    _checkIfInitialized() {
      if (!this._initializedDeferred.resolved()) {
        this._initializedDeferred.resolve(exports.InitializationStatus.SUCCESS);
      }
    }
  }
          return true;
        }
        const popupPage = await this.page();
          return CdpPage._create(client, this, _classPrivateFieldGet(_defaultViewport, this) ?? null);
        });
      }
      return (await this.pagePromise) ?? null;
    }
    _checkIfInitialized() {
      if (this._initializedDeferred.resolved()) {
        return;
      }
      if (this._getTargetInfo().url !== '') {
        this._initializedDeferred.resolve(exports.InitializationStatus.SUCCESS);
      }
    }
  }
  class DevToolsTarget extends PageTarget {}
  class OtherTarget extends CdpTarget {}

  function isPageTargetBecomingPrimary(target, newTargetInfo) {
    return Boolean(target._subtype()) && !newTargetInfo.subtype;
  }
      _classPrivateFieldInitSpec(this, _discoveredTargetsByTargetId, new Map());
      _classPrivateFieldInitSpec(this, _attachedTargetsByTargetId, new Map());
      _classPrivateFieldInitSpec(this, _attachedTargetsBySessionId, new Map());
      _classPrivateFieldInitSpec(this, _ignoredTargets, new Set());
      _classPrivateFieldInitSpec(this, _targetFilterCallback, void 0);
      _classPrivateFieldInitSpec(this, _targetFactory, void 0);
      _classPrivateFieldInitSpec(this, _attachedToTargetListenersBySession, new WeakMap());
      _classPrivateFieldInitSpec(this, _detachedFromTargetListenersBySession, new WeakMap());
      _classPrivateFieldInitSpec(this, _initializeDeferred, Deferred.create());
      _classPrivateFieldInitSpec(this, _targetsIdsForInit, new Set());
      _classPrivateFieldInitSpec(this, _waitForInitiallyDiscoveredTargets, true);
      _classPrivateFieldInitSpec(this, _discoveryFilter, [{}]);
      _classPrivateFieldInitSpec(this, _storeExistingTargetsForInit, () => {
        if (!_classPrivateFieldGet(_waitForInitiallyDiscoveredTargets, this)) {
          return;
        }
        for (const [targetId, targetInfo] of _classPrivateFieldGet(_discoveredTargetsByTargetId, this).entries()) {
          const targetForFilter = new CdpTarget(targetInfo, undefined, undefined, this, undefined);
          
          
          const isPageOrFrame = targetInfo.type === 'page' || targetInfo.type === 'iframe';
          const isExtension = targetInfo.url.startsWith('chrome-extension:
          if ((!_classPrivateFieldGet(_targetFilterCallback, this) || _classPrivateFieldGet(_targetFilterCallback, this).call(this, targetForFilter)) && isPageOrFrame && !isExtension) {
            _classPrivateFieldGet(_targetsIdsForInit, this).add(targetId);
          }
        }
      });
      _classPrivateFieldInitSpec(this, _onSessionDetached, session => {
        _assertClassBrand(_TargetManager_brand, this, _removeAttachmentListeners).call(this, session);
      });
      _classPrivateFieldInitSpec(this, _onTargetCreated, async event => {
        _classPrivateFieldGet(_discoveredTargetsByTargetId, this).set(event.targetInfo.targetId, event.targetInfo);
            _classPrivateFieldGet(_attachedTargetsByTargetId, this).delete(event.targetId);
          }
        }
      });
      _classPrivateFieldInitSpec(this, _onTargetInfoChanged, event => {
        _classPrivateFieldGet(_discoveredTargetsByTargetId, this).set(event.targetInfo.targetId, event.targetInfo);
        if (_classPrivateFieldGet(_ignoredTargets, this).has(event.targetInfo.targetId) || !_classPrivateFieldGet(_attachedTargetsByTargetId, this).has(event.targetInfo.targetId) || !event.targetInfo.attached) {
          return;
        }
        const target = _classPrivateFieldGet(_attachedTargetsByTargetId, this).get(event.targetInfo.targetId);
        if (!target) {
          return;
        }
        const previousURL = target.url();
        const wasInitialized = target._initializedDeferred.value() === exports.InitializationStatus.SUCCESS;
        if (isPageTargetBecomingPrimary(target, event.targetInfo)) {
          const session = target?._session();
          assert(session, 'Target that is being activated is missing a CDPSession.');
          session.parentSession()?.emit(exports.CDPSessionEvent.Swapped, session);
        }
        target._targetInfoChanged(event.targetInfo);
        if (wasInitialized && previousURL !== target.url()) {
          return;
        }
        const isExistingTarget = _classPrivateFieldGet(_attachedTargetsByTargetId, this).has(targetInfo.targetId);
        const target = isExistingTarget ? _classPrivateFieldGet(_attachedTargetsByTargetId, this).get(targetInfo.targetId) : _classPrivateFieldGet(_targetFactory, this).call(this, targetInfo, session, parentSession instanceof CdpCDPSession ? parentSession : undefined);
        if (_classPrivateFieldGet(_targetFilterCallback, this) && !_classPrivateFieldGet(_targetFilterCallback, this).call(this, target)) {
          _classPrivateFieldGet(_ignoredTargets, this).add(targetInfo.targetId);
          _assertClassBrand(_TargetManager_brand, this, _finishInitializationIfReady).call(this, targetInfo.targetId);
          await silentDetach();
          return;
        }
        _assertClassBrand(_TargetManager_brand, this, _setupAttachmentListeners).call(this, session);
        if (isExistingTarget) {
          session.setTarget(target);
          _classPrivateFieldGet(_attachedTargetsBySessionId, this).set(session.id(), _classPrivateFieldGet(_attachedTargetsByTargetId, this).get(targetInfo.targetId));
        } else {
          target._initialize();
          _classPrivateFieldGet(_attachedTargetsByTargetId, this).set(targetInfo.targetId, target);
          _classPrivateFieldGet(_attachedTargetsBySessionId, this).set(session.id(), target);
        }
        const parentTarget = parentSession instanceof CDPSession ? parentSession.target() : null;
        parentTarget?._addChildTarget(target);
        parentSession.emit(exports.CDPSessionEvent.Ready, session);
        _classPrivateFieldGet(_targetsIdsForInit, this).delete(target._targetId);
        if (!isExistingTarget) {
      });
      _classPrivateFieldSet(_connection3, this, connection);
      _classPrivateFieldSet(_targetFilterCallback, this, targetFilterCallback);
      _classPrivateFieldSet(_targetFactory, this, targetFactory);
      _classPrivateFieldSet(_waitForInitiallyDiscoveredTargets, this, waitForInitiallyDiscoveredTargets);
      _classPrivateFieldGet(_connection3, this).on('Target.targetCreated', _classPrivateFieldGet(_onTargetCreated, this));
      _classPrivateFieldGet(_connection3, this).on('Target.targetDestroyed', _classPrivateFieldGet(_onTargetDestroyed, this));
      _classPrivateFieldGet(_connection3, this).on('Target.targetInfoChanged', _classPrivateFieldGet(_onTargetInfoChanged, this));
      _classPrivateFieldGet(_connection3, this).on(exports.CDPSessionEvent.SessionDetached, _classPrivateFieldGet(_onSessionDetached, this));
      _assertClassBrand(_TargetManager_brand, this, _setupAttachmentListeners).call(this, _classPrivateFieldGet(_connection3, this));
    }
    async initialize() {
      await _classPrivateFieldGet(_connection3, this).send('Target.setDiscoverTargets', {
        discover: true,
        filter: _classPrivateFieldGet(_discoveryFilter, this)
      });
      _classPrivateFieldGet(_storeExistingTargetsForInit, this).call(this);
      await _classPrivateFieldGet(_connection3, this).send('Target.setAutoAttach', {
        waitForDebuggerOnStart: true,
        flatten: true,
        autoAttach: true,
        filter: [{
          type: 'page',
          exclude: true
        }, ..._classPrivateFieldGet(_discoveryFilter, this)]
      });
      _assertClassBrand(_TargetManager_brand, this, _finishInitializationIfReady).call(this);
      await _classPrivateFieldGet(_initializeDeferred, this).valueOrThrow();
    }
    getChildTargets(target) {
      return target._childTargets();
    }
    dispose() {
      _classPrivateFieldGet(_connection3, this).off('Target.targetCreated', _classPrivateFieldGet(_onTargetCreated, this));
      _classPrivateFieldGet(_connection3, this).off('Target.targetDestroyed', _classPrivateFieldGet(_onTargetDestroyed, this));
      _classPrivateFieldGet(_connection3, this).off('Target.targetInfoChanged', _classPrivateFieldGet(_onTargetInfoChanged, this));
      _classPrivateFieldGet(_connection3, this).off(exports.CDPSessionEvent.SessionDetached, _classPrivateFieldGet(_onSessionDetached, this));
      _assertClassBrand(_TargetManager_brand, this, _removeAttachmentListeners).call(this, _classPrivateFieldGet(_connection3, this));
    }
    getAvailableTargets() {
      return _classPrivateFieldGet(_attachedTargetsByTargetId, this);
    }
  }

  function _setupAttachmentListeners(session) {
    const listener = event => {
      void _classPrivateFieldGet(_onAttachedToTarget2, this).call(this, session, event);
    };
    assert(!_classPrivateFieldGet(_attachedToTargetListenersBySession, this).has(session));
    _classPrivateFieldGet(_attachedToTargetListenersBySession, this).set(session, listener);
    session.on('Target.attachedToTarget', listener);
    const detachedListener = event => {
      return _classPrivateFieldGet(_onDetachedFromTarget2, this).call(this, session, event);
    };
    assert(!_classPrivateFieldGet(_detachedFromTargetListenersBySession, this).has(session));
    _classPrivateFieldGet(_detachedFromTargetListenersBySession, this).set(session, detachedListener);
    session.on('Target.detachedFromTarget', detachedListener);
  }
  function _removeAttachmentListeners(session) {
    const listener = _classPrivateFieldGet(_attachedToTargetListenersBySession, this).get(session);
    if (listener) {
      session.off('Target.attachedToTarget', listener);
      _classPrivateFieldGet(_attachedToTargetListenersBySession, this).delete(session);
    }
    if (_classPrivateFieldGet(_detachedFromTargetListenersBySession, this).has(session)) {
      session.off('Target.detachedFromTarget', _classPrivateFieldGet(_detachedFromTargetListenersBySession, this).get(session));
      _classPrivateFieldGet(_detachedFromTargetListenersBySession, this).delete(session);
    }
  }
  function _finishInitializationIfReady(targetId) {
    if (targetId !== undefined) {
      _classPrivateFieldGet(_targetsIdsForInit, this).delete(targetId);
    }
    if (_classPrivateFieldGet(_targetsIdsForInit, this).size === 0) {
      _classPrivateFieldGet(_initializeDeferred, this).resolve();
    }
  }
  class CdpBrowser extends Browser {
    static async _create(connection, contextIds, acceptInsecureCerts, defaultViewport, downloadBehavior, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
      const browser = new CdpBrowser(connection, contextIds, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets);
      if (acceptInsecureCerts) {
        await connection.send('Security.setIgnoreCertificateErrors', {
          ignore: true
        });
      }
      await browser._attach(downloadBehavior);
      return browser;
    }
    constructor(connection, contextIds, defaultViewport, process, closeCallback, targetFilterCallback, _isPageTargetCallback2, waitForInitiallyDiscoveredTargets = true) {
      super();
      _classPrivateMethodInitSpec(this, _CdpBrowser_brand);
      _defineProperty(this, "protocol", 'cdp');
      _classPrivateFieldInitSpec(this, _defaultViewport2, void 0);
      _classPrivateFieldInitSpec(this, _process, void 0);
      _classPrivateFieldInitSpec(this, _connection4, void 0);
      _classPrivateFieldInitSpec(this, _closeCallback, void 0);
      _classPrivateFieldInitSpec(this, _targetFilterCallback2, void 0);
      _classPrivateFieldInitSpec(this, _isPageTargetCallback, void 0);
      _classPrivateFieldInitSpec(this, _defaultContext, void 0);
      _classPrivateFieldInitSpec(this, _contexts, new Map());
      _classPrivateFieldInitSpec(this, _targetManager3, void 0);
      _classPrivateFieldInitSpec(this, _emitDisconnected, () => {
      });
      _classPrivateFieldSet(_defaultViewport2, this, defaultViewport);
      _classPrivateFieldSet(_process, this, process);
      _classPrivateFieldSet(_connection4, this, connection);
      _classPrivateFieldSet(_closeCallback, this, closeCallback || (() => {}));
      _classPrivateFieldSet(_targetFilterCallback2, this, targetFilterCallback || (() => {
        return true;
      }));
      _assertClassBrand(_CdpBrowser_brand, this, _setIsPageTargetCallback).call(this, _isPageTargetCallback2);
      _classPrivateFieldSet(_targetManager3, this, new TargetManager(connection, _classPrivateFieldGet(_createTarget, this), _classPrivateFieldGet(_targetFilterCallback2, this), waitForInitiallyDiscoveredTargets));
      _classPrivateFieldSet(_defaultContext, this, new CdpBrowserContext(_classPrivateFieldGet(_connection4, this), this));
      for (const contextId of contextIds) {
        _classPrivateFieldGet(_contexts, this).set(contextId, new CdpBrowserContext(_classPrivateFieldGet(_connection4, this), this, contextId));
      }
    }
    async _attach(downloadBehavior) {
      _classPrivateFieldGet(_connection4, this).on(exports.CDPSessionEvent.Disconnected, _classPrivateFieldGet(_emitDisconnected, this));
      if (downloadBehavior) {
        await _classPrivateFieldGet(_defaultContext, this).setDownloadBehavior(downloadBehavior);
      }
      await _classPrivateFieldGet(_targetManager3, this).initialize();
    }
    _detach() {
      _classPrivateFieldGet(_connection4, this).off(exports.CDPSessionEvent.Disconnected, _classPrivateFieldGet(_emitDisconnected, this));
    }
    process() {
      return _classPrivateFieldGet(_process, this) ?? null;
    }
    _targetManager() {
      return _classPrivateFieldGet(_targetManager3, this);
    }
    _getIsPageTargetCallback() {
      return _classPrivateFieldGet(_isPageTargetCallback, this);
    }
    async createBrowserContext(options = {}) {
      const {
        proxyServer,
        proxyBypassList,
        downloadBehavior
      } = options;
      const {
        browserContextId
      } = await _classPrivateFieldGet(_connection4, this).send('Target.createBrowserContext', {
        proxyServer,
        proxyBypassList: proxyBypassList && proxyBypassList.join(',')
      });
      const context = new CdpBrowserContext(_classPrivateFieldGet(_connection4, this), this, browserContextId);
      if (downloadBehavior) {
        await context.setDownloadBehavior(downloadBehavior);
      }
      _classPrivateFieldGet(_contexts, this).set(browserContextId, context);
      return context;
    }
    browserContexts() {
      return [_classPrivateFieldGet(_defaultContext, this), ...Array.from(_classPrivateFieldGet(_contexts, this).values())];
    }
    defaultBrowserContext() {
      return _classPrivateFieldGet(_defaultContext, this);
    }
    async _disposeContext(contextId) {
      if (!contextId) {
        return;
      }
      await _classPrivateFieldGet(_connection4, this).send('Target.disposeBrowserContext', {
        browserContextId: contextId
      });
      _classPrivateFieldGet(_contexts, this).delete(contextId);
    }
    wsEndpoint() {
      return _classPrivateFieldGet(_connection4, this).url();
    }
    async newPage() {
      return await _classPrivateFieldGet(_defaultContext, this).newPage();
    }
    async _createPageInContext(contextId) {
      const {
        targetId
      } = await _classPrivateFieldGet(_connection4, this).send('Target.createTarget', {
        url: 'about:blank',
        browserContextId: contextId || undefined
      });
      const target = await this.waitForTarget(t => {
        return t._targetId === targetId;
      });
      if (!target) {
        throw new Error(`Missing target for page (id = ${targetId})`);
      }
      const initialized = (await target._initializedDeferred.valueOrThrow()) === exports.InitializationStatus.SUCCESS;
      if (!initialized) {
        throw new Error(`Failed to create target for page (id = ${targetId})`);
      }
      const page = await target.page();
      if (!page) {
        throw new Error(`Failed to create a page for context (id = ${contextId})`);
      }
      return page;
    }
    targets() {
      return Array.from(_classPrivateFieldGet(_targetManager3, this).getAvailableTargets().values()).filter(target => {
        return target._isTargetExposed() && target._initializedDeferred.value() === exports.InitializationStatus.SUCCESS;
      });
    }
    target() {
      const browserTarget = this.targets().find(target => {
        return target.type() === 'browser';
      });
      if (!browserTarget) {
        throw new Error('Browser target is not found');
      }
      return browserTarget;
    }
    async version() {
      const version = await _assertClassBrand(_CdpBrowser_brand, this, _getVersion).call(this);
      return version.product;
    }
    async userAgent() {
      const version = await _assertClassBrand(_CdpBrowser_brand, this, _getVersion).call(this);
      return version.userAgent;
    }
    async close() {
      await _classPrivateFieldGet(_closeCallback, this).call(null);
      await this.disconnect();
    }
    disconnect() {
      _classPrivateFieldGet(_targetManager3, this).dispose();
      _classPrivateFieldGet(_connection4, this).dispose();
      this._detach();
      return Promise.resolve();
    }
    get connected() {
      return !_classPrivateFieldGet(_connection4, this)._closed;
    }
    get debugInfo() {
      return {
        pendingProtocolErrors: _classPrivateFieldGet(_connection4, this).getPendingProtocolErrors()
      };
    }
  }

  function _setIsPageTargetCallback(isPageTargetCallback) {
    _classPrivateFieldSet(_isPageTargetCallback, this, isPageTargetCallback || (target => {
      return target.type() === 'page' || target.type() === 'background_page' || target.type() === 'webview';
    }));
  }
  function _getVersion() {
    return _classPrivateFieldGet(_connection4, this).send('Browser.getVersion');
  }
  async function _connectToCdpBrowser(connectionTransport, url, options) {
    const {
      acceptInsecureCerts = false,
      defaultViewport = DEFAULT_VIEWPORT,
      downloadBehavior,
      targetFilter,
      _isPageTarget: isPageTarget,
      slowMo = 0,
      protocolTimeout
    } = options;
    const connection = new Connection(url, connectionTransport, slowMo, protocolTimeout);
    const {
      browserContextIds
    } = await connection.send('Target.getBrowserContexts');
    const browser = await CdpBrowser._create(connection, browserContextIds, acceptInsecureCerts, defaultViewport, downloadBehavior, undefined, () => {
      return connection.send('Browser.close').catch(debugError);
    }, targetFilter, isPageTarget);
    return browser;
  }
  const tabTargetInfo = {
    targetId: 'tabTargetId',
    type: 'tab',
    title: 'tab',
    url: 'about:blank',
    attached: false,
    canAccessOpener: false
  };
  const pageTargetInfo = {
    targetId: 'pageTargetId',
    type: 'page',
    title: 'page',
    url: 'about:blank',
    attached: false,
    canAccessOpener: false
  };
    constructor(tabId) {
      _classPrivateMethodInitSpec(this, _ExtensionTransport_brand);
      _defineProperty(this, "onmessage", void 0);
      _defineProperty(this, "onclose", void 0);
      _classPrivateFieldInitSpec(this, _tabId, void 0);
      _classPrivateFieldInitSpec(this, _debuggerEventHandler, (source, method, params) => {
        if (source.tabId !== _classPrivateFieldGet(_tabId, this)) {
          return;
        }
        _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
          
          sessionId: source.sessionId ?? 'pageTargetSessionId',
          method: method,
          params: params
        });
      });
      _classPrivateFieldSet(_tabId, this, tabId);
      chrome.debugger.onEvent.addListener(_classPrivateFieldGet(_debuggerEventHandler, this));
    }
    send(message) {
      const parsed = JSON.parse(message);
      switch (parsed.method) {
        case 'Browser.getVersion':
          {
            _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
              id: parsed.id,
              sessionId: parsed.sessionId,
              method: parsed.method,
              result: {
                protocolVersion: '1.3',
                product: 'chrome',
                revision: 'unknown',
                userAgent: 'chrome',
                jsVersion: 'unknown'
              }
            });
            return;
          }
        case 'Target.getBrowserContexts':
          {
            _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
              id: parsed.id,
              sessionId: parsed.sessionId,
              method: parsed.method,
              result: {
                browserContextIds: []
              }
            });
            return;
          }
        case 'Target.setDiscoverTargets':
          {
            _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
              method: 'Target.targetCreated',
              params: {
                targetInfo: tabTargetInfo
              }
            });
            _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
              method: 'Target.targetCreated',
              params: {
                targetInfo: pageTargetInfo
              }
            });
            _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
              id: parsed.id,
              sessionId: parsed.sessionId,
              method: parsed.method,
              result: {}
            });
            return;
          }
        case 'Target.setAutoAttach':
          {
            if (parsed.sessionId === 'tabTargetSessionId') {
              _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
                method: 'Target.attachedToTarget',
                params: {
                  targetInfo: pageTargetInfo,
                  sessionId: 'pageTargetSessionId'
                }
              });
              _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
                id: parsed.id,
                sessionId: parsed.sessionId,
                method: parsed.method,
                result: {}
              });
              return;
            } else if (!parsed.sessionId) {
              _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
                method: 'Target.attachedToTarget',
                params: {
                  targetInfo: tabTargetInfo,
                  sessionId: 'tabTargetSessionId'
                }
              });
              _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
                id: parsed.id,
                sessionId: parsed.sessionId,
                method: parsed.method,
                result: {}
              });
              return;
            }
          }
      }
      if (parsed.sessionId === 'pageTargetSessionId') {
        delete parsed.sessionId;
      }
      chrome.debugger.sendCommand(
      
      {
        tabId: _classPrivateFieldGet(_tabId, this),
        sessionId: parsed.sessionId
      }, parsed.method, parsed.params).then(response => {
        _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
          id: parsed.id,
          sessionId: parsed.sessionId ?? 'pageTargetSessionId',
          method: parsed.method,
          result: response
        });
      }).catch(err => {
        _assertClassBrand(_ExtensionTransport_brand, this, _dispatchResponse).call(this, {
          id: parsed.id,
          sessionId: parsed.sessionId ?? 'pageTargetSessionId',
          method: parsed.method,
          error: {
            code: err?.code,
            data: err?.data,
            message: err?.message ?? 'CDP error had no message'
          }
        });
      });
    }
    close() {
      chrome.debugger.onEvent.removeListener(_classPrivateFieldGet(_debuggerEventHandler, this));
      void chrome.debugger.detach({
        tabId: _classPrivateFieldGet(_tabId, this)
      });
    }
  }

  function _dispatchResponse(message) {
    this.onmessage?.(JSON.stringify(message));
  }
  const PredefinedNetworkConditions = Object.freeze({
    
    
    'Slow 3G': {
      
      download: 500 * 1000 / 8 * 0.8,
      
      upload: 500 * 1000 / 8 * 0.8,
      
      latency: 400 * 5
    },
    'Fast 3G': {
      
      download: 1.6 * 1000 * 1000 / 8 * 0.9,
      
      upload: 750 * 1000 / 8 * 0.9,
      
      latency: 150 * 3.75
    },
    
    
    'Slow 4G': {
      
      download: 1.6 * 1000 * 1000 / 8 * 0.9,
      
      upload: 750 * 1000 / 8 * 0.9,
      
      latency: 150 * 3.75
    },
    'Fast 4G': {
      
      download: 9 * 1000 * 1000 / 8 * 0.9,
      
      upload: 1.5 * 1000 * 1000 / 8 * 0.9,
      
      latency: 60 * 2.75
    }
  });

    
    BrowserWebSocketTransport: BrowserWebSocketTransport
  });

  const knownDevices = [{
    name: 'Blackberry PlayBook',
    userAgent: 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+',
    viewport: {
      width: 600,
      height: 1024,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Blackberry PlayBook landscape',
    userAgent: 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+',
    viewport: {
      width: 1024,
      height: 600,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'BlackBerry Z30',
    userAgent: 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+',
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'BlackBerry Z30 landscape',
    userAgent: 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+',
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Galaxy Note 3',
    userAgent: 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Galaxy Note 3 landscape',
    userAgent: 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Galaxy Note II',
    userAgent: 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Galaxy Note II landscape',
    userAgent: 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Galaxy S III',
    userAgent: 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Galaxy S III landscape',
    userAgent: 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Galaxy S5',
    userAgent: 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Galaxy S5 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Galaxy S8',
    userAgent: 'Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
    viewport: {
      width: 360,
      height: 740,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Galaxy S8 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
    viewport: {
      width: 740,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Galaxy S9+',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36',
    viewport: {
      width: 320,
      height: 658,
      deviceScaleFactor: 4.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Galaxy S9+ landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36',
    viewport: {
      width: 658,
      height: 320,
      deviceScaleFactor: 4.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Galaxy Tab S4',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36',
    viewport: {
      width: 712,
      height: 1138,
      deviceScaleFactor: 2.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Galaxy Tab S4 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36',
    viewport: {
      width: 1138,
      height: 712,
      deviceScaleFactor: 2.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPad',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPad landscape',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPad (gen 6)',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPad (gen 6) landscape',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPad (gen 7)',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 810,
      height: 1080,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPad (gen 7) landscape',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 1080,
      height: 810,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPad Mini',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPad Mini landscape',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPad Pro',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
    viewport: {
      width: 1024,
      height: 1366,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPad Pro landscape',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
    viewport: {
      width: 1366,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPad Pro 11',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 834,
      height: 1194,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPad Pro 11 landscape',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 1194,
      height: 834,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 4',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53',
    viewport: {
      width: 320,
      height: 480,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 4 landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53',
    viewport: {
      width: 480,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 5',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
    viewport: {
      width: 320,
      height: 568,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 5 landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
    viewport: {
      width: 568,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 6',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 6 landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 6 Plus',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 6 Plus landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 7',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 7 landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 7 Plus',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 7 Plus landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 8',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 8 landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 8 Plus',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 8 Plus landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone SE',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
    viewport: {
      width: 320,
      height: 568,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone SE landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
    viewport: {
      width: 568,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone X',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone X landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone XR',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 414,
      height: 896,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone XR landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 896,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 11',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 414,
      height: 828,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 11 landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 828,
      height: 414,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 11 Pro',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 11 Pro landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 11 Pro Max',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 414,
      height: 896,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 11 Pro Max landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 896,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 12',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 12 landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 12 Pro',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 12 Pro landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 12 Pro Max',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 428,
      height: 926,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 12 Pro Max landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 926,
      height: 428,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 12 Mini',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 12 Mini landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 13',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 13 landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 13 Pro',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 13 Pro landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 13 Pro Max',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 428,
      height: 926,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 13 Pro Max landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 926,
      height: 428,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 13 Mini',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 13 Mini landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 14',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 390,
      height: 663,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 14 landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 750,
      height: 340,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 14 Plus',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 428,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 14 Plus landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 832,
      height: 378,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 14 Pro',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 14 Pro landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 14 Pro Max',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 14 Pro Max landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 15',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 15 landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 15 Plus',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 15 Plus landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 15 Pro',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 15 Pro landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'iPhone 15 Pro Max',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'iPhone 15 Pro Max landscape',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'JioPhone 2',
    userAgent: 'Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5',
    viewport: {
      width: 240,
      height: 320,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'JioPhone 2 landscape',
    userAgent: 'Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5',
    viewport: {
      width: 320,
      height: 240,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Kindle Fire HDX',
    userAgent: 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true',
    viewport: {
      width: 800,
      height: 1280,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Kindle Fire HDX landscape',
    userAgent: 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true',
    viewport: {
      width: 1280,
      height: 800,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'LG Optimus L70',
    userAgent: 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 384,
      height: 640,
      deviceScaleFactor: 1.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'LG Optimus L70 landscape',
    userAgent: 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 640,
      height: 384,
      deviceScaleFactor: 1.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Microsoft Lumia 550',
    userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Microsoft Lumia 950',
    userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 4,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Microsoft Lumia 950 landscape',
    userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 4,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Nexus 10',
    userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
    viewport: {
      width: 800,
      height: 1280,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Nexus 10 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
    viewport: {
      width: 1280,
      height: 800,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Nexus 4',
    userAgent: 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 384,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Nexus 4 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 640,
      height: 384,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Nexus 5',
    userAgent: 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Nexus 5 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Nexus 5X',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Nexus 5X landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Nexus 6',
    userAgent: 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Nexus 6 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Nexus 6P',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Nexus 6P landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Nexus 7',
    userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
    viewport: {
      width: 600,
      height: 960,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Nexus 7 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
    viewport: {
      width: 960,
      height: 600,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Nokia Lumia 520',
    userAgent: 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)',
    viewport: {
      width: 320,
      height: 533,
      deviceScaleFactor: 1.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Nokia Lumia 520 landscape',
    userAgent: 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)',
    viewport: {
      width: 533,
      height: 320,
      deviceScaleFactor: 1.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Nokia N9',
    userAgent: 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13',
    viewport: {
      width: 480,
      height: 854,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Nokia N9 landscape',
    userAgent: 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13',
    viewport: {
      width: 854,
      height: 480,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Pixel 2',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 411,
      height: 731,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Pixel 2 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 731,
      height: 411,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Pixel 2 XL',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 411,
      height: 823,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Pixel 2 XL landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
    viewport: {
      width: 823,
      height: 411,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Pixel 3',
    userAgent: 'Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36',
    viewport: {
      width: 393,
      height: 786,
      deviceScaleFactor: 2.75,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Pixel 3 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36',
    viewport: {
      width: 786,
      height: 393,
      deviceScaleFactor: 2.75,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Pixel 4',
    userAgent: 'Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36',
    viewport: {
      width: 353,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Pixel 4 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36',
    viewport: {
      width: 745,
      height: 353,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Pixel 4a (5G)',
    userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
    viewport: {
      width: 353,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Pixel 4a (5G) landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
    viewport: {
      width: 745,
      height: 353,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Pixel 5',
    userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
    viewport: {
      width: 393,
      height: 851,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Pixel 5 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
    viewport: {
      width: 851,
      height: 393,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }, {
    name: 'Moto G4',
    userAgent: 'Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  }, {
    name: 'Moto G4 landscape',
    userAgent: 'Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }];
  const knownDevicesByName = {};
  for (const device of knownDevices) {
    knownDevicesByName[device.name] = device;
  }
  const KnownDevices = Object.freeze(knownDevicesByName);

  async function _connectToBiDiBrowser(connectionTransport, url, options) {
    const {
      acceptInsecureCerts = false,
      defaultViewport = DEFAULT_VIEWPORT
    } = options;
    const {
      bidiConnection,
      cdpConnection,
      closeCallback
    } = await getBiDiConnection(connectionTransport, url, options);
  async function getBiDiConnection(connectionTransport, url, options) {
    const version = await cdpConnection.send('Browser.getVersion');
    if (version.product.toLowerCase().includes('firefox')) {
      throw new UnsupportedOperation('Firefox is not supported in BiDi over CDP mode.');
    }
    const bidiOverCdpConnection = await BiDi.connectBidiOverCdp(cdpConnection);
    return {
      cdpConnection,
      bidiConnection: bidiOverCdpConnection,
      closeCallback: async () => {
        
        await cdpConnection.send('Browser.close').catch(debugError);
      }
    };
  }

  const getWebSocketTransportClass = async () => {
    return isNode ? (await Promise.resolve().then(() => _interopRequireWildcard(require('./node/NodeWebSocketTransport.js')))).NodeWebSocketTransport : (await Promise.resolve().then(function () {
      return BrowserWebSocketTransport$1;
    })).BrowserWebSocketTransport;
  };
  async function _connectToBrowser(options) {
    const {
      connectionTransport,
      endpointUrl
    } = await getConnectionTransport(options);
    if (options.protocol === 'webDriverBiDi') {
      const bidiBrowser = await _connectToBiDiBrowser(connectionTransport, endpointUrl, options);
      return bidiBrowser;
    } else {
      const cdpBrowser = await _connectToCdpBrowser(connectionTransport, endpointUrl, options);
      return cdpBrowser;
    }
  }
  async function getConnectionTransport(options) {
    const {
      browserWSEndpoint,
      browserURL,
      transport,
      headers = {}
    } = options;
    assert(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, 'Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect');
    if (transport) {
      return {
        connectionTransport: transport,
        endpointUrl: ''
      };
    } else if (browserWSEndpoint) {
      const WebSocketClass = await getWebSocketTransportClass();
      const connectionTransport = await WebSocketClass.create(browserWSEndpoint, headers);
      return {
        connectionTransport: connectionTransport,
        endpointUrl: browserWSEndpoint
      };
    } else if (browserURL) {
      const connectionURL = await getWSEndpoint(browserURL);
      const WebSocketClass = await getWebSocketTransportClass();
      const connectionTransport = await WebSocketClass.create(connectionURL);
      return {
        connectionTransport: connectionTransport,
        endpointUrl: connectionURL
      };
    }
    throw new Error('Invalid connection options');
  }
  async function getWSEndpoint(browserURL) {
    const endpointURL = new URL('/json/version', browserURL);
    try {
      const result = await globalThis.fetch(endpointURL.toString(), {
        method: 'GET'
      });
      if (!result.ok) {
        throw new Error(`HTTP ${result.statusText}`);
      }
      const data = await result.json();
      return data.webSocketDebuggerUrl;
    } catch (error) {
      if (isErrorLike(error)) {
        error.message = `Failed to fetch browser webSocket URL from ${endpointURL}: ` + error.message;
      }
      throw error;
    }
  }

  class Puppeteer {
    static registerCustomQueryHandler(name, queryHandler) {
      return this.customQueryHandlers.register(name, queryHandler);
    }
    static unregisterCustomQueryHandler(name) {
      return this.customQueryHandlers.unregister(name);
    }
    static customQueryHandlerNames() {
      return this.customQueryHandlers.names();
    }
    static clearCustomQueryHandlers() {
      return this.customQueryHandlers.clear();
    }

    constructor(settings) {
      _defineProperty(this, "_isPuppeteerCore", void 0);
      _defineProperty(this, "_changedBrowsers", false);
      this._isPuppeteerCore = settings.isPuppeteerCore;
      this.connect = this.connect.bind(this);
    }
    connect(options) {
      return _connectToBrowser(options);
    }
  }

  _defineProperty(Puppeteer, "customQueryHandlers", customQueryHandlers);
  const PUPPETEER_REVISIONS = Object.freeze({
    chrome: '134.0.6998.35',
    'chrome-headless-shell': '134.0.6998.35',
    firefox: 'stable_136.0'
  });

  const puppeteer = new Puppeteer({
    isPuppeteerCore: true
  });
  const {
    connect
  } = puppeteer;
  exports.ARIAQueryHandler = ARIAQueryHandler;
  exports.Accessibility = Accessibility;
  exports.AsyncDisposableStack = AsyncDisposableStack;
  exports.AsyncIterableUtil = AsyncIterableUtil;
  exports.Binding = Binding;
  exports.Browser = Browser;
  exports.BrowserContext = BrowserContext;
  exports.BrowserWebSocketTransport = BrowserWebSocketTransport;
  exports.CDPSession = CDPSession;
  exports.CDP_BINDING_PREFIX = CDP_BINDING_PREFIX;
  exports.CSSCoverage = CSSCoverage;
  exports.Callback = Callback;
  exports.CallbackRegistry = CallbackRegistry;
  exports.CdpBrowser = CdpBrowser;
  exports.CdpBrowserContext = CdpBrowserContext;
  exports.CdpCDPSession = CdpCDPSession;
  exports.CdpDialog = CdpDialog;
  exports.CdpElementHandle = CdpElementHandle;
  exports.CdpFrame = CdpFrame;
  exports.CdpHTTPRequest = CdpHTTPRequest;
  exports.CdpHTTPResponse = CdpHTTPResponse;
  exports.CdpJSHandle = CdpJSHandle;
  exports.CdpKeyboard = CdpKeyboard;
  exports.CdpMouse = CdpMouse;
  exports.CdpPage = CdpPage;
  exports.CdpPreloadScript = CdpPreloadScript;
  exports.CdpTarget = CdpTarget;
  exports.CdpTouchscreen = CdpTouchscreen;
  exports.CdpWebWorker = CdpWebWorker;
  exports.Connection = Connection;
  exports.ConsoleMessage = ConsoleMessage;
  exports.Coverage = Coverage;
  exports.CustomQueryHandlerRegistry = CustomQueryHandlerRegistry;
  exports.DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = DEFAULT_INTERCEPT_RESOLUTION_PRIORITY;
  exports.DEFAULT_VIEWPORT = DEFAULT_VIEWPORT;
  exports.Deferred = Deferred;
  exports.DelegatedLocator = DelegatedLocator;
  exports.DevToolsTarget = DevToolsTarget;
  exports.DeviceRequestPrompt = DeviceRequestPrompt;
  exports.DeviceRequestPromptDevice = DeviceRequestPromptDevice;
  exports.DeviceRequestPromptManager = DeviceRequestPromptManager;
  exports.Dialog = Dialog;
  exports.DisposableStack = DisposableStack;
  exports.ElementHandle = ElementHandle;
  exports.EmulatedState = EmulatedState;
  exports.EmulationManager = EmulationManager;
  exports.EventEmitter = EventEmitter;
  exports.ExecutionContext = ExecutionContext;
  exports.ExtensionTransport = ExtensionTransport;
  exports.FileChooser = FileChooser;
  exports.FilteredLocator = FilteredLocator;
  exports.Frame = Frame;
  exports.FrameManager = FrameManager;
  exports.FrameTree = FrameTree;
  exports.FunctionLocator = FunctionLocator;
  exports.HTTPRequest = HTTPRequest;
  exports.HTTPResponse = HTTPResponse;
  exports.IsolatedWorld = IsolatedWorld;
  exports.JSCoverage = JSCoverage;
  exports.JSHandle = JSHandle;
  exports.Keyboard = Keyboard;
  exports.KnownDevices = KnownDevices;
  exports.LazyArg = LazyArg;
  exports.LifecycleWatcher = LifecycleWatcher;
  exports.Locator = Locator;
  exports.MAIN_WORLD = MAIN_WORLD;
  exports.MappedLocator = MappedLocator;
  exports.Mouse = Mouse;
  exports.MouseButton = MouseButton;
  exports.Mutex = Mutex;
  exports.NETWORK_IDLE_TIME = NETWORK_IDLE_TIME;
  exports.NetworkEventManager = NetworkEventManager;
  exports.NetworkManager = NetworkManager;
  exports.NodeLocator = NodeLocator;
  exports.OtherTarget = OtherTarget;
  exports.PQueryHandler = PQueryHandler;
  exports.PUPPETEER_REVISIONS = PUPPETEER_REVISIONS;
  exports.PUPPETEER_WORLD = PUPPETEER_WORLD;
  exports.Page = Page;
  exports.PageTarget = PageTarget;
  exports.PierceQueryHandler = PierceQueryHandler;
  exports.PredefinedNetworkConditions = PredefinedNetworkConditions;
  exports.ProtocolError = ProtocolError;
  exports.Puppeteer = Puppeteer;
  exports.PuppeteerError = PuppeteerError;
  exports.PuppeteerURL = PuppeteerURL;
  exports.QueryHandler = QueryHandler;
  exports.RETRY_DELAY = RETRY_DELAY;
  exports.RaceLocator = RaceLocator;
  exports.Realm = Realm;
  exports.SOURCE_URL_REGEX = SOURCE_URL_REGEX;
  exports.STATUS_TEXTS = STATUS_TEXTS;
  exports.ScriptInjector = ScriptInjector;
  exports.SecurityDetails = SecurityDetails;
  exports.Target = Target;
  exports.TargetCloseError = TargetCloseError;
  exports.TargetManager = TargetManager;
  exports.TaskManager = TaskManager;
  exports.TaskQueue = TaskQueue;
  exports.TextQueryHandler = TextQueryHandler;
  exports.TimeoutError = TimeoutError;
  exports.TimeoutSettings = TimeoutSettings;
  exports.TouchError = TouchError;
  exports.Touchscreen = Touchscreen;
  exports.Tracing = Tracing;
  exports.UTILITY_WORLD_NAME = UTILITY_WORLD_NAME;
  exports.UnsupportedOperation = UnsupportedOperation;
  exports.WEB_PERMISSION_TO_PROTOCOL_PERMISSION = WEB_PERMISSION_TO_PROTOCOL_PERMISSION;
  exports.WaitTask = WaitTask;
  exports.WebWorker = WebWorker;
  exports.WorkerTarget = WorkerTarget;
  exports.XPathQueryHandler = XPathQueryHandler;
  exports._connectToCdpBrowser = _connectToCdpBrowser;
  exports._keyDefinitions = _keyDefinitions;
  exports.addPageBinding = addPageBinding;
  exports.assert = assert;
  exports.asyncDisposeSymbol = asyncDisposeSymbol;
  exports.bindIsolatedHandle = bindIsolatedHandle;
  exports.connect = connect;
  exports.convertCookiesPartitionKeyFromPuppeteerToCdp = convertCookiesPartitionKeyFromPuppeteerToCdp;
  exports.createClientError = createClientError;
  exports.createEvaluationError = createEvaluationError;
  exports.createProtocolErrorMessage = createProtocolErrorMessage;
  exports.customQueryHandlers = customQueryHandlers;
  exports.debug = debug;
  exports.debugError = debugError;
  exports.default = puppeteer;
  exports.disposeSymbol = disposeSymbol;
  exports.evaluationString = evaluationString;
  exports.filterAsync = filterAsync;
  exports.fromAbortSignal = fromAbortSignal;
  exports.fromEmitterEvent = fromEmitterEvent;
  exports.getCapturedLogs = getCapturedLogs;
  exports.getQueryHandlerAndSelector = getQueryHandlerAndSelector;
  exports.getReadableAsTypedArray = getReadableAsTypedArray;
  exports.getReadableFromProtocolStream = getReadableFromProtocolStream;
  exports.getSourcePuppeteerURLIfAvailable = getSourcePuppeteerURLIfAvailable;
  exports.getSourceUrlComment = getSourceUrlComment;
  exports.handleError = handleError;
  exports.headersArray = headersArray;
  exports.importDebug = importDebug;
  exports.isDate = isDate;
  exports.isErrnoException = isErrnoException;
  exports.isErrorLike = isErrorLike;
  exports.isNumber = isNumber;
  exports.isPlainObject = isPlainObject;
  exports.isRegExp = isRegExp;
  exports.isString = isString;
  exports.isTargetClosedError = isTargetClosedError;
  exports.pageBindingInitString = pageBindingInitString;
  exports.paperFormats = paperFormats;
  exports.parsePDFOptions = parsePDFOptions;
  exports.parsePSelectors = parsePSelectors;
  exports.releaseObject = releaseObject;
  exports.rewriteError = rewriteError$1;
  exports.scriptInjector = scriptInjector;
  exports.setDefaultScreenshotOptions = setDefaultScreenshotOptions;
  exports.setLogCapture = setLogCapture;
  exports.supportedMetrics = supportedMetrics$1;
  exports.throwIfDetached = throwIfDetached;
  exports.timeout = timeout;
  exports.transposeIterableHandle = transposeIterableHandle;
  exports.unitToPixels = unitToPixels;
  exports.validateDialogType = validateDialogType;
  exports.valueFromRemoteObject = valueFromRemoteObject;
  exports.withSourcePuppeteerURLIfNone = withSourcePuppeteerURLIfNone;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  return exports;
}({});

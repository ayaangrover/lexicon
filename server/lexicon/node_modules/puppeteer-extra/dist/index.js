"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addExtra = exports.PuppeteerExtra = void 0;
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('puppeteer-extra');
const deepmerge_1 = __importDefault(require("deepmerge"));
class PuppeteerExtra {
    constructor(_pptr, _requireError) {
        this._pptr = _pptr;
        this._requireError = _requireError;
        this._plugins = [];
    }
    use(plugin) {
        if (typeof plugin !== 'object' || !plugin._isPuppeteerExtraPlugin) {
            console.error(`Warning: Plugin is not derived from PuppeteerExtraPlugin, ignoring.`, plugin);
            return this;
        }
        if (!plugin.name) {
            console.error(`Warning: Plugin with no name registering, ignoring.`, plugin);
            return this;
        }
        if (plugin.requirements.has('dataFromPlugins')) {
            plugin.getDataFromPlugins = this.getPluginData.bind(this);
        }
        plugin._register(Object.getPrototypeOf(plugin));
        this._plugins.push(plugin);
        debug('plugin registered', plugin.name);
        return this;
    }
    get pptr() {
        if (this._pptr) {
            return this._pptr;
        }
        
        console.warn(`
    Puppeteer is missing. :-)

    Note: puppeteer is a peer dependency of puppeteer-extra,
    which means you can install your own preferred version.

    - To get the latest stable version run: 'yarn add puppeteer' or 'npm i puppeteer'

    Alternatively:
    - To get puppeteer without the bundled Chromium browser install 'puppeteer-core'
    `);
        throw this._requireError || new Error('No puppeteer instance provided.');
    }
    async launch(options) {
        
        const defaultLaunchOptions = { args: [] };
        options = (0, deepmerge_1.default)(defaultLaunchOptions, options || {});
        this.resolvePluginDependencies();
        this.orderPlugins();
        
        options = await this.callPluginsWithValue('beforeLaunch', options);
        const opts = {
            context: 'launch',
            options,
            defaultArgs: this.defaultArgs
        };
        
        this.checkPluginRequirements(opts);
        const browser = await this.pptr.launch(options);
        this._patchPageCreationMethods(browser);
        await this.callPlugins('_bindBrowserEvents', browser, opts);
        return browser;
    }
    async connect(options) {
        this.resolvePluginDependencies();
        this.orderPlugins();
        
        options = await this.callPluginsWithValue('beforeConnect', options);
        const opts = { context: 'connect', options };
        
        this.checkPluginRequirements(opts);
        const browser = await this.pptr.connect(options);
        this._patchPageCreationMethods(browser);
        await this.callPlugins('_bindBrowserEvents', browser, opts);
        return browser;
    }
    defaultArgs(options) {
        return this.pptr.defaultArgs(options);
    }
    createBrowserFetcher(options) {
        return this.pptr.createBrowserFetcher(options);
    }
    _patchPageCreationMethods(browser) {
        if (!browser._createPageInContext) {
            debug('warning: _patchPageCreationMethods failed (no browser._createPageInContext)');
            return;
        }
        browser._createPageInContext = (function (originalMethod, context) {
            return async function () {
                const page = await originalMethod.apply(context, arguments);
                await page.goto('about:blank');
                return page;
            };
        })(browser._createPageInContext, browser);
    }
    get plugins() {
        return this._plugins;
    }
    get pluginNames() {
        return this._plugins.map(p => p.name);
    }
    getPluginData(name) {
        const data = this._plugins
            .map(p => (Array.isArray(p.data) ? p.data : [p.data]))
            .reduce((acc, arr) => [...acc, ...arr], []);
        return name ? data.filter((d) => d.name === name) : data;
    }
    getPluginsByProp(prop) {
        return this._plugins.filter(plugin => prop in plugin);
    }
    resolvePluginDependencies() {
        
        const missingPlugins = this._plugins
            .map(p => p._getMissingDependencies(this._plugins))
            .reduce((combined, list) => {
            return new Set([...combined, ...list]);
        }, new Set());
        if (!missingPlugins.size) {
            debug('no dependencies are missing');
            return;
        }
        debug('dependencies missing', missingPlugins);
        
        for (let name of [...missingPlugins]) {
            
            
            if (this.pluginNames.includes(name)) {
                debug(`ignoring dependency '${name}', which has been required already.`);
                continue;
            }
            
            name = name.startsWith('puppeteer-extra-plugin')
                ? name
                : `puppeteer-extra-plugin-${name}`;
            
            
            const packageName = name.split('/')[0];
            let dep = null;
            try {
                
                dep = require(name)();
                
                this.use(dep);
            }
            catch (err) {
                console.warn(`
          A plugin listed '${name}' as dependency,
          which is currently missing. Please install it:

          yarn add ${packageName}

          Note: You don't need to require the plugin yourself,
          unless you want to modify it's default settings.
          `);
                throw err;
            }
            
            if (dep.dependencies.size) {
                this.resolvePluginDependencies();
            }
        }
    }
    orderPlugins() {
        debug('orderPlugins:before', this.pluginNames);
        const runLast = this._plugins
            .filter(p => p.requirements.has('runLast'))
            .map(p => p.name);
        for (const name of runLast) {
            const index = this._plugins.findIndex(p => p.name === name);
            this._plugins.push(this._plugins.splice(index, 1)[0]);
        }
        debug('orderPlugins:after', this.pluginNames);
    }
    checkPluginRequirements(opts = {}) {
        for (const plugin of this._plugins) {
            for (const requirement of plugin.requirements) {
                if (opts.context === 'launch' &&
                    requirement === 'headful' &&
                    opts.options.headless) {
                    console.warn(`Warning: Plugin '${plugin.name}' is not supported in headless mode.`);
                }
                if (opts.context === 'connect' && requirement === 'launch') {
                    console.warn(`Warning: Plugin '${plugin.name}' doesn't support puppeteer.connect().`);
                }
            }
        }
    }
    async callPlugins(prop, ...values) {
        for (const plugin of this.getPluginsByProp(prop)) {
            await plugin[prop].apply(plugin, values);
        }
    }
    async callPluginsWithValue(prop, value) {
        for (const plugin of this.getPluginsByProp(prop)) {
            const newValue = await plugin[prop](value);
            if (newValue) {
                value = newValue;
            }
        }
        return value;
    }
}
exports.PuppeteerExtra = PuppeteerExtra;
const defaultExport = (() => {
    return new PuppeteerExtra(...requireVanillaPuppeteer());
})();
exports.default = defaultExport;
const addExtra = (puppeteer) => new PuppeteerExtra(puppeteer);
exports.addExtra = addExtra;
function requireVanillaPuppeteer() {
    try {
        return [require('puppeteer'), undefined];
    }
    catch (_) {
        
    }
    try {
        return [require('puppeteer-core'), undefined];
    }
    catch (err) {
        return [undefined, err];
    }
}

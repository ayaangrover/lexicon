"use strict";
    if (typescript === undefined) {
        typescript = require('typescript');
    }
    const compiledFilepath = `${filepath.slice(0, -2)}cjs`;
    try {
        const config = resolveTsConfig(path_1.default.dirname(filepath)) ?? {};
        config.compilerOptions = {
            ...config.compilerOptions,
            module: typescript.ModuleKind.NodeNext,
            moduleResolution: typescript.ModuleResolutionKind.NodeNext,
            target: typescript.ScriptTarget.ES2022,
            noEmit: false,
        };
        content = typescript.transpileModule(content, config).outputText;
        (0, fs_1.writeFileSync)(compiledFilepath, content);
        return (0, exports.loadJsSync)(compiledFilepath, content).default;
    }
    catch (error) {
        error.message = `TypeScript Error in ${filepath}:\n${error.message}`;
        throw error;
    }
    finally {
        if ((0, fs_1.existsSync)(compiledFilepath)) {
            (0, fs_1.rmSync)(compiledFilepath);
        }
    }
};
exports.loadTsSync = loadTsSync;
const loadTs = async function loadTs(filepath, content) {
    if (typescript === undefined) {
        typescript = (await import('typescript')).default;
    }
    const compiledFilepath = `${filepath.slice(0, -2)}mjs`;
    let transpiledContent;
    try {
        try {
            const config = resolveTsConfig(path_1.default.dirname(filepath)) ?? {};
            config.compilerOptions = {
                ...config.compilerOptions,
                module: typescript.ModuleKind.ES2022,
                moduleResolution: typescript.ModuleResolutionKind.Bundler,
                target: typescript.ScriptTarget.ES2022,
                noEmit: false,
            };
            transpiledContent = typescript.transpileModule(content, config).outputText;
            await (0, promises_1.writeFile)(compiledFilepath, transpiledContent);
        }
        catch (error) {
            error.message = `TypeScript Error in ${filepath}:\n${error.message}`;
            throw error;
        }
        
        return await (0, exports.loadJs)(compiledFilepath, transpiledContent);
    }
    finally {
        if ((0, fs_1.existsSync)(compiledFilepath)) {
            await (0, promises_1.rm)(compiledFilepath);
        }
    }
};
exports.loadTs = loadTs;

function resolveTsConfig(directory) {
    const filePath = typescript.findConfigFile(directory, (fileName) => {
        return typescript.sys.fileExists(fileName);
    });
    if (filePath !== undefined) {
        const { config, error } = typescript.readConfigFile(filePath, (path) => typescript.sys.readFile(path));
        if (error) {
            throw new Error(`Error in ${filePath}: ${error.messageText.toString()}`);
        }
        return config;
    }
    return;
}

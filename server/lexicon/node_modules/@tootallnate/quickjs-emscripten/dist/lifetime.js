"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scope = exports.WeakLifetime = exports.StaticLifetime = exports.Lifetime = void 0;
const asyncify_helpers_1 = require("./asyncify-helpers");
const debug_1 = require("./debug");
const errors_1 = require("./errors");
class Lifetime {
    constructor(_value, copier, disposer, _owner) {
        this._value = _value;
        this.copier = copier;
        this.disposer = disposer;
        this._owner = _owner;
        this._alive = true;
        this._constructorStack = debug_1.QTS_DEBUG ? new Error("Lifetime constructed").stack : undefined;
    }
    get alive() {
        return this._alive;
    }
    get value() {
        this.assertAlive();
        return this._value;
    }
    get owner() {
        return this._owner;
    }
    get dupable() {
        return !!this.copier;
    }
    dup() {
        this.assertAlive();
        if (!this.copier) {
            throw new Error("Non-dupable lifetime");
        }
        return new Lifetime(this.copier(this._value), this.copier, this.disposer, this._owner);
    }
    consume(map) {
        this.assertAlive();
        const result = map(this);
        this.dispose();
        return result;
    }
    dispose() {
        this.assertAlive();
        if (this.disposer) {
            this.disposer(this._value);
        }
        this._alive = false;
    }
    assertAlive() {
        if (!this.alive) {
            if (this._constructorStack) {
                throw new errors_1.QuickJSUseAfterFree(`Lifetime not alive\n${this._constructorStack}\nLifetime used`);
            }
            throw new errors_1.QuickJSUseAfterFree("Lifetime not alive");
        }
    }
}
exports.Lifetime = Lifetime;
class StaticLifetime extends Lifetime {
    constructor(value, owner) {
        super(value, undefined, undefined, owner);
    }
    
    get dupable() {
        return true;
    }
    
    dup() {
        return this;
    }
    
    dispose() { }
}
exports.StaticLifetime = StaticLifetime;
class WeakLifetime extends Lifetime {
    constructor(value, copier, disposer, owner) {
        
        super(value, copier, disposer, owner);
    }
    dispose() {
        this._alive = false;
    }
}
exports.WeakLifetime = WeakLifetime;
function scopeFinally(scope, blockError) {
    
    let disposeError;
    try {
        scope.dispose();
    }
    catch (error) {
        disposeError = error;
    }
    if (blockError && disposeError) {
        Object.assign(blockError, {
            message: `${blockError.message}\n Then, failed to dispose scope: ${disposeError.message}`,
            disposeError,
        });
        throw blockError;
    }
    if (blockError || disposeError) {
        throw blockError || disposeError;
    }
}
class Scope {
    constructor() {
        this._disposables = new Lifetime(new Set());
    }
    static withScope(block) {
        const scope = new Scope();
        let blockError;
        try {
            return block(scope);
        }
        catch (error) {
            blockError = error;
            throw error;
        }
        finally {
            scopeFinally(scope, blockError);
        }
    }
    static withScopeMaybeAsync(_this, block) {
        return (0, asyncify_helpers_1.maybeAsync)(undefined, function* (awaited) {
            const scope = new Scope();
            let blockError;
            try {
                return yield* awaited.of(block.call(_this, awaited, scope));
            }
            catch (error) {
                blockError = error;
                throw error;
            }
            finally {
                scopeFinally(scope, blockError);
            }
        });
    }
    static async withScopeAsync(block) {
        const scope = new Scope();
        let blockError;
        try {
            return await block(scope);
        }
        catch (error) {
            blockError = error;
            throw error;
        }
        finally {
            scopeFinally(scope, blockError);
        }
    }
    manage(lifetime) {
        this._disposables.value.add(lifetime);
        return lifetime;
    }
    get alive() {
        return this._disposables.alive;
    }
    dispose() {
        const lifetimes = Array.from(this._disposables.value.values()).reverse();
        for (const lifetime of lifetimes) {
            if (lifetime.alive) {
                lifetime.dispose();
            }
        }
        this._disposables.dispose();
    }
}
exports.Scope = Scope;

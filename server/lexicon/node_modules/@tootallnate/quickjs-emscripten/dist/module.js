"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuickJSWASMModule = exports.applyModuleEvalRuntimeOptions = exports.applyBaseRuntimeOptions = exports.QuickJSModuleCallbacks = void 0;
const debug_1 = require("./debug");
const errors_1 = require("./errors");
const lifetime_1 = require("./lifetime");
const runtime_1 = require("./runtime");
const types_1 = require("./types");
class QuickJSEmscriptenModuleCallbacks {
    constructor(args) {
        this.callFunction = args.callFunction;
        this.shouldInterrupt = args.shouldInterrupt;
        this.loadModuleSource = args.loadModuleSource;
        this.normalizeModule = args.normalizeModule;
    }
}
class QuickJSModuleCallbacks {
    constructor(module) {
        this.contextCallbacks = new Map();
        this.runtimeCallbacks = new Map();
        this.suspendedCount = 0;
        this.cToHostCallbacks = new QuickJSEmscriptenModuleCallbacks({
            callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id) => this.handleAsyncify(asyncify, () => {
                try {
                    const vm = this.contextCallbacks.get(ctx);
                    if (!vm) {
                        throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call "${fn_id}"`);
                    }
                    return vm.callFunction(ctx, this_ptr, argc, argv, fn_id);
                }
                catch (error) {
                    console.error("[C to host error: returning null]", error);
                    return 0;
                }
            }),
            shouldInterrupt: (asyncify, rt) => this.handleAsyncify(asyncify, () => {
                try {
                    const vm = this.runtimeCallbacks.get(rt);
                    if (!vm) {
                        throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C interrupt`);
                    }
                    return vm.shouldInterrupt(rt);
                }
                catch (error) {
                    console.error("[C to host interrupt: returning error]", error);
                    return 1;
                }
            }),
            loadModuleSource: (asyncify, rt, ctx, moduleName) => this.handleAsyncify(asyncify, () => {
                try {
                    const runtimeCallbacks = this.runtimeCallbacks.get(rt);
                    if (!runtimeCallbacks) {
                        throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`);
                    }
                    const loadModule = runtimeCallbacks.loadModuleSource;
                    if (!loadModule) {
                        throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`);
                    }
                    return loadModule(rt, ctx, moduleName);
                }
                catch (error) {
                    console.error("[C to host module loader error: returning null]", error);
                    return 0;
                }
            }),
            normalizeModule: (asyncify, rt, ctx, moduleBaseName, moduleName) => this.handleAsyncify(asyncify, () => {
                try {
                    const runtimeCallbacks = this.runtimeCallbacks.get(rt);
                    if (!runtimeCallbacks) {
                        throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`);
                    }
                    const normalizeModule = runtimeCallbacks.normalizeModule;
                    if (!normalizeModule) {
                        throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`);
                    }
                    return normalizeModule(rt, ctx, moduleBaseName, moduleName);
                }
                catch (error) {
                    console.error("[C to host module loader error: returning null]", error);
                    return 0;
                }
            }),
        });
        this.module = module;
        this.module.callbacks = this.cToHostCallbacks;
    }
    setRuntimeCallbacks(rt, callbacks) {
        this.runtimeCallbacks.set(rt, callbacks);
    }
    deleteRuntime(rt) {
        this.runtimeCallbacks.delete(rt);
    }
    setContextCallbacks(ctx, callbacks) {
        this.contextCallbacks.set(ctx, callbacks);
    }
    deleteContext(ctx) {
        this.contextCallbacks.delete(ctx);
    }
    handleAsyncify(asyncify, fn) {
        if (asyncify) {
            
            
            
            return asyncify.handleSleep((done) => {
                try {
                    const result = fn();
                    if (!(result instanceof Promise)) {
                        (0, debug_1.debugLog)("asyncify.handleSleep: not suspending:", result);
                        done(result);
                        return;
                    }
                    
                    if (this.suspended) {
                        throw new errors_1.QuickJSAsyncifyError(`Already suspended at: ${this.suspended.stack}\nAttempted to suspend at:`);
                    }
                    else {
                        this.suspended = new errors_1.QuickJSAsyncifySuspended(`(${this.suspendedCount++})`);
                        (0, debug_1.debugLog)("asyncify.handleSleep: suspending:", this.suspended);
                    }
                    result.then((resolvedResult) => {
                        this.suspended = undefined;
                        (0, debug_1.debugLog)("asyncify.handleSleep: resolved:", resolvedResult);
                        done(resolvedResult);
                    }, (error) => {
                        (0, debug_1.debugLog)("asyncify.handleSleep: rejected:", error);
                        console.error("QuickJS: cannot handle error in suspended function", error);
                        this.suspended = undefined;
                    });
                }
                catch (error) {
                    (0, debug_1.debugLog)("asyncify.handleSleep: error:", error);
                    this.suspended = undefined;
                    throw error;
                }
            });
        }
        
        const value = fn();
        if (value instanceof Promise) {
            throw new Error("Promise return value not supported in non-asyncify context.");
        }
        return value;
    }
}
exports.QuickJSModuleCallbacks = QuickJSModuleCallbacks;
function applyBaseRuntimeOptions(runtime, options) {
    if (options.interruptHandler) {
        runtime.setInterruptHandler(options.interruptHandler);
    }
    if (options.maxStackSizeBytes !== undefined) {
        runtime.setMaxStackSize(options.maxStackSizeBytes);
    }
    if (options.memoryLimitBytes !== undefined) {
        runtime.setMemoryLimit(options.memoryLimitBytes);
    }
}
exports.applyBaseRuntimeOptions = applyBaseRuntimeOptions;
function applyModuleEvalRuntimeOptions(runtime, options) {
    if (options.moduleLoader) {
        runtime.setModuleLoader(options.moduleLoader);
    }
    if (options.shouldInterrupt) {
        runtime.setInterruptHandler(options.shouldInterrupt);
    }
    if (options.memoryLimitBytes !== undefined) {
        runtime.setMemoryLimit(options.memoryLimitBytes);
    }
    if (options.maxStackSizeBytes !== undefined) {
        runtime.setMaxStackSize(options.maxStackSizeBytes);
    }
}
exports.applyModuleEvalRuntimeOptions = applyModuleEvalRuntimeOptions;
class QuickJSWASMModule {
    newRuntime(options = {}) {
        const rt = new lifetime_1.Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {
            this.callbacks.deleteRuntime(rt_ptr);
            this.ffi.QTS_FreeRuntime(rt_ptr);
        });
        const runtime = new runtime_1.QuickJSRuntime({
            module: this.module,
            callbacks: this.callbacks,
            ffi: this.ffi,
            rt,
        });
        applyBaseRuntimeOptions(runtime, options);
        if (options.moduleLoader) {
            runtime.setModuleLoader(options.moduleLoader);
        }
        return runtime;
    }
    newContext(options = {}) {
        const runtime = this.newRuntime();
        const context = runtime.newContext({
            ...options,
            ownedLifetimes: (0, types_1.concat)(runtime, options.ownedLifetimes),
        });
        runtime.context = context;
        return context;
    }
    evalCode(code, options = {}) {
        return lifetime_1.Scope.withScope((scope) => {
            const vm = scope.manage(this.newContext());
            applyModuleEvalRuntimeOptions(vm.runtime, options);
            const result = vm.evalCode(code, "eval.js");
            if (options.memoryLimitBytes !== undefined) {
                
                vm.runtime.setMemoryLimit(-1);
            }
            if (result.error) {
                const error = vm.dump(scope.manage(result.error));
                throw error;
            }
            const value = vm.dump(scope.manage(result.value));
            return value;
        });
    }
    getFFI() {
        return this.ffi;
    }
}
exports.QuickJSWASMModule = QuickJSWASMModule;

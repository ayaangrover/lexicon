"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FTPContext = exports.FTPError = void 0;
const net_1 = require("net");
const parseControlResponse_1 = require("./parseControlResponse");
class FTPError extends Error {
    constructor(res) {
        super(res.message);
        this.name = this.constructor.name;
        this.code = res.code;
    }
}
exports.FTPError = FTPError;
function doNothing() {
class FTPContext {
    constructor(timeout = 0, encoding = "utf8") {
        this.timeout = timeout;
        this.ipFamily = undefined;
        this._partialResponse = "";
        this._encoding = encoding;
        
        this._socket = this.socket = this._newSocket();
        this._dataSocket = undefined;
    }
    close() {
        
        
        
        
        
        
        const message = this._task ? "User closed client during task" : "User closed client";
        const err = new Error(message);
        this.closeWithError(err);
    }
    closeWithError(err) {
        
        if (this._closingError) {
            return;
        }
        this._closingError = err;
        
        this._closeControlSocket();
        this._closeSocket(this._dataSocket);
        
        this._passToHandler(err);
        
        this._stopTrackingTask();
    }
    get closed() {
        return this.socket.remoteAddress === undefined || this._closingError !== undefined;
    }
    reset() {
        this.socket = this._newSocket();
    }
    get socket() {
        return this._socket;
    }
    set socket(socket) {
        
        this.dataSocket = undefined;
        
        this.tlsOptions = {};
        this._partialResponse = "";
        if (this._socket) {
            const newSocketUpgradesExisting = socket.localPort === this._socket.localPort;
            if (newSocketUpgradesExisting) {
                this._removeSocketListeners(this.socket);
            }
            else {
                this._closeControlSocket();
            }
        }
        if (socket) {
            
            
            
            
            this._closingError = undefined;
            
            socket.setTimeout(0);
            socket.setEncoding(this._encoding);
            socket.setKeepAlive(true);
            socket.on("data", data => this._onControlSocketData(data));
            
            socket.on("end", () => this.closeWithError(new Error("Server sent FIN packet unexpectedly, closing connection.")));
            
            socket.on("close", hadError => { if (!hadError)
                this.closeWithError(new Error("Server closed connection unexpectedly.")); });
            this._setupDefaultErrorHandlers(socket, "control socket");
        }
        this._socket = socket;
    }
    get dataSocket() {
        return this._dataSocket;
    }
    set dataSocket(socket) {
        this._closeSocket(this._dataSocket);
        if (socket) {
            
            
            socket.setTimeout(0);
            this._setupDefaultErrorHandlers(socket, "data socket");
        }
        this._dataSocket = socket;
    }
    get encoding() {
        return this._encoding;
    }
    set encoding(encoding) {
        this._encoding = encoding;
        if (this.socket) {
            this.socket.setEncoding(encoding);
        }
    }
    send(command) {
        const containsPassword = command.startsWith("PASS");
        const message = containsPassword ? "> PASS ###" : `> ${command}`;
        this.log(message);
        this._socket.write(command + "\r\n", this.encoding);
    }
    request(command) {
        return this.handle(command, (res, task) => {
            if (res instanceof Error) {
                task.reject(res);
            }
            else {
                task.resolve(res);
            }
        });
    }
    handle(command, responseHandler) {
        if (this._task) {
            const err = new Error("User launched a task while another one is still running. Forgot to use 'await' or '.then()'?");
            err.stack += `\nRunning task launched at: ${this._task.stack}`;
            this.closeWithError(err);
            
            
            
        }
        return new Promise((resolveTask, rejectTask) => {
            this._task = {
                stack: new Error().stack || "Unknown call stack",
                responseHandler,
                resolver: {
                    resolve: arg => {
                        this._stopTrackingTask();
                        resolveTask(arg);
                    },
                    reject: err => {
                        this._stopTrackingTask();
                        rejectTask(err);
                    }
                }
            };
            if (this._closingError) {
                
                
                const err = new Error(`Client is closed because ${this._closingError.message}`); 
                err.stack += `\nClosing reason: ${this._closingError.stack}`;
                err.code = this._closingError.code !== undefined ? this._closingError.code : "0";
                this._passToHandler(err);
                return;
            }
            
            
            this.socket.setTimeout(this.timeout);
            if (command) {
                this.send(command);
            }
        });
    }
    log(message) {
        if (this.verbose) {
            
            console.log(message);
        }
    }
    get hasTLS() {
        return "encrypted" in this._socket;
    }
    _stopTrackingTask() {
        
        this.socket.setTimeout(0);
        this._task = undefined;
    }
    _onControlSocketData(chunk) {
        this.log(`< ${chunk}`);
        
        const completeResponse = this._partialResponse + chunk;
        const parsed = (0, parseControlResponse_1.parseControlResponse)(completeResponse);
        
        this._partialResponse = parsed.rest;
        
        for (const message of parsed.messages) {
            const code = parseInt(message.substr(0, 3), 10);
            const response = { code, message };
            const err = code >= 400 ? new FTPError(response) : undefined;
            this._passToHandler(err ? err : response);
        }
    }
    _passToHandler(response) {
        if (this._task) {
            this._task.responseHandler(response, this._task.resolver);
        }
        
        
        
        
        
        
    }
    _setupDefaultErrorHandlers(socket, identifier) {
        socket.once("error", error => {
            error.message += ` (${identifier})`;
            this.closeWithError(error);
        });
        socket.once("close", hadError => {
            if (hadError) {
                this.closeWithError(new Error(`Socket closed due to transmission error (${identifier})`));
            }
        });
        socket.once("timeout", () => {
            socket.destroy();
            this.closeWithError(new Error(`Timeout (${identifier})`));
        });
    }
    _closeControlSocket() {
        this._removeSocketListeners(this._socket);
        this._socket.on("error", doNothing);
        this.send("QUIT");
        this._closeSocket(this._socket);
    }
    _closeSocket(socket) {
        if (socket) {
            this._removeSocketListeners(socket);
            socket.on("error", doNothing);
            socket.destroy();
        }
    }
    _removeSocketListeners(socket) {
        socket.removeAllListeners();
        
        socket.removeAllListeners("timeout");
        socket.removeAllListeners("data");
        socket.removeAllListeners("end");
        socket.removeAllListeners("error");
        socket.removeAllListeners("close");
        socket.removeAllListeners("connect");
    }
    _newSocket() {
        return new net_1.Socket();
    }
}
exports.FTPContext = FTPContext;

import debug from 'debug';
const debugInternal = debug('bidi:server:pipeTranspot');
export class PipeTransport {
    #pipeWrite;
    #onMessage = null;
    #pendingMessage = '';
    constructor(pipeWrite, pipeRead) {
        this.#pipeWrite = pipeWrite;
        pipeRead.on('data', (chunk) => {
            return this.#dispatch(chunk);
        });
        pipeRead.on('close', () => {
            this.close();
        });
        pipeRead.on('error', (error) => {
            debugInternal('Pipe read error: ', error);
            this.close();
        });
        pipeWrite.on('error', (error) => {
            debugInternal('Pipe read error: ', error);
            this.close();
        });
    }
    setOnMessage(onMessage) {
        this.#onMessage = onMessage;
    }
    sendMessage(message) {
        
        
        this.#pipeWrite.write(message);
        this.#pipeWrite.write('\0');
    }
    #dispatch(buffer) {
        
        
        let end = buffer.indexOf('\0');
        if (end === -1) {
            this.#pendingMessage += buffer.toString();
            return;
        }
        const message = this.#pendingMessage + buffer.toString(undefined, 0, end);
        if (this.#onMessage) {
            this.#onMessage.call(null, message);
        }
        let start = end + 1;
        end = buffer.indexOf('\0', start);
        while (end !== -1) {
            if (this.#onMessage) {
                this.#onMessage.call(null, buffer.toString(undefined, start, end));
            }
            start = end + 1;
            end = buffer.indexOf('\0', start);
        }
        this.#pendingMessage = buffer.toString(undefined, start);
    }
    close() {
        debugInternal('Closing pipe');
    }
}

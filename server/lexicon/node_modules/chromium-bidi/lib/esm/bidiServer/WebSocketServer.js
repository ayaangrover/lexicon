import http from 'http';
import debug from 'debug';
import * as websocket from 'websocket';
import { Deferred } from '../utils/Deferred.js';
import { uuidv4 } from '../utils/uuid.js';
import { BrowserInstance } from './BrowserInstance.js';
export const debugInfo = debug('bidi:server:info');
const debugInternal = debug('bidi:server:internal');
const debugSend = debug('bidi:server:SEND ▸');
const debugRecv = debug('bidi:server:RECV ◂');
export class WebSocketServer {
    #sessions = new Map();
    #port;
    #verbose;
    #server;
    #wsServer;
    constructor(port, verbose) {
        this.#port = port;
        this.#verbose = verbose;
        this.#server = http.createServer((request, response) => {
            return this.#onRequest(request, response).catch((e) => {
                debugInfo('Error while processing request', e);
                response.writeHead(500, String(e));
            });
        });
        this.#wsServer = new websocket.server({
            httpServer: this.#server,
            autoAcceptConnections: false,
        });
        this.#wsServer.on('request', this.#onWsRequest.bind(this));
        void this.#listen();
    }
    #logServerStarted() {
        debugInfo('BiDi server is listening on port', this.#port);
        debugInfo('BiDi server was started successfully.');
    }
    async #listen() {
        try {
            this.#server.listen(this.#port, () => {
                this.#logServerStarted();
            });
        }
        catch (error) {
            if (error &&
                typeof error === 'object' &&
                'code' in error &&
                error.code === 'EADDRINUSE') {
                await new Promise((resolve) => {
                    setTimeout(resolve, 500);
                });
                debugInfo('Retrying to run BiDi server');
                this.#server.listen(this.#port, () => {
                    this.#logServerStarted();
                });
            }
            throw error;
        }
    }
    async #onRequest(request, response) {
        debugInternal(`Received HTTP ${JSON.stringify(request.method)} request for ${JSON.stringify(request.url)}`);
        if (!request.url) {
            throw new Error('Request URL is empty.');
        }
        
        if (request.url === '/session') {
            const body = await new Promise((resolve, reject) => {
                const bodyArray = [];
                request.on('data', (chunk) => {
                    bodyArray.push(chunk);
                });
                request.on('error', reject);
                request.on('end', () => {
                    resolve(Buffer.concat(bodyArray));
                });
            });
            debugInternal(`Creating session by HTTP request ${body.toString()}`);
            
            const jsonBody = JSON.parse(body.toString());
            response.writeHead(200, {
                'Content-Type': 'application/json;charset=utf-8',
                'Cache-Control': 'no-cache',
            });
            const sessionId = uuidv4();
            const session = {
                sessionId,
                
                
                browserInstancePromise: undefined,
                sessionOptions: {
                    chromeOptions: this.#getChromeOptions(jsonBody.capabilities),
                    verbose: this.#verbose,
                    sessionNewBody: `{"id":0,"method":"session.new","params":${body.toString()}}`,
                },
            };
            this.#sessions.set(sessionId, session);
            const webSocketUrl = `ws:
            debugInternal(`Session created. WebSocket URL: ${JSON.stringify(webSocketUrl)}.`);
            response.write(JSON.stringify({
                value: {
                    sessionId,
                    capabilities: {
                        webSocketUrl,
                    },
                },
            }));
            return response.end();
        }
        else if (request.url.startsWith('/session')) {
            debugInternal(`Unknown session command ${request.method ?? 'UNKNOWN METHOD'} request for ${request.url} with payload ${await this.#getHttpRequestPayload(request)}. 200 returned.`);
            response.writeHead(200, {
                'Content-Type': 'application/json;charset=utf-8',
                'Cache-Control': 'no-cache',
            });
            response.write(JSON.stringify({
                value: {},
            }));
            return response.end();
        }
        throw new Error(`Unknown "${request.method}" request for "${JSON.stringify(request.url)}" with payload "${await this.#getHttpRequestPayload(request)}".`);
    }
    #onWsRequest(request) {
        
        let session;
        
        let requestSessionId = '';
        if ((request.resource ?? '').startsWith(`/session/`)) {
            requestSessionId = (request.resource ?? '').split('/').pop() ?? '';
        }
        debugInternal(`new WS request received. Path: ${JSON.stringify(request.resourceURL.path)}, sessionId: ${JSON.stringify(requestSessionId)}`);
        if (requestSessionId !== '' &&
            requestSessionId !== undefined &&
            !this.#sessions.has(requestSessionId)) {
            debugInternal('Unknown session id:', requestSessionId);
            request.reject();
            return;
        }
        const connection = request.accept();
        session = this.#sessions.get(requestSessionId ?? '');
        if (session !== undefined) {
            
            
            
            
            
            const sessionOptions = session.sessionOptions;
            session.browserInstancePromise = this.#closeBrowserInstanceIfLaunched(session)
                .then(async () => await this.#launchBrowserInstance(connection, sessionOptions))
                .catch((e) => {
                debugInfo('Error while creating session', e);
                connection.close(500, 'cannot create browser instance');
                throw e;
            });
        }
        connection.on('message', async (message) => {
            
            if (message.type !== 'utf8') {
                return;
            }
            
            if (parsedCommandData.method === 'session.new') {
                if (session !== undefined) {
                    debugInfo('WS connection already have an associated session.');
                    return;
                }
                return;
            }
            
            if (parsedCommandData.method === 'session.end') {
                if (session === undefined) {
                    debugInfo('WS connection does not have an associated session.');
                    return;
                }
                this.#sendClientMessage({
                    id: parsedCommandData.id,
                    type: 'success',
                    result: {},
                }, connection);
                return;
            }
            if (session === undefined) {
                debugInfo('Session is not yet initialized.');
                return;
            }
            const browserInstance = await session.browserInstancePromise;
            
            if (parsedCommandData.method === 'browser.close') {
                await browserInstance.close();
                this.#sendClientMessage({
                    id: parsedCommandData.id,
                    type: 'success',
                    result: {},
                }, connection);
                return;
            }
            
            await browserInstance.bidiSession().sendCommand(plainCommandData);
        });
        connection.on('close', async () => {
            debugInternal(`Peer ${connection.remoteAddress} disconnected.`);
            
            await this.#closeBrowserInstanceIfLaunched(session);
        });
    }
    async #closeBrowserInstanceIfLaunched(session) {
        if (session === undefined || session.browserInstancePromise === undefined) {
            return;
        }
        const browserInstance = await session.browserInstancePromise;
        session.browserInstancePromise = undefined;
        void browserInstance.close();
    }
    #getChromeOptions(capabilities) {
        const chromeCapabilities = capabilities?.alwaysMatch?.['goog:chromeOptions'];
        return {
            chromeArgs: chromeCapabilities?.args ?? [],
            chromeBinary: chromeCapabilities?.binary ?? undefined,
        };
    }
    async #launchBrowserInstance(connection, sessionOptions, passSessionNewThrough = false) {
        debugInfo('Scheduling browser launch...');
        const browserInstance = await BrowserInstance.run(sessionOptions.chromeOptions, sessionOptions.verbose);
        const body = JSON.parse(sessionOptions.sessionNewBody);
        const id = body.id;
        const sessionCreated = new Deferred();
        const sessionResponseListener = (message) => {
            const jsonMessage = JSON.parse(message);
            if (jsonMessage['id'] === id) {
                debugInfo('Receiving session.new response from mapper', message);
                sessionCreated.resolve();
                if (passSessionNewThrough) {
                    this.#sendClientMessageString(message, connection);
                }
            }
        };
        browserInstance.bidiSession().on('message', sessionResponseListener);
        debugInfo('Sending session.new to mapper', sessionOptions.sessionNewBody);
        await browserInstance
            .bidiSession()
            .sendCommand(sessionOptions.sessionNewBody);
        await sessionCreated;
        browserInstance.bidiSession().off('message', sessionResponseListener);
        
        browserInstance.bidiSession().on('message', (message) => {
            this.#sendClientMessageString(message, connection);
        });
        debugInfo('Browser is launched!');
        return browserInstance;
    }
    #sendClientMessageString(message, connection) {
        if (debugSend.enabled) {
            try {
                debugSend(JSON.parse(message));
            }
            catch {
                debugSend(message);
            }
        }
        connection.sendUTF(message);
    }
    #sendClientMessage(object, connection) {
        const json = JSON.stringify(object);
        return this.#sendClientMessageString(json, connection);
    }
    #respondWithError(connection, plainCommandData, errorCode, errorMessage) {
        const errorResponse = this.#getErrorResponse(plainCommandData, errorCode, errorMessage);
        void this.#sendClientMessage(errorResponse, connection);
    }
    #getErrorResponse(plainCommandData, errorCode, errorMessage) {
        
        
        let commandId;
        try {
            const commandData = JSON.parse(plainCommandData);
            if ('id' in commandData) {
                commandId = commandData.id;
            }
        }
        catch { }
        return {
            type: 'error',
            id: commandId,
            error: errorCode,
            message: errorMessage,
            
        };
    }
    #getHttpRequestPayload(request) {
        return new Promise((resolve, reject) => {
            let data = '';
            request.on('data', (chunk) => {
                data += chunk;
            });
            request.on('end', () => {
                resolve(data);
            });
            request.on('error', (error) => {
                reject(error);
            });
        });
    }
}

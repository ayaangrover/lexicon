var _a;
import { ChromiumBidi, } from '../../../protocol/protocol.js';
import { assert } from '../../../utils/assert.js';
import { DefaultMap } from '../../../utils/DefaultMap.js';
import { Deferred } from '../../../utils/Deferred.js';
import { LogType } from '../../../utils/log.js';
import { bidiBodySizeFromCdpPostDataEntries, bidiNetworkHeadersFromCdpNetworkHeaders, cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction, cdpFetchHeadersFromBidiNetworkHeaders, cdpToBiDiCookie, computeHeadersSize, getTiming, networkHeaderFromCookieHeaders, stringToBase64, } from './NetworkUtils.js';
const REALM_REGEX = /(?<=realm=").*(?=")/;
    #id;
    #fetchId;
    #interceptPhase;
    #servedFromCache = false;
    #redirectCount;
    #request = {};
    #requestOverrides;
    #responseOverrides;
    #response = {};
    #eventManager;
    #networkStorage;
    #cdpTarget;
    #logger;
    #emittedEvents = {
        [ChromiumBidi.Network.EventNames.AuthRequired]: false,
        [ChromiumBidi.Network.EventNames.BeforeRequestSent]: false,
        [ChromiumBidi.Network.EventNames.FetchError]: false,
        [ChromiumBidi.Network.EventNames.ResponseCompleted]: false,
        [ChromiumBidi.Network.EventNames.ResponseStarted]: false,
    };
    waitNextPhase = new Deferred();
    constructor(id, eventManager, networkStorage, cdpTarget, redirectCount = 0, logger) {
        this.#id = id;
        this.#eventManager = eventManager;
        this.#networkStorage = networkStorage;
        this.#cdpTarget = cdpTarget;
        this.#redirectCount = redirectCount;
        this.#logger = logger;
    }
    get id() {
        return this.#id;
    }
    get fetchId() {
        return this.#fetchId;
    }
    get interceptPhase() {
        return this.#interceptPhase;
    }
    get url() {
        const fragment = this.#request.info?.request.urlFragment ??
            this.#request.paused?.request.urlFragment ??
            '';
        const url = this.#response.paused?.request.url ??
            this.#requestOverrides?.url ??
            this.#response.info?.url ??
            this.#request.auth?.request.url ??
            this.#request.info?.request.url ??
            this.#request.paused?.request.url ??
            _a.unknownParameter;
        return `${url}${fragment}`;
    }
    get redirectCount() {
        return this.#redirectCount;
    }
    get cdpTarget() {
        return this.#cdpTarget;
    }
    get cdpClient() {
        return this.#cdpTarget.cdpClient;
    }
    isRedirecting() {
        return Boolean(this.#request.info);
    }
    #isDataUrl() {
        return this.url.startsWith('data:');
    }
    get #method() {
        return (this.#requestOverrides?.method ??
            this.#request.info?.request.method ??
            this.#request.paused?.request.method ??
            this.#request.auth?.request.method ??
            this.#response.paused?.request.method);
    }
    get #navigationId() {
        
        if (!this.#request.info ||
            !this.#request.info.loaderId ||
            
            
            
            this.#request.info.loaderId !== this.#request.info.requestId) {
            return null;
        }
        
        return this.#networkStorage.getNavigationId(this.#context ?? undefined);
    }
    get #cookies() {
        let cookies = [];
        if (this.#request.extraInfo) {
            cookies = this.#request.extraInfo.associatedCookies
                .filter(({ blockedReasons }) => {
                return !Array.isArray(blockedReasons) || blockedReasons.length === 0;
            })
                .map(({ cookie }) => cdpToBiDiCookie(cookie));
        }
        return cookies;
    }
    get #bodySize() {
        let bodySize = 0;
        if (typeof this.#requestOverrides?.bodySize === 'number') {
            bodySize = this.#requestOverrides.bodySize;
        }
        else {
            bodySize = bidiBodySizeFromCdpPostDataEntries(this.#request.info?.request.postDataEntries ?? []);
        }
        return bodySize;
    }
    get #context() {
        return (this.#response.paused?.frameId ??
            this.#request.info?.frameId ??
            this.#request.paused?.frameId ??
            this.#request.auth?.frameId ??
            null);
    }
        const requestInterceptionCompleted = !requestInterceptionExpected ||
            (requestInterceptionExpected && Boolean(this.#request.paused));
        if (Boolean(this.#request.info) &&
            (requestInterceptionExpected
                ? requestInterceptionCompleted
                : requestExtraInfoCompleted)) {
            this.#emitEvent(this.#getBeforeRequestEvent.bind(this));
        }
        const responseExtraInfoCompleted = Boolean(this.#response.extraInfo) ||
            
            this.#servedFromCache ||
            
            Boolean(this.#response.info && !this.#response.hasExtraInfo);
        const responseInterceptionExpected = !noInterceptionExpected &&
    async failRequest(errorReason) {
        assert(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.failRequest', {
            requestId: this.#fetchId,
            errorReason,
        });
        this.#interceptPhase = undefined;
    }
    onRequestPaused(event) {
        this.#fetchId = event.requestId;
        
        if (event.responseStatusCode || event.responseErrorReason) {
            this.#response.paused = event;
            }
            else {
                void this.#continueResponse();
            }
        }
        else {
            this.#request.paused = event;
            }
            else {
                void this.#continueRequest();
            }
        }
        this.#emitEventsIfReady();
    }
    onAuthRequired(event) {
        this.#fetchId = event.requestId;
        this.#request.auth = event;
        }
        else {
            void this.#continueWithAuth({
                response: 'Default',
            });
        }
        this.#emitEvent(() => {
            return {
                method: ChromiumBidi.Network.EventNames.AuthRequired,
                params: {
    async continueRequest(overrides = {}) {
        const overrideHeaders = this.#getOverrideHeader(overrides.headers, overrides.cookies);
        const headers = cdpFetchHeadersFromBidiNetworkHeaders(overrideHeaders);
        const postData = getCdpBodyFromBiDiBytesValue(overrides.body);
        await this.#continueRequest({
            url: overrides.url,
            method: overrides.method,
            headers,
            postData,
        });
        this.#requestOverrides = {
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers,
            cookies: overrides.cookies,
            bodySize: getSizeFromBiDiBytesValue(overrides.body),
        };
    }
    async #continueRequest(overrides = {}) {
        assert(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.continueRequest', {
            requestId: this.#fetchId,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers,
            postData: overrides.postData,
        });
        this.#interceptPhase = undefined;
    }
            if (overrides.credentials) {
                await Promise.all([
                    this.waitNextPhase,
                    await this.#continueWithAuth({
                        response: 'ProvideCredentials',
                        username: overrides.credentials.username,
                        password: overrides.credentials.password,
                    }),
                ]);
            }
            else {
                
                
                return await this.#continueWithAuth({
                    response: 'ProvideCredentials',
                });
            }
        }
    async continueWithAuth(authChallenge) {
        let username;
        let password;
        if (authChallenge.action === 'provideCredentials') {
            const { credentials } = authChallenge;
            username = credentials.username;
            password = credentials.password;
        }
        const response = cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction(authChallenge.action);
        await this.#continueWithAuth({
            response,
            username,
            password,
        });
    }
            
            
            return await this.#continueWithAuth({
                response: 'ProvideCredentials',
            });
        }
        
        
        if (!overrides.body && !overrides.headers) {
            return await this.#continueRequest();
        }
        const overrideHeaders = this.#getOverrideHeader(overrides.headers, overrides.cookies);
        const responseHeaders = cdpFetchHeadersFromBidiNetworkHeaders(overrideHeaders);
        const responseCode = overrides.statusCode ?? this.#statusCode ?? 200;
        await this.cdpClient.sendCommand('Fetch.fulfillRequest', {
            requestId: this.#fetchId,
            responseCode,
            responsePhrase: overrides.reasonPhrase,
            responseHeaders,
            body: getCdpBodyFromBiDiBytesValue(overrides.body),
        });
        this.#interceptPhase = undefined;
    }
    dispose() {
        this.waitNextPhase.reject(new Error('waitNextPhase disposed'));
    }
    async #continueWithAuth(authChallengeResponse) {
        assert(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.continueWithAuth', {
            requestId: this.#fetchId,
            authChallengeResponse,
        });
        this.#interceptPhase = undefined;
    }
    #emitEvent(getEvent) {
        let event;
        try {
            event = getEvent();
        }
        catch (error) {
            this.#logger?.(LogType.debugError, error);
            return;
        }
        if (this.#isIgnoredEvent() ||
            (this.#emittedEvents[event.method] &&
                
                event.method !== ChromiumBidi.Network.EventNames.AuthRequired)) {
            return;
        }
        this.#phaseChanged();
        this.#emittedEvents[event.method] = true;
        if (this.#context) {
            this.#eventManager.registerEvent(Object.assign(event, {
                type: 'event',
            }), this.#context);
        }
        else {
            this.#eventManager.registerGlobalEvent(Object.assign(event, {
                type: 'event',
            }));
        }
    }
    #getBaseEventParams(phase) {
        const interceptProps = {
            isBlocked: false,
        };
        if (phase) {
            const blockedBy = this.#interceptsInPhase(phase);
            interceptProps.isBlocked = blockedBy.size > 0;
            if (interceptProps.isBlocked) {
                interceptProps.intercepts = [...blockedBy];
            }
        }
        return {
            context: this.#context,
            navigation: this.#navigationId,
            redirectCount: this.#redirectCount,
            request: this.#getRequestData(),
            
            timestamp: Math.round(getTiming(this.#request.info?.wallTime) * 1000),
            
            ...interceptProps,
        };
    }
    #getResponseEventParams() {
        
        
        
        if (this.#response.info?.fromDiskCache) {
            this.#response.extraInfo = undefined;
        }
        const headers = [
            ...bidiNetworkHeadersFromCdpNetworkHeaders(this.#response.info?.headers),
            ...bidiNetworkHeadersFromCdpNetworkHeaders(this.#response.extraInfo?.headers),
            
            
            
            
        ];
        const authChallenges = this.#authChallenges;
        const response = {
            url: this.url,
            protocol: this.#response.info?.protocol ?? '',
            status: this.#statusCode ?? -1, 
            statusText: this.#response.info?.statusText ||
                this.#response.paused?.responseStatusText ||
                '',
            fromCache: this.#response.info?.fromDiskCache ||
                this.#response.info?.fromPrefetchCache ||
                this.#servedFromCache,
            headers: this.#responseOverrides?.headers ?? headers,
            mimeType: this.#response.info?.mimeType || '',
            bytesReceived: this.#response.info?.encodedDataLength || 0,
            headersSize: computeHeadersSize(headers),
            
            bodySize: 0,
            content: {
                
                size: 0,
            },
            ...(authChallenges ? { authChallenges } : {}),
        };
        return {
            ...response,
            'goog:securityDetails': this.#response.info?.securityDetails,
        };
    }
    #getRequestData() {
        const headers = this.#requestHeaders;
        const request = {
            request: this.#id,
            url: this.url,
            method: this.#method ?? _a.unknownParameter,
            headers,
            cookies: this.#cookies,
            headersSize: computeHeadersSize(headers),
            bodySize: this.#bodySize,
            
            destination: this.#getDestination(),
            
            initiatorType: this.#getInitiatorType(),
            timings: this.#timings,
        };
        return {
            ...request,
            'goog:postData': this.#request.info?.request?.postData,
            'goog:hasPostData': this.#request.info?.request?.hasPostData,
            'goog:resourceType': this.#request.info?.type,
            'goog:resourceInitiator': this.#request.info?.initiator,
        };
    }
    #getDestination() {
        switch (this.#request.info?.type) {
            case 'Script':
                return 'script';
            case 'Stylesheet':
                return 'style';
            case 'Image':
                return 'image';
            case 'Document':
                
                
                return this.#request.info?.initiator.type === 'parser' ? 'iframe' : '';
            default:
                return '';
        }
    }
    #getInitiatorType() {
        if (this.#request.info?.initiator.type === 'parser') {
            switch (this.#request.info?.type) {
                case 'Document':
                    
                    return 'iframe';
                case 'Font':
                    
                    
                    return this.#request.info?.initiator?.url ===
                        this.#request.info?.documentURL
                        ? 'font'
                        : 'css';
                case 'Image':
                    
                    
                    return this.#request.info?.initiator?.url ===
                        this.#request.info?.documentURL
                        ? 'img'
                        : 'css';
                case 'Script':
                    return 'script';
                case 'Stylesheet':
                    return 'link';
                default:
                    return null;
            }
        }
        if (this.#request?.info?.type === 'Fetch') {
            return 'fetch';
        }
        return null;
    }
    #getBeforeRequestEvent() {
        assert(this.#request.info, 'RequestWillBeSentEvent is not set');
        return {
            method: ChromiumBidi.Network.EventNames.BeforeRequestSent,
            params: {
                response: this.#getResponseEventParams(),
            },
        };
    }
    #getResponseReceivedEvent() {
        return {
            method: ChromiumBidi.Network.EventNames.ResponseCompleted,
            params: {
                ...this.#getBaseEventParams(),
                response: this.#getResponseEventParams(),
            },
        };
    }
    #isIgnoredEvent() {
        const faviconUrl = '/favicon.ico';
        return (this.#request.paused?.request.url.endsWith(faviconUrl) ??
            this.#request.info?.request.url.endsWith(faviconUrl) ??
            false);
    }
    #getOverrideHeader(headers, cookies) {
        if (!headers && !cookies) {
            return undefined;
        }
        let overrideHeaders = headers;
        const cookieHeader = networkHeaderFromCookieHeaders(cookies);
        if (cookieHeader && !overrideHeaders) {
            overrideHeaders = this.#requestHeaders;
        }
        if (cookieHeader && overrideHeaders) {
            overrideHeaders.filter((header) => header.name.localeCompare('cookie', undefined, {
                sensitivity: 'base',
            }) !== 0);
            overrideHeaders.push(cookieHeader);
        }
        return overrideHeaders;
    }
    static #getInitiator(initiatorType) {
        switch (initiatorType) {
            case 'parser':
            case 'script':
            case 'preflight':
                return initiatorType;
            default:
                return 'other';
        }
    }
}
_a = NetworkRequest;
function getCdpBodyFromBiDiBytesValue(body) {
    let parsedBody;
    if (body?.type === 'string') {
        parsedBody = stringToBase64(body.value);
    }
    else if (body?.type === 'base64') {
        parsedBody = body.value;
    }
    return parsedBody;
}
function getSizeFromBiDiBytesValue(body) {
    if (body?.type === 'string') {
        return body.value.length;
    }
    else if (body?.type === 'base64') {
        return atob(body.value).length;
    }
    return 0;
}

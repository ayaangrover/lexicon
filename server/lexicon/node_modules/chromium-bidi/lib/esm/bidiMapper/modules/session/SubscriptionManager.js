import { ChromiumBidi, InvalidArgumentException, NoSuchFrameException, } from '../../../protocol/protocol.js';
import { uuidv4 } from '../../../utils/uuid.js';
export function cartesianProduct(...a) {
    return a.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, e].flat())));
}
    subscribe(eventNames, contextIds, userContextIds, channel) {
        
        const subscription = {
            id: uuidv4(),
            eventNames: new Set(unrollEvents(eventNames)),
            topLevelTraversableIds: new Set(contextIds.map((contextId) => {
                const topLevelContext = this.#browsingContextStorage.findTopLevelContextId(contextId);
                if (!topLevelContext) {
                    throw new NoSuchFrameException(`Top-level navigable not found for context id ${contextId}`);
                }
                return topLevelContext;
            })),
            userContextIds: new Set(userContextIds),
            channel,
        };
        this.#subscriptions.push(subscription);
        this.#knownSubscriptionIds.add(subscription.id);
        return subscription;
    }
    unsubscribe(inputEventNames, inputContextIds, channel) {
        const eventNames = new Set(unrollEvents(inputEventNames));
        
        this.#browsingContextStorage.verifyContextsList(inputContextIds);
        const topLevelTraversables = new Set(inputContextIds.map((contextId) => {
            const topLevelContext = this.#browsingContextStorage.findTopLevelContextId(contextId);
            if (!topLevelContext) {
                throw new NoSuchFrameException(`Top-level navigable not found for context id ${contextId}`);
            }
            return topLevelContext;
        }));
        const isGlobalUnsubscribe = topLevelTraversables.size === 0;
        const newSubscriptions = [];
        const eventsMatched = new Set();
        const contextsMatched = new Set();
        for (const subscription of this.#subscriptions) {
            
            if (JSON.stringify(subscription.channel) !== JSON.stringify(channel)) {
                newSubscriptions.push(subscription);
                continue;
            }
            
            if (subscription.userContextIds.size !== 0) {
                newSubscriptions.push(subscription);
                continue;
            }
            
            if (intersection(subscription.eventNames, eventNames).size === 0) {
                newSubscriptions.push(subscription);
                continue;
            }
            if (isGlobalUnsubscribe) {
                
                if (subscription.topLevelTraversableIds.size !== 0) {
                    newSubscriptions.push(subscription);
                    continue;
                }
                const subscriptionEventNames = new Set(subscription.eventNames);
                for (const eventName of eventNames) {
                    if (subscriptionEventNames.has(eventName)) {
                        eventsMatched.add(eventName);
                        subscriptionEventNames.delete(eventName);
                    }
                }
                
                if (subscriptionEventNames.size !== 0) {
                    newSubscriptions.push({
                        ...subscription,
                        eventNames: subscriptionEventNames,
                    });
                }
            }
            else {
                
                if (subscription.topLevelTraversableIds.size === 0) {
                    newSubscriptions.push(subscription);
                    continue;
                }
                
                const eventMap = new Map();
                for (const eventName of subscription.eventNames) {
                    eventMap.set(eventName, new Set(subscription.topLevelTraversableIds));
                }
                for (const eventName of eventNames) {
                    const eventContextSet = eventMap.get(eventName);
                    if (!eventContextSet) {
                        continue;
                    }
                    for (const toRemoveId of topLevelTraversables) {
                        if (eventContextSet.has(toRemoveId)) {
                            contextsMatched.add(toRemoveId);
                            eventsMatched.add(eventName);
                            eventContextSet.delete(toRemoveId);
                        }
                    }
                    if (eventContextSet.size === 0) {
                        eventMap.delete(eventName);
                    }
                }
                for (const [eventName, remainingContextIds] of eventMap) {
                    const partialSubscription = {
                        id: subscription.id,
                        channel: subscription.channel,
                        eventNames: new Set([eventName]),
                        topLevelTraversableIds: remainingContextIds,
                        userContextIds: new Set(),
                    };
                    newSubscriptions.push(partialSubscription);
                }
            }
        }
        
        if (!equal(eventsMatched, eventNames)) {
            throw new InvalidArgumentException('No subscription found');
        }
        
        if (!isGlobalUnsubscribe && !equal(contextsMatched, topLevelTraversables)) {
            throw new InvalidArgumentException('No subscription found');
        }
        
        this.#subscriptions = newSubscriptions;
    }
    unsubscribeById(subscriptionIds) {
        const subscriptionIdsSet = new Set(subscriptionIds);
        const unknownIds = difference(subscriptionIdsSet, this.#knownSubscriptionIds);
        if (unknownIds.size !== 0) {
            throw new InvalidArgumentException('No subscription found');
        }
        this.#subscriptions = this.#subscriptions.filter((subscription) => {
            return !subscriptionIdsSet.has(subscription.id);
        });
        this.#knownSubscriptionIds = difference(this.#knownSubscriptionIds, subscriptionIdsSet);
    }
}
function intersection(setA, setB) {
    const result = new Set();
    for (const a of setA) {
        if (setB.has(a)) {
            result.add(a);
        }
    }
    return result;
}
export function difference(setA, setB) {
    const result = new Set();
    for (const a of setA) {
        if (!setB.has(a)) {
            result.add(a);
        }
    }
    return result;
}
function equal(setA, setB) {
    if (setA.size !== setB.size) {
        return false;
    }
    for (const a of setA) {
        if (!setB.has(a)) {
            return false;
        }
    }
    return true;
}

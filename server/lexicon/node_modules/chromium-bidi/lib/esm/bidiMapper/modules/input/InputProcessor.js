import { InvalidArgumentException, NoSuchElementException, UnableToSetFileInputException, NoSuchNodeException, } from '../../../protocol/protocol.js';
import { assert } from '../../../utils/assert.js';
import { ActionDispatcher } from '../input/ActionDispatcher.js';
import { InputStateManager } from '../input/InputStateManager.js';
export class InputProcessor {
    #browsingContextStorage;
    #inputStateManager = new InputStateManager();
    constructor(browsingContextStorage) {
        this.#browsingContextStorage = browsingContextStorage;
    }
    async performActions(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        const inputState = this.#inputStateManager.get(context.top);
        const actionsByTick = this.#getActionsByTick(params, inputState);
        const dispatcher = new ActionDispatcher(inputState, this.#browsingContextStorage, params.context, await ActionDispatcher.isMacOS(context).catch(() => false));
        await dispatcher.dispatchActions(actionsByTick);
        return {};
    }
    async releaseActions(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        const topContext = context.top;
        const inputState = this.#inputStateManager.get(topContext);
        const dispatcher = new ActionDispatcher(inputState, this.#browsingContextStorage, params.context, await ActionDispatcher.isMacOS(context).catch(() => false));
        await dispatcher.dispatchTickActions(inputState.cancelList.reverse());
        this.#inputStateManager.delete(topContext);
        return {};
    }
    async setFiles(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        const realm = await context.getOrCreateSandbox(undefined);
        let result;
        try {
            result = await realm.callFunction(String(function getFiles(fileListLength) {
                if (!(this instanceof HTMLInputElement)) {
                    if (this instanceof Element) {
                }
                if (this.type !== 'file') {
                }
                if (fileListLength > 1 && !this.multiple) {
                    throw new NoSuchElementException(`Could not find element ${params.element.sharedId}`);
                }
                    throw new UnableToSetFileInputException(`Input element ${params.element.sharedId} is not a file type`);
                }
                    throw new UnableToSetFileInputException(`Cannot set multiple files on a non-multiple input element`);
                }
            }
        }
        if (params.files.length === 0) {
            
            
            await realm.callFunction(String(function dispatchEvent() {
                if (this.files?.length === 0) {
                    this.dispatchEvent(new Event('cancel', {
                        bubbles: true,
                    }));
                    return;
                }
                this.files = new DataTransfer().files;
                
                this.dispatchEvent(new Event('input', { bubbles: true, composed: true }));
                this.dispatchEvent(new Event('change', { bubbles: true }));
            }), false, params.element);
            return {};
        }
        
        
        const paths = [];
        for (let i = 0; i < params.files.length; ++i) {
            const result = await realm.callFunction(String(function getFiles(index) {
                return this.files?.item(index);

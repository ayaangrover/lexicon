"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapperCdpConnection = void 0;
const log_js_1 = require("../utils/log.js");
const CdpClient_js_1 = require("./CdpClient.js");
class MapperCdpConnection {
    static LOGGER_PREFIX_RECV = `${log_js_1.LogType.cdp}:RECV ◂`;
    static LOGGER_PREFIX_SEND = `${log_js_1.LogType.cdp}:SEND ▸`;
    #mainBrowserCdpClient;
    #transport;
    #sessionCdpClients = new Map();
    #commandCallbacks = new Map();
    #logger;
    #nextId = 0;
    constructor(transport, logger) {
        this.#transport = transport;
        this.#logger = logger;
        this.#transport.setOnMessage(this.#onMessage);
        
        this.#mainBrowserCdpClient = this.#createCdpClient(undefined);
    }
    getCdpClient(sessionId) {
        const cdpClient = this.#sessionCdpClients.get(sessionId);
        if (!cdpClient) {
            throw new Error(`Unknown CDP session ID: ${sessionId}`);
        }
        return cdpClient;
    }
    sendCommand(method, params, sessionId) {
        return new Promise((resolve, reject) => {
            const id = this.#nextId++;
            this.#commandCallbacks.set(id, {
                sessionId,
                resolve,
                reject,
                error: new CdpClient_js_1.CloseError(`${method} ${JSON.stringify(params)} ${sessionId ?? ''} call rejected because the connection has been closed.`),
            });
            const cdpMessage = { id, method, params };
            if (sessionId) {
                cdpMessage.sessionId = sessionId;
            }
            void this.#transport
                .sendMessage(JSON.stringify(cdpMessage))
                ?.catch((error) => {
                this.#logger?.(log_js_1.LogType.debugError, error);
                this.#transport.close();
            });
            this.#logger?.(_a.LOGGER_PREFIX_SEND, cdpMessage);
        });
    }
    #onMessage = (json) => {
        const message = JSON.parse(json);
        this.#logger?.(_a.LOGGER_PREFIX_RECV, message);
        
        
        if (message.method === 'Target.attachedToTarget') {
            const { sessionId } = message.params;
            this.#createCdpClient(sessionId);
        }
        if (message.id !== undefined) {
            
            const callbacks = this.#commandCallbacks.get(message.id);
            this.#commandCallbacks.delete(message.id);
            if (callbacks) {
                if (message.result) {
                    callbacks.resolve(message.result);
                }
                else if (message.error) {
                    callbacks.reject(message.error);
                }
            }
        }
        else if (message.method) {
            const client = this.#sessionCdpClients.get(message.sessionId ?? undefined);
            client?.emit(message.method, message.params || {});
            
            
            if (message.method === 'Target.detachedFromTarget') {
                const { sessionId } = message.params;
                const client = this.#sessionCdpClients.get(sessionId);
                if (client) {
                    this.#sessionCdpClients.delete(sessionId);
                    client.removeAllListeners();
                }
                
                for (const callback of this.#commandCallbacks.values()) {
                    if (callback.sessionId === sessionId) {
                        callback.reject(callback.error);
                    }
                }
            }
        }
    };
    #createCdpClient(sessionId) {
        const cdpClient = new CdpClient_js_1.MapperCdpClient(this, sessionId);
        this.#sessionCdpClients.set(sessionId, cdpClient);
        return cdpClient;
    }
}
exports.MapperCdpConnection = MapperCdpConnection;
_a = MapperCdpConnection;

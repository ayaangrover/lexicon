"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpCompressedRequest = exports.OpMsgResponse = exports.OpMsgRequest = exports.DocumentSequence = exports.OpReply = exports.OpQueryRequest = void 0;
const BSON = require("../bson");
const error_1 = require("../error");
const compression_1 = require("./wire_protocol/compression");
const constants_1 = require("./wire_protocol/constants");

let _requestId = 0;

const OPTS_TAILABLE_CURSOR = 2;
const OPTS_SECONDARY = 4;
const OPTS_OPLOG_REPLAY = 8;
const OPTS_NO_CURSOR_TIMEOUT = 16;
const OPTS_AWAIT_DATA = 32;
const OPTS_EXHAUST = 64;
const OPTS_PARTIAL = 128;

const CURSOR_NOT_FOUND = 1;
const QUERY_FAILURE = 2;
const SHARD_CONFIG_STALE = 4;
const AWAIT_CAPABLE = 8;
const encodeUTF8Into = BSON.BSON.onDemand.ByteUtils.encodeUTF8Into;
        this.moreToCome = false;
        
        
        const ns = `${databaseName}.$cmd`;
        if (typeof databaseName !== 'string') {
            throw new error_1.MongoRuntimeError('Database name must be a string for a query');
        }
        
        if (query == null)
            throw new error_1.MongoRuntimeError('A query document must be specified for query');
        
        if (ns.indexOf('\x00') !== -1) {
            
            throw new error_1.MongoRuntimeError('Namespace cannot contain a null character');
        }
        
        this.ns = ns;
        
        this.numberToSkip = options.numberToSkip || 0;
        this.numberToReturn = options.numberToReturn || 0;
        this.returnFieldSelector = options.returnFieldSelector || undefined;
        this.requestId = options.requestId ?? OpQueryRequest.getRequestId();
        
        this.pre32Limit = options.pre32Limit;
        
        this.serializeFunctions =
            typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
        this.ignoreUndefined =
            typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;
        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
        this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
        this.batchSize = this.numberToReturn;
        
        this.tailable = false;
        this.secondaryOk = typeof options.secondaryOk === 'boolean' ? options.secondaryOk : false;
        this.oplogReplay = false;
        this.noCursorTimeout = false;
        this.awaitData = false;
        this.exhaust = false;
        this.partial = false;
    }
    nextRequestId() {
        return _requestId + 1;
    }
class OpReply {
    constructor(message, msgHeader, msgBody, opts) {
        this.index = 0;
        this.sections = [];
class DocumentSequence {
    constructor(field, documents) {
        this.field = field;
        this.documents = [];
        this.chunks = [];
        this.serializedDocumentsLength = 0;
        
        
        const buffer = Buffer.allocUnsafe(1 + 4 + this.field.length + 1);
        buffer[0] = 1;
        
        encodeUTF8Into(buffer, `${this.field}\0`, 5);
        this.chunks.push(buffer);
        this.header = buffer;
        if (documents) {
            for (const doc of documents) {
                this.push(doc, BSON.serialize(doc));
            }
        }
    }
    push(document, buffer) {
        this.serializedDocumentsLength += buffer.length;
        
        this.documents.push(document);
        
        this.chunks.push(buffer);
        
        this.header?.writeInt32LE(4 + this.field.length + 1 + this.serializedDocumentsLength, 1);
        return this.serializedDocumentsLength + this.header.length;
    }
    toBin() {
        return Buffer.concat(this.chunks);
    }
}
exports.DocumentSequence = DocumentSequence;
    makeSections(buffers, document) {
        const sequencesBuffer = this.extractDocumentSequences(document);
        const payloadTypeBuffer = Buffer.allocUnsafe(1);
        payloadTypeBuffer[0] = 0;
        const documentBuffer = this.serializeBson(document);
        
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        
        buffers.push(sequencesBuffer);
        return payloadTypeBuffer.length + documentBuffer.length + sequencesBuffer.length;
    }
    extractDocumentSequences(document) {
        
        const chunks = [];
        for (const [key, value] of Object.entries(document)) {
            if (value instanceof DocumentSequence) {
                chunks.push(value.toBin());
                
                
                
                
                
                
                
                delete document[key];
            }
        }
        if (chunks.length > 0) {
            return Buffer.concat(chunks);
        }
        
        
        return Buffer.alloc(0);
    }
    serializeBson(document) {
        return BSON.serialize(document, {
            checkKeys: this.checkKeys,
            serializeFunctions: this.serializeFunctions,
            ignoreUndefined: this.ignoreUndefined
        });
    }
    static getRequestId() {
        _requestId = (_requestId + 1) & 0x7fffffff;
        return _requestId;
    }
}
exports.OpMsgRequest = OpMsgRequest;
class OpCompressedRequest {
    constructor(command, options) {
        this.command = command;
        this.options = options;
    }
    
    
    static canCompress(command) {
        const commandDoc = command instanceof OpMsgRequest ? command.command : command.query;
        const commandName = Object.keys(commandDoc)[0];
        return !compression_1.uncompressibleCommands.has(commandName);
    }
    async toBin() {
        const concatenatedOriginalCommandBuffer = Buffer.concat(this.command.toBin());
        
        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
        
        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
        
        const compressedMessage = await (0, compression_1.compress)(this.options, messageToBeCompressed);
        
        const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); 
        msgHeader.writeInt32LE(this.command.requestId, 4); 
        msgHeader.writeInt32LE(0, 8); 
        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); 
        
        const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0); 
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); 
        compressionDetails.writeUInt8(compression_1.Compressor[this.options.agreedCompressor], 8); 
        return [msgHeader, compressionDetails, compressedMessage];
    }
}
exports.OpCompressedRequest = OpCompressedRequest;

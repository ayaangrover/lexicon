"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallbackWorkflow = exports.AUTOMATED_TIMEOUT_MS = exports.HUMAN_TIMEOUT_MS = void 0;
const promises_1 = require("timers/promises");
const error_1 = require("../../../error");
const utils_1 = require("../../../utils");
const command_builders_1 = require("./command_builders");
exports.AUTOMATED_TIMEOUT_MS = 60000;
const CALLBACK_RESULT_ERROR = 'User provided OIDC callbacks must return a valid object with an accessToken.';
class CallbackWorkflow {
    constructor(cache, callback) {
        this.cache = cache;
        this.callback = this.withLock(callback);
        this.lastExecutionTime = Date.now() - THROTTLE_MS;
    }
    async speculativeAuth(connection, credentials) {
        
        
        
        if (this.cache.hasAccessToken) {
            const accessToken = this.cache.getAccessToken();
            connection.accessToken = accessToken;
            const document = (0, command_builders_1.finishCommandDocument)(accessToken);
            document.db = credentials.source;
            return { speculativeAuthenticate: document };
        }
        return {};
    }
    async reauthenticate(connection, credentials) {
        if (this.cache.hasAccessToken) {
            
            if (connection.accessToken === this.cache.getAccessToken()) {
                
                
                this.cache.removeAccessToken();
                delete connection.accessToken;
            }
            else {
                
                
                
                connection.accessToken = this.cache.getAccessToken();
            }
        }
        await this.execute(connection, credentials);
    }
    async startAuthentication(connection, credentials, response) {
        let result;
        if (response?.speculativeAuthenticate) {
            result = response.speculativeAuthenticate;
        }
        else {
            result = await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.startCommandDocument)(credentials), undefined);
        }
        return result;
    }
    async finishAuthentication(connection, credentials, token, conversationId) {
        await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.finishCommandDocument)(token, conversationId), undefined);
    }
    async executeAndValidateCallback(params) {
        const result = await this.callback(params);
        
        
        if (isCallbackResultInvalid(result)) {
            throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);
        }
        return result;
    }
    withLock(callback) {
        let lock = Promise.resolve();
        return async (params) => {
            
            
            await lock;
            lock = lock
                .catch(() => null)
                .then(async () => {
                const difference = Date.now() - this.lastExecutionTime;
                if (difference <= THROTTLE_MS) {
                    await (0, promises_1.setTimeout)(THROTTLE_MS - difference, { signal: params.timeoutContext });
                }
                this.lastExecutionTime = Date.now();
                return await callback(params);
            });
            return await lock;
        };
    }
}
exports.CallbackWorkflow = CallbackWorkflow;
function isCallbackResultInvalid(tokenResult) {
    if (tokenResult == null || typeof tokenResult !== 'object')
        return true;
    if (!('accessToken' in tokenResult))
        return true;
    return !Object.getOwnPropertyNames(tokenResult).every(prop => RESULT_PROPERTIES.includes(prop));
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildReplaceOneOperation = exports.buildUpdateManyOperation = exports.buildUpdateOneOperation = exports.buildDeleteManyOperation = exports.buildDeleteOneOperation = exports.buildInsertOneOperation = exports.ClientBulkWriteCommandBuilder = void 0;
exports.buildOperation = buildOperation;
const bson_1 = require("../../bson");
const commands_1 = require("../../cmap/commands");
const error_1 = require("../../error");
const utils_1 = require("../../utils");
const MESSAGE_OVERHEAD_BYTES = 1000;
    constructor(models, options, pkFactory) {
        this.models = models;
        this.options = options;
        this.pkFactory = pkFactory ?? utils_1.DEFAULT_PK_FACTORY;
        this.currentModelIndex = 0;
        this.previousModelIndex = 0;
        this.lastOperations = [];
        this.isBatchRetryable = true;
    }
    get errorsOnly() {
        if ('verboseResults' in this.options) {
            return !this.options.verboseResults;
        }
        return true;
    }
    hasNextBatch() {
        return this.currentModelIndex < this.models.length;
    }
    resetBatch() {
        this.currentModelIndex = this.previousModelIndex;
        return true;
    }
    buildBatch(maxMessageSizeBytes, maxWriteBatchSize, maxBsonObjectSize) {
        
        
        this.isBatchRetryable = true;
        let commandLength = 0;
        let currentNamespaceIndex = 0;
        const command = this.baseCommand();
        const namespaces = new Map();
        
        this.previousModelIndex = this.currentModelIndex;
        while (this.currentModelIndex < this.models.length) {
            const model = this.models[this.currentModelIndex];
            const ns = model.namespace;
            const nsIndex = namespaces.get(ns);
            
            if (model.name === 'deleteMany' || model.name === 'updateMany') {
                this.isBatchRetryable = false;
            }
            if (nsIndex != null) {
                
                const operation = buildOperation(model, nsIndex, this.pkFactory);
                let operationBuffer;
                try {
                    operationBuffer = bson_1.BSON.serialize(operation);
                }
                catch (cause) {
                    throw new error_1.MongoInvalidArgumentError(`Could not serialize operation to BSON`, { cause });
                }
                validateBufferSize('ops', operationBuffer, maxBsonObjectSize);
                
                
                
                if (commandLength + operationBuffer.length < maxMessageSizeBytes &&
                    command.ops.documents.length < maxWriteBatchSize) {
                    
                    commandLength = MESSAGE_OVERHEAD_BYTES + command.ops.push(operation, operationBuffer);
                    
                    this.currentModelIndex++;
                }
                else {
                    
                    
                    break;
                }
            }
            else {
                
                
                namespaces.set(ns, currentNamespaceIndex);
                const nsInfo = { ns: ns };
                const operation = buildOperation(model, currentNamespaceIndex, this.pkFactory);
                let nsInfoBuffer;
                let operationBuffer;
                try {
                    nsInfoBuffer = bson_1.BSON.serialize(nsInfo);
                    operationBuffer = bson_1.BSON.serialize(operation);
                }
                catch (cause) {
                    throw new error_1.MongoInvalidArgumentError(`Could not serialize ns info to BSON`, { cause });
                }
                validateBufferSize('nsInfo', nsInfoBuffer, maxBsonObjectSize);
                validateBufferSize('ops', operationBuffer, maxBsonObjectSize);
                
                
                
                
                if (commandLength + nsInfoBuffer.length + operationBuffer.length < maxMessageSizeBytes &&
                    command.ops.documents.length < maxWriteBatchSize) {
                    
                    commandLength =
                        MESSAGE_OVERHEAD_BYTES +
                            command.nsInfo.push(nsInfo, nsInfoBuffer) +
                            command.ops.push(operation, operationBuffer);
                    
                    currentNamespaceIndex++;
                    
                    this.currentModelIndex++;
                }
                else {
                    
                    
                    break;
                }
            }
        }
        
        this.lastOperations = command.ops.documents;
        return command;
    }
    baseCommand() {
        const command = {
            bulkWrite: 1,
            errorsOnly: this.errorsOnly,
            ordered: this.options.ordered ?? true,
            ops: new commands_1.DocumentSequence('ops'),
            nsInfo: new commands_1.DocumentSequence('nsInfo')
        };
        
        if (this.options.bypassDocumentValidation != null) {
            command.bypassDocumentValidation = this.options.bypassDocumentValidation;
        }
        
        if (this.options.let) {
            command.let = this.options.let;
        }
        
        
        if (this.options.comment !== undefined) {
            command.comment = this.options.comment;
        }
        return command;
    }
}
exports.ClientBulkWriteCommandBuilder = ClientBulkWriteCommandBuilder;
function validateBufferSize(name, buffer, maxBsonObjectSize) {
    if (buffer.length > maxBsonObjectSize) {
        throw new error_1.MongoInvalidArgumentError(`Client bulk write operation ${name} of length ${buffer.length} exceeds the max bson object size of ${maxBsonObjectSize}`);
    }
}
const buildInsertOneOperation = (model, index, pkFactory) => {
    const document = {
        insert: index,
        document: model.document
    };
    document.document._id = model.document._id ?? pkFactory.createPk();
    return document;
};
exports.buildInsertOneOperation = buildInsertOneOperation;
const buildDeleteOneOperation = (model, index) => {
    return createDeleteOperation(model, index, false);
};
exports.buildDeleteOneOperation = buildDeleteOneOperation;
const buildDeleteManyOperation = (model, index) => {
    return createDeleteOperation(model, index, true);
};
exports.buildDeleteManyOperation = buildDeleteManyOperation;
function createDeleteOperation(model, index, multi) {
    const document = {
        delete: index,
        multi: multi,
        filter: model.filter
    };
    if (model.hint) {
        document.hint = model.hint;
    }
    if (model.collation) {
        document.collation = model.collation;
    }
    return document;
}
const buildUpdateOneOperation = (model, index) => {
    return createUpdateOperation(model, index, false);
};
exports.buildUpdateOneOperation = buildUpdateOneOperation;
const buildUpdateManyOperation = (model, index) => {
    return createUpdateOperation(model, index, true);
};
exports.buildUpdateManyOperation = buildUpdateManyOperation;
function validateUpdate(update) {
    if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoAPIError('Client bulk write update models must only contain atomic modifiers (start with $) and must not be empty.');
    }
}
function createUpdateOperation(model, index, multi) {
    
    
    
    
    validateUpdate(model.update);
    const document = {
        update: index,
        multi: multi,
        filter: model.filter,
        updateMods: model.update
    };
    if (model.hint) {
        document.hint = model.hint;
    }
    if (model.upsert) {
        document.upsert = model.upsert;
    }
    if (model.arrayFilters) {
        document.arrayFilters = model.arrayFilters;
    }
    if (model.collation) {
        document.collation = model.collation;
    }
    return document;
}
const buildReplaceOneOperation = (model, index) => {
    if ((0, utils_1.hasAtomicOperators)(model.replacement)) {
        throw new error_1.MongoAPIError('Client bulk write replace models must not contain atomic modifiers (start with $) and must not be empty.');
    }
    const document = {
        update: index,
        multi: false,
        filter: model.filter,
        updateMods: model.replacement
    };
    if (model.hint) {
        document.hint = model.hint;
    }
    if (model.upsert) {
        document.upsert = model.upsert;
    }
    if (model.collation) {
        document.collation = model.collation;
    }
    return document;
};
exports.buildReplaceOneOperation = buildReplaceOneOperation;

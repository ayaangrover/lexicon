"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FindCursor = exports.FLAGS = void 0;
const responses_1 = require("../cmap/wire_protocol/responses");
const error_1 = require("../error");
const explain_1 = require("../explain");
const count_1 = require("../operations/count");
const execute_operation_1 = require("../operations/execute_operation");
const find_1 = require("../operations/find");
const sort_1 = require("../sort");
const utils_1 = require("../utils");
class FindCursor extends explain_1.ExplainableCursor {
        this.numReturned = 0;
        this.cursorFilter = filter;
        this.findOptions = options;
        if (options.sort != null) {
            this.findOptions.sort = (0, sort_1.formatSort)(options.sort);
        }
    }
    clone() {
        const clonedOptions = (0, utils_1.mergeOptions)({}, this.findOptions);
        delete clonedOptions.session;
        return new FindCursor(this.client, this.namespace, this.cursorFilter, {
            ...clonedOptions
        });
    }
    map(transform) {
        return super.map(transform);
    }
    async getMore(batchSize) {
        const numReturned = this.numReturned;
        if (numReturned) {
            
            const limit = this.findOptions.limit;
            batchSize =
                limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;
            if (batchSize <= 0) {
                try {
                    await this.close();
                }
                catch (error) {
                    (0, utils_1.squashError)(error);
                    
                    
                    
                    
                    
                    
                    
                    
                }
                return responses_1.CursorResponse.emptyGetMore;
            }
        }
        const response = await super.getMore(batchSize);
        
        this.numReturned = this.numReturned + response.batchSize;
        return response;
    }
    async count(options) {
        (0, utils_1.emitWarningOnce)('cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ');
        if (typeof options === 'boolean') {
            throw new error_1.MongoInvalidArgumentError('Invalid first parameter to count');
        }
        return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this.cursorFilter, {
            ...this.findOptions, 
            ...this.cursorOptions,
            ...options
        }));
    }
    async explain(verbosity, options) {
        const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);
        return (await (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(this.namespace, this.cursorFilter, {
            ...this.findOptions, 
            ...this.cursorOptions,
            ...timeout,
            explain: explain ?? true
        }))).shift(this.deserializationOptions);
    }
    hint(hint) {
        this.throwIfInitialized();
        this.findOptions.hint = hint;
        return this;
    }
    min(min) {
        this.throwIfInitialized();
        this.findOptions.min = min;
        return this;
    }
    max(max) {
        this.throwIfInitialized();
        this.findOptions.max = max;
        return this;
    }
    returnKey(value) {
        this.throwIfInitialized();
        this.findOptions.returnKey = value;
        return this;
    }
    showRecordId(value) {
        this.throwIfInitialized();
        this.findOptions.showRecordId = value;
        return this;
    }
    addQueryModifier(name, value) {
        this.throwIfInitialized();
        if (name[0] !== '$') {
            throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);
        }
        
        const field = name.substr(1);
        
        switch (field) {
            case 'comment':
                this.findOptions.comment = value;
                break;
            case 'explain':
                this.findOptions.explain = value;
                break;
            case 'hint':
                this.findOptions.hint = value;
                break;
            case 'max':
                this.findOptions.max = value;
                break;
            case 'maxTimeMS':
                this.findOptions.maxTimeMS = value;
                break;
            case 'min':
                this.findOptions.min = value;
                break;
            case 'orderby':
                this.findOptions.sort = (0, sort_1.formatSort)(value);
                break;
            case 'query':
                this.cursorFilter = value;
                break;
            case 'returnKey':
                this.findOptions.returnKey = value;
                break;
            case 'showDiskLoc':
                this.findOptions.showRecordId = value;
                break;
            default:
                throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);
        }
        return this;
    }
    comment(value) {
        this.throwIfInitialized();
        this.findOptions.comment = value;
        return this;
    }
    maxAwaitTimeMS(value) {
        this.throwIfInitialized();
        if (typeof value !== 'number') {
            throw new error_1.MongoInvalidArgumentError('Argument for maxAwaitTimeMS must be a number');
        }
        this.findOptions.maxAwaitTimeMS = value;
        return this;
    }
    maxTimeMS(value) {
        this.throwIfInitialized();
        if (typeof value !== 'number') {
            throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');
        }
        this.findOptions.maxTimeMS = value;
        return this;
    }
    project(value) {
        this.throwIfInitialized();
        this.findOptions.projection = value;
        return this;
    }
    sort(sort, direction) {
        this.throwIfInitialized();
        if (this.findOptions.tailable) {
            throw new error_1.MongoTailableCursorError('Tailable cursor does not support sorting');
        }
        this.findOptions.sort = (0, sort_1.formatSort)(sort, direction);
        return this;
    }
    allowDiskUse(allow = true) {
        this.throwIfInitialized();
        if (!this.findOptions.sort) {
            throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
        }
        
        if (!allow) {
            this.findOptions.allowDiskUse = false;
            return this;
        }
        this.findOptions.allowDiskUse = true;
        return this;
    }
    collation(value) {
        this.throwIfInitialized();
        this.findOptions.collation = value;
        return this;
    }
    limit(value) {
        this.throwIfInitialized();
        if (this.findOptions.tailable) {
            throw new error_1.MongoTailableCursorError('Tailable cursor does not support limit');
        }
        if (typeof value !== 'number') {
            throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
        }
        this.findOptions.limit = value;
        return this;
    }
    skip(value) {
        this.throwIfInitialized();
        if (this.findOptions.tailable) {
            throw new error_1.MongoTailableCursorError('Tailable cursor does not support skip');
        }
        if (typeof value !== 'number') {
            throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
        }
        this.findOptions.skip = value;
        return this;
    }
}
exports.FindCursor = FindCursor;

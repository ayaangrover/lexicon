"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregationCursor = void 0;
const error_1 = require("../error");
const explain_1 = require("../explain");
const aggregate_1 = require("../operations/aggregate");
const execute_operation_1 = require("../operations/execute_operation");
const utils_1 = require("../utils");
const abstract_cursor_1 = require("./abstract_cursor");
class AggregationCursor extends explain_1.ExplainableCursor {
    async _initialize(session) {
        const options = {
            ...this.aggregateOptions,
            ...this.cursorOptions,
            session,
            signal: this.signal
        };
        if (options.explain) {
            try {
                (0, explain_1.validateExplainTimeoutOptions)(options, explain_1.Explain.fromOptions(options));
            }
            catch {
                throw new error_1.MongoAPIError('timeoutMS cannot be used with explain when explain is specified in aggregateOptions');
            }
        }
        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, options);
        const response = await (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, this.timeoutContext);
        return { server: aggregateOperation.server, session, response };
    }
    async explain(verbosity, options) {
        const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);
        return (await (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
            ...this.aggregateOptions, 
            ...this.cursorOptions,
            ...timeout,
            explain: explain ?? true
        }))).shift(this.deserializationOptions);
    }
    addStage(stage) {
        this.throwIfInitialized();
        if (this.cursorOptions.timeoutMS != null &&
            this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION &&
            (stage.$out != null || stage.$merge != null)) {
            throw new error_1.MongoAPIError('Cannot use $out or $merge stage with ITERATION timeoutMode');
        }
        this.pipeline.push(stage);
        return this;
    }
    group($group) {
        return this.addStage({ $group });
    }
    match($match) {
        return this.addStage({ $match });
    }
    project($project) {
        return this.addStage({ $project });
    }
    redact($redact) {
        return this.addStage({ $redact });
    }
    sort($sort) {
        return this.addStage({ $sort });
    }
    geoNear($geoNear) {
        return this.addStage({ $geoNear });
    }
}
exports.AggregationCursor = AggregationCursor;

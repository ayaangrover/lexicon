"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LegacyTimeoutContext = exports.CSOTTimeoutContext = exports.TimeoutContext = exports.Timeout = exports.TimeoutError = void 0;
const timers_1 = require("timers");
const error_1 = require("./error");
const utils_1 = require("./utils");
class Timeout extends Promise {
    get remainingTime() {
        if (this.timedOut)
            return 0;
        if (this.duration === 0)
            return Infinity;
        return this.start + this.duration - Math.trunc(performance.now());
    }
    get timeElapsed() {
        return Math.trunc(performance.now()) - this.start;
    }
    clear() {
        (0, timers_1.clearTimeout)(this.id);
        this.id = undefined;
        this.timedOut = false;
        this.cleared = true;
    }
    throwIfExpired() {
        if (this.timedOut) {
            
            
            
            this.then(undefined, utils_1.squashError);
            throw new TimeoutError('Timed out', { duration: this.duration });
        }
    }
    static expires(duration, unref) {
        return new Timeout(undefined, { duration, unref });
    }
    static reject(rejection) {
        return new Timeout(undefined, { duration: 0, unref: true, rejection });
    }
}
exports.Timeout = Timeout;
function isLegacyTimeoutContextOptions(v) {
    return (v != null &&
        typeof v === 'object' &&
        'serverSelectionTimeoutMS' in v &&
        typeof v.serverSelectionTimeoutMS === 'number' &&
        'waitQueueTimeoutMS' in v &&
        typeof v.waitQueueTimeoutMS === 'number');
}
function isCSOTTimeoutContextOptions(v) {
    return (v != null &&
        typeof v === 'object' &&
        'serverSelectionTimeoutMS' in v &&
        typeof v.serverSelectionTimeoutMS === 'number' &&
        'timeoutMS' in v &&
        typeof v.timeoutMS === 'number');
}
class CSOTTimeoutContext extends TimeoutContext {
    constructor(options) {
        super();
        this.minRoundTripTime = 0;
        this.start = Math.trunc(performance.now());
        this.timeoutMS = options.timeoutMS;
        this.serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
        this.socketTimeoutMS = options.socketTimeoutMS;
        this.clearServerSelectionTimeout = false;
    }
    get maxTimeMS() {
        return this.remainingTimeMS - this.minRoundTripTime;
    }
    get remainingTimeMS() {
        const timePassed = Math.trunc(performance.now()) - this.start;
        return this.timeoutMS <= 0 ? Infinity : this.timeoutMS - timePassed;
    }
    csotEnabled() {
        return true;
    }
    get serverSelectionTimeout() {
        
        if (typeof this._serverSelectionTimeout !== 'object' || this._serverSelectionTimeout?.cleared) {
            const { remainingTimeMS, serverSelectionTimeoutMS } = this;
            if (remainingTimeMS <= 0)
                return Timeout.reject(new error_1.MongoOperationTimeoutError(`Timed out in server selection after ${this.timeoutMS}ms`));
            const usingServerSelectionTimeoutMS = serverSelectionTimeoutMS !== 0 &&
                (0, utils_1.csotMin)(remainingTimeMS, serverSelectionTimeoutMS) === serverSelectionTimeoutMS;
            if (usingServerSelectionTimeoutMS) {
                this._serverSelectionTimeout = Timeout.expires(serverSelectionTimeoutMS);
            }
            else {
                if (remainingTimeMS > 0 && Number.isFinite(remainingTimeMS)) {
                    this._serverSelectionTimeout = Timeout.expires(remainingTimeMS);
                }
                else {
                    this._serverSelectionTimeout = null;
                }
            }
        }
        return this._serverSelectionTimeout;
    }
    get connectionCheckoutTimeout() {
        if (typeof this._connectionCheckoutTimeout !== 'object' ||
            this._connectionCheckoutTimeout?.cleared) {
            if (typeof this._serverSelectionTimeout === 'object') {
                
                this._connectionCheckoutTimeout = this._serverSelectionTimeout;
            }
            else {
                throw new error_1.MongoRuntimeError('Unreachable. If you are seeing this error, please file a ticket on the NODE driver project on Jira');
            }
        }
        return this._connectionCheckoutTimeout;
    }
    get timeoutForSocketWrite() {
        const { remainingTimeMS } = this;
        if (!Number.isFinite(remainingTimeMS))
            return null;
        if (remainingTimeMS > 0)
            return Timeout.expires(remainingTimeMS);
        return Timeout.reject(new error_1.MongoOperationTimeoutError('Timed out before socket write'));
    }
    get timeoutForSocketRead() {
        const { remainingTimeMS } = this;
        if (!Number.isFinite(remainingTimeMS))
            return null;
        if (remainingTimeMS > 0)
            return Timeout.expires(remainingTimeMS);
        return Timeout.reject(new error_1.MongoOperationTimeoutError('Timed out before socket read'));
    }
    refresh() {
        this.start = Math.trunc(performance.now());
        this.minRoundTripTime = 0;
        this._serverSelectionTimeout?.clear();
        this._connectionCheckoutTimeout?.clear();
    }
    clear() {
        this._serverSelectionTimeout?.clear();
        this._connectionCheckoutTimeout?.clear();
    }
    getRemainingTimeMSOrThrow(message) {
        const { remainingTimeMS } = this;
        if (remainingTimeMS <= 0)
            throw new error_1.MongoOperationTimeoutError(message ?? `Expired after ${this.timeoutMS}ms`);
        return remainingTimeMS;
    }
    clone() {
        const timeoutContext = new CSOTTimeoutContext({
            timeoutMS: this.timeoutMS,
            serverSelectionTimeoutMS: this.serverSelectionTimeoutMS
        });
        timeoutContext.start = this.start;
        return timeoutContext;
    }
    refreshed() {
        return new CSOTTimeoutContext(this);
    }
    addMaxTimeMSToCommand(command, options) {
        if (options.omitMaxTimeMS)
            return;
        const maxTimeMS = this.remainingTimeMS - this.minRoundTripTime;
        if (maxTimeMS > 0 && Number.isFinite(maxTimeMS))
            command.maxTimeMS = maxTimeMS;
    }
    getSocketTimeoutMS() {
        return 0;
    }
}
exports.CSOTTimeoutContext = CSOTTimeoutContext;

'use strict'

const { PuppeteerExtraPlugin } = require('puppeteer-extra-plugin')

const withUtils = require('../_utils/withUtils')

const STATIC_DATA = require('./staticData.json')

class Plugin extends PuppeteerExtraPlugin {
  constructor(opts = {}) {
    super(opts)
  }

  get name() {
    return 'stealth/evasions/chrome.runtime'
  }

  get defaults() {
    return { runOnInsecureOrigins: false } 
  }

  async onPageCreated(page) {
    await withUtils(page).evaluateOnNewDocument(
      (utils, { opts, STATIC_DATA }) => {
        if (!window.chrome) {
          
          
          Object.defineProperty(window, 'chrome', {
            writable: true,
            enumerable: true,
            configurable: false, 
            value: {} 
          })
        }

        
        const existsAlready = 'runtime' in window.chrome
        
        const isNotSecure = !window.location.protocol.startsWith('https')
        if (existsAlready || (isNotSecure && !opts.runOnInsecureOrigins)) {
          return 
        }

        window.chrome.runtime = {
          
          
          ...STATIC_DATA,
          
          get id() {
            return undefined
          },
          
          connect: null,
          sendMessage: null
        }

        const makeCustomRuntimeErrors = (preamble, method, extensionId) => ({
          NoMatchingSignature: new TypeError(
            preamble + `No matching signature.`
          ),
          MustSpecifyExtensionID: new TypeError(
            preamble +
              `${method} called from a webpage must specify an Extension ID (string) for its first argument.`
          ),
          InvalidExtensionID: new TypeError(
            preamble + `Invalid extension id: '${extensionId}'`
          )
        })

        
        
        const isValidExtensionID = str =>
          str.length === 32 && str.toLowerCase().match(/^[a-p]+$/)

        const connectHandler = {
          apply: function(target, ctx, args) {
            const [extensionId, connectInfo] = args || []

            
            const errorPreamble = `Error in invocation of runtime.connect(optional string extensionId, optional object connectInfo): `
            const Errors = makeCustomRuntimeErrors(
              errorPreamble,
              `chrome.runtime.connect()`,
              extensionId
            )

            
            const noArguments = args.length === 0
            const emptyStringArgument = args.length === 1 && extensionId === ''
            if (noArguments || emptyStringArgument) {
              throw Errors.MustSpecifyExtensionID
            }

            const tooManyArguments = args.length > 2
            const incorrectConnectInfoType =
              connectInfo && typeof connectInfo !== 'object'

            if (tooManyArguments || incorrectConnectInfoType) {
              throw Errors.NoMatchingSignature
            }

            const extensionIdIsString = typeof extensionId === 'string'
            if (extensionIdIsString && extensionId === '') {
              throw Errors.MustSpecifyExtensionID
            }
            if (extensionIdIsString && !isValidExtensionID(extensionId)) {
              throw Errors.InvalidExtensionID
            }

            
            const validateConnectInfo = ci => {
              
              if (args.length > 1) {
                throw Errors.NoMatchingSignature
              }
              
              if (Object.keys(ci).length === 0) {
                throw Errors.MustSpecifyExtensionID
              }
              
              Object.entries(ci).forEach(([k, v]) => {
                const isExpected = ['name', 'includeTlsChannelId'].includes(k)
                if (!isExpected) {
                  throw new TypeError(
                    errorPreamble + `Unexpected property: '${k}'.`
                  )
                }
                const MismatchError = (propName, expected, found) =>
                  TypeError(
                    errorPreamble +
                      `Error at property '${propName}': Invalid type: expected ${expected}, found ${found}.`
                  )
                if (k === 'name' && typeof v !== 'string') {
                  throw MismatchError(k, 'string', typeof v)
                }
                if (k === 'includeTlsChannelId' && typeof v !== 'boolean') {
                  throw MismatchError(k, 'boolean', typeof v)
                }
              })
            }
            if (typeof extensionId === 'object') {
              validateConnectInfo(extensionId)
              throw Errors.MustSpecifyExtensionID
            }

            
            return utils.patchToStringNested(makeConnectResponse())
          }
        }
        utils.mockWithProxy(
          window.chrome.runtime,
          'connect',
          function connect() {},
          connectHandler
        )

        function makeConnectResponse() {
          const onSomething = () => ({
            addListener: function addListener() {},
            dispatch: function dispatch() {},
            hasListener: function hasListener() {},
            hasListeners: function hasListeners() {
              return false
            },
            removeListener: function removeListener() {}
          })

          const response = {
            name: '',
            sender: undefined,
            disconnect: function disconnect() {},
            onDisconnect: onSomething(),
            onMessage: onSomething(),
            postMessage: function postMessage() {
              if (!arguments.length) {
                throw new TypeError(`Insufficient number of arguments.`)
              }
              throw new Error(`Attempting to use a disconnected port object`)
            }
          }
          return response
        }
      },
      {
        opts: this.opts,
        STATIC_DATA
      }
    )
  }
}

module.exports = function(pluginConfig) {
  return new Plugin(pluginConfig)
}

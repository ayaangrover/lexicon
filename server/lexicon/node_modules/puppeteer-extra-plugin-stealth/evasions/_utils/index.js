const utils = {}

utils.init = () => {
  utils.preloadCache()
}

utils.stripProxyFromErrors = (handler = {}) => {
  const newHandler = {
    setPrototypeOf: function (target, proto) {
      if (proto === null)
        throw new TypeError('Cannot convert object to primitive value')
      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {
        throw new TypeError('Cyclic __proto__ value')
      }
      return Reflect.setPrototypeOf(target, proto)
    }
  }
  
  const traps = Object.getOwnPropertyNames(handler)
  traps.forEach(trap => {
    newHandler[trap] = function () {
      try {
        
        return handler[trap].apply(this, arguments || [])
      } catch (err) {
        
        if (!err || !err.stack || !err.stack.includes(`at `)) {
          throw err
        }

        
        
        
        
        

        const stripWithBlacklist = (stack, stripFirstLine = true) => {
          const blacklist = [
            `at Reflect.${trap} `, 
            `at Object.${trap} `, 
            `at Object.newHandler.<computed> [as ${trap}] ` 
          ]
          return (
            err.stack
              .split('\n')
              
              .filter((line, index) => !(index === 1 && stripFirstLine))
              
              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))
              .join('\n')
          )
        }

        const stripWithAnchor = (stack, anchor) => {
          const stackArr = stack.split('\n')
          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` 
          const anchorIndex = stackArr.findIndex(line =>
            line.trim().startsWith(anchor)
          )
          if (anchorIndex === -1) {
            return false 
          }
          
          
          stackArr.splice(1, anchorIndex)
          return stackArr.join('\n')
        }

        
        err.stack = err.stack.replace(
          'at Object.toString (',
          'at Function.toString ('
        )
        if ((err.stack || '').includes('at Function.toString (')) {
          err.stack = stripWithBlacklist(err.stack, false)
          throw err
        }

        
        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)

        throw err 
      }
    }
  })
  return newHandler
}

utils.stripErrorWithAnchor = (err, anchor) => {
  const stackArr = err.stack.split('\n')
  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))
  if (anchorIndex === -1) {
    return err 
  }
  
  
  stackArr.splice(1, anchorIndex)
  err.stack = stackArr.join('\n')
  return err
}

utils.replaceProperty = (obj, propName, descriptorOverrides = {}) => {
  return Object.defineProperty(obj, propName, {
    
    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),
    
    ...descriptorOverrides
  })
}

utils.preloadCache = () => {
  if (utils.cache) {
    return
  }
  utils.cache = {
    
    Reflect: {
      get: Reflect.get.bind(Reflect),
      apply: Reflect.apply.bind(Reflect)
    },
    
    nativeToStringStr: Function.toString + '' 
  }
}

utils.makeNativeString = (name = '') => {
  return utils.cache.nativeToStringStr.replace('toString', name || '')
}

utils.patchToString = (obj, str = '') => {
  const handler = {
    apply: function (target, ctx) {
      
      if (ctx === Function.prototype.toString) {
        return utils.makeNativeString('toString')
      }
      
      if (ctx === obj) {
        
        return str || utils.makeNativeString(obj.name)
      }
      
      
      const hasSameProto = Object.getPrototypeOf(
        Function.prototype.toString
      ).isPrototypeOf(ctx.toString) 
      if (!hasSameProto) {
        
        return ctx.toString()
      }
      return target.call(ctx)
    }
  }

  const toStringProxy = new Proxy(
    Function.prototype.toString,
    utils.stripProxyFromErrors(handler)
  )
  utils.replaceProperty(Function.prototype, 'toString', {
    value: toStringProxy
  })
}

utils.patchToStringNested = (obj = {}) => {
  return utils.execRecursively(obj, ['function'], utils.patchToString)
}

utils.redirectToString = (proxyObj, originalObj) => {
  const handler = {
    apply: function (target, ctx) {
      
      if (ctx === Function.prototype.toString) {
        return utils.makeNativeString('toString')
      }

      
      if (ctx === proxyObj) {
        const fallback = () =>
          originalObj && originalObj.name
            ? utils.makeNativeString(originalObj.name)
            : utils.makeNativeString(proxyObj.name)

        
        return originalObj + '' || fallback()
      }

      if (typeof ctx === 'undefined' || ctx === null) {
        return target.call(ctx)
      }

      
      
      const hasSameProto = Object.getPrototypeOf(
        Function.prototype.toString
      ).isPrototypeOf(ctx.toString) 
      if (!hasSameProto) {
        
        return ctx.toString()
      }

      return target.call(ctx)
    }
  }

  const toStringProxy = new Proxy(
    Function.prototype.toString,
    utils.stripProxyFromErrors(handler)
  )
  utils.replaceProperty(Function.prototype, 'toString', {
    value: toStringProxy
  })
}

utils.replaceWithProxy = (obj, propName, handler) => {
  const originalObj = obj[propName]
  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))

  utils.replaceProperty(obj, propName, { value: proxyObj })
  utils.redirectToString(proxyObj, originalObj)

  return true
}
utils.replaceGetterWithProxy = (obj, propName, handler) => {
  const fn = Object.getOwnPropertyDescriptor(obj, propName).get
  const fnStr = fn.toString() 
  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))

  utils.replaceProperty(obj, propName, { get: proxyObj })
  utils.patchToString(proxyObj, fnStr)

  return true
}

utils.replaceGetterSetter = (obj, propName, handlerGetterSetter) => {
  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)
  const handler = { ...ownPropertyDescriptor }

  if (handlerGetterSetter.get !== undefined) {
    const nativeFn = ownPropertyDescriptor.get
    handler.get = function() {
      return handlerGetterSetter.get.call(this, nativeFn.bind(this))
    }
    utils.redirectToString(handler.get, nativeFn)
  }

  if (handlerGetterSetter.set !== undefined) {
    const nativeFn = ownPropertyDescriptor.set
    handler.set = function(newValue) {
      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))
    }
    utils.redirectToString(handler.set, nativeFn)
  }

  Object.defineProperty(obj, propName, handler)
}

utils.mockWithProxy = (obj, propName, pseudoTarget, handler) => {
  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))

  utils.replaceProperty(obj, propName, { value: proxyObj })
  utils.patchToString(proxyObj)

  return true
}

utils.createProxy = (pseudoTarget, handler) => {
  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))
  utils.patchToString(proxyObj)

  return proxyObj
}

utils.splitObjPath = objPath => ({
  
  objName: objPath.split('.').slice(0, -1).join('.'),
  
  propName: objPath.split('.').slice(-1)[0]
})

utils.replaceObjPathWithProxy = (objPath, handler) => {
  const { objName, propName } = utils.splitObjPath(objPath)
  const obj = eval(objName) 
  return utils.replaceWithProxy(obj, propName, handler)
}

utils.execRecursively = (obj = {}, typeFilter = [], fn) => {
  function recurse(obj) {
    for (const key in obj) {
      if (obj[key] === undefined) {
        continue
      }
      if (obj[key] && typeof obj[key] === 'object') {
        recurse(obj[key])
      } else {
        if (obj[key] && typeFilter.includes(typeof obj[key])) {
          fn.call(this, obj[key])
        }
      }
    }
  }
  recurse(obj)
  return obj
}

utils.stringifyFns = (fnObj = { hello: () => 'world' }) => {
  
  
  function fromEntries(iterable) {
    return [...iterable].reduce((obj, [key, val]) => {
      obj[key] = val
      return obj
    }, {})
  }
  return (Object.fromEntries || fromEntries)(
    Object.entries(fnObj)
      .filter(([key, value]) => typeof value === 'function')
      .map(([key, value]) => [key, value.toString()]) 
  )
}

utils.materializeFns = (fnStrObj = { hello: "() => 'world'" }) => {
  return Object.fromEntries(
    Object.entries(fnStrObj).map(([key, value]) => {
      if (value.startsWith('function')) {
        
        return [key, eval(`() => ${value}`)()] 
      } else {
        
        return [key, eval(value)] 
      }
    })
  )
}


utils.makeHandler = () => ({
  
  getterValue: value => ({
    apply(target, ctx, args) {
      
      
      utils.cache.Reflect.apply(...arguments)
      return value
    }
  })
})

utils.arrayEquals = (array1, array2) => {
  if (array1.length !== array2.length) {
    return false
  }
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false
    }
  }
  return true
}

utils.memoize = fn => {
  const cache = []
  return function(...args) {
    if (!cache.some(c => utils.arrayEquals(c.key, args))) {
      cache.push({ key: args, value: fn.apply(this, args) })
    }
    return cache.find(c => utils.arrayEquals(c.key, args)).value
  }
}




module.exports = utils

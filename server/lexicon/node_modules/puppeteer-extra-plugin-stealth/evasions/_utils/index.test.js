const test = require('ava')

const { vanillaPuppeteer } = require('../../test/util')

const utils = require('.')
const withUtils = require('./withUtils')

    const dummyProxyHandler = {
      get() {
        return utils.cache.Reflect.get(...(arguments || []))
      },
      apply() {
        return utils.cache.Reflect.apply(...arguments)
      }
    }
    const vanillaProxy = new Proxy(
      HTMLMediaElement.prototype.canPlayType,
      dummyProxyHandler
    )
    const stealthProxy = new Proxy(
      HTMLMediaElement.prototype.canPlayType,
      utils.stripProxyFromErrors(dummyProxyHandler)
    )

    const stacks = {
      vanilla: getStack(HTMLMediaElement.prototype.canPlayType),
      vanillaProxy: getStack(vanillaProxy),
      stealthProxy: getStack(stealthProxy)
    }
    return stacks
  })

  
  t.true(results.vanilla.includes(`TypeError: 'caller'`))
  t.false(results.vanilla.includes(`at Object.get`))

  
  t.true(results.vanillaProxy.includes(`TypeError: 'caller'`))
  t.true(results.vanillaProxy.includes(`at Object.get`))

  
  t.true(results.stealthProxy.includes(`TypeError: 'caller'`))
  t.false(results.stealthProxy.includes(`at Object.get`))
})

test('replaceProperty: will work without traces', async t => {
  const browser = await vanillaPuppeteer.launch({ headless: true })
  const page = await browser.newPage()

  const results = await withUtils(page).evaluate(utils => {
    utils.replaceProperty(Object.getPrototypeOf(navigator), 'languages', {
      get: () => ['de-DE']
    })
    return {
      propNames: Object.getOwnPropertyNames(navigator)
    }
  })
  t.false(results.propNames.includes('languages'))
})

test('cache: will prevent leaks through overriding methods', async t => {
  const browser = await vanillaPuppeteer.launch({ headless: true })
  const page = await browser.newPage()

  const results = await withUtils(page).evaluate(utils => {
    const sniffResults = {
      vanilla: false,
      stealth: false
    }

    const vanillaProxy = new Proxy(
      {},
      {
        get() {
          return Reflect.get(...arguments)
        }
      }
    )
    Reflect.get = () => (sniffResults.vanilla = true)
    
    vanillaProxy.foo 

    const stealthProxy = new Proxy(
      {},
      {
        get() {
          return utils.cache.Reflect.get(...arguments) 
        }
      }
    )
    Reflect.get = () => (sniffResults.stealth = true)
    
    stealthProxy.foo 

    return sniffResults
  })

  t.deepEqual(results, {
    vanilla: true,
    stealth: false
  })
})

test('replaceWithProxy: will throw prototype errors', async t => {
  const browser = await vanillaPuppeteer.launch({ headless: true })
  const page = await browser.newPage()
  await page.goto('about:blank')

  const result = await withUtils(page).evaluate(utils => {
    utils.replaceWithProxy(HTMLMediaElement.prototype, 'canPlayType', {})

    const evalErr = (str = '') => {
      try {
        
        return eval(str)
      } catch (err) {
        return err.toString()
      }
    }

    return {
      same: evalErr(
        `Object.setPrototypeOf(HTMLMediaElement.prototype.canPlayType, HTMLMediaElement.prototype.canPlayType) + ""`
      ),
      sameString: evalErr(
        `Object.setPrototypeOf(Function.prototype.toString, Function.prototype.toString) + ""`
      ),
      null: evalErr(
        `Object.setPrototypeOf(Function.prototype.toString, null) + ""`
      ),
      undef: evalErr(
        `Object.setPrototypeOf(Function.prototype.toString, undefined) + ""`
      ),
      none: evalErr(`Object.setPrototypeOf(Function.prototype.toString) + ""`)
    }
  })
  t.deepEqual(result, {
    same: 'TypeError: Cyclic __proto__ value',
    sameString: 'TypeError: Cyclic __proto__ value',
    null: 'TypeError: Cannot convert object to primitive value',
    undef:
      'TypeError: Object prototype may only be an Object or null: undefined',
    none: 'TypeError: Object prototype may only be an Object or null: undefined'
  })
})

test('replaceGetterSetter', async t => {
  const browser = await vanillaPuppeteer.launch({ headless: true })
  const page = await browser.newPage()
  await page.goto('about:blank')

  const results = await withUtils(page).evaluate(utils => {
    const getDetails = a => ({
      href: a.href,
      typeof: typeof a.href,
      in: 'href' in a,
      keys: Object.keys(a),
      
      prototypeKeys: Object.keys(HTMLAnchorElement.prototype),
      getOwnPropertyNames: Object.getOwnPropertyNames(a),
      prototypeGetOwnPropertyNames: Object.getOwnPropertyNames(
        
        HTMLAnchorElement.prototype
      ),
      ownPropertyDescriptor:
        undefined === Object.getOwnPropertyDescriptor(a, 'href'),
      prototypeOwnPropertyDescriptor: Object.getOwnPropertyDescriptor(
        
        HTMLAnchorElement.prototype,
        'href'
      ),
      ownPropertyDescriptors: Object.getOwnPropertyDescriptors(a, 'href'),
      prototypeOwnPropertyDescriptors: Object.getOwnPropertyDescriptors(
        
        HTMLAnchorElement.prototype,
        'href'
      ),
      getToString: Object.getOwnPropertyDescriptor(
        
        HTMLAnchorElement.prototype,
        'href'
      ).get.toString(),
      setToString: Object.getOwnPropertyDescriptor(
        
        HTMLAnchorElement.prototype,
        'href'
      ).set.toString()
    })

    
    const a1 = document.createElement('a')
    a1.href = 'http:
    const details1 = getDetails(a1)

    
    let href = ''
    
    utils.replaceGetterSetter(HTMLAnchorElement.prototype, 'href', {
      get: function() {
        return href
      },
      set: function(newValue) {
        href = newValue
      }
    })

    
    const a2 = document.createElement('a')
    a2.href = 'http:
    const details2 = getDetails(a2)

    return [details1, details2]
  })

  t.deepEqual(results[1], results[0])
})

test('arrayEquals', async t => {
  const browser = await vanillaPuppeteer.launch({ headless: true })
  const page = await browser.newPage()
  await page.goto('about:blank')

  const results = await withUtils(page).evaluate(utils => {
    const obj = { foo: 'bar' }
    return {
      a: utils.arrayEquals(['a', 'Alpha'], ['a', 'Alpha']),
      b: !utils.arrayEquals(['b', 'Beta'], ['b', 'Blue']),
      c: !utils.arrayEquals(['c', { foo: 'bar' }], ['c', { foo: 'bar' }]),
      d: utils.arrayEquals(['d', obj], ['d', obj]),
      e: utils.arrayEquals([null], [null]),
      f: utils.arrayEquals([undefined], [undefined]),
      g: utils.arrayEquals([false], [false])
    }
  })

  t.deepEqual(results, {
    a: true,
    b: true,
    c: true,
    d: true,
    e: true,
    f: true,
    g: true
  })
})

test('memoize', async t => {
  const browser = await vanillaPuppeteer.launch({ headless: true })
  const page = await browser.newPage()
  await page.goto('about:blank')

  const results = await withUtils(page).evaluate(utils => {
    const objectify = utils.memoize((valueAdded, valueIgnored) => {
      return { valueAdded }
    })

    const obj = { foo: 'bar' }
  })

  t.deepEqual(results, {
    a: true,
    b: true,
    c: true,
    d: true,
    e: true,
    f: true,
    g: true
  })
})

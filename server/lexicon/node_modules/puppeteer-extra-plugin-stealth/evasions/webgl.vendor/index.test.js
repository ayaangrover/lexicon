const test = require('ava')

const {
  getVanillaFingerPrint,
  getStealthFingerPrint
} = require('../../test/util')
const { vanillaPuppeteer, addExtra } = require('../../test/util')

const Plugin = require('.')
const { errors } = require('puppeteer')








test('stealth: videoCard is Intel Inc', async t => {
  const pageFn = async page => await page.evaluate(() => window.chrome) 
  const { videoCard } = await getStealthFingerPrint(Plugin, pageFn)
  t.deepEqual(videoCard, ['Intel Inc.', 'Intel Iris OpenGL Engine'])
})

test('stealth: customized values', async t => {
  const pageFn = async page => await page.evaluate(() => window.chrome) 
  const { videoCard } = await getStealthFingerPrint(Plugin, pageFn, {
    vendor: 'foo',
    renderer: 'bar'
  })
  t.deepEqual(videoCard, ['foo', 'bar'])
})

function getVideoCardInfo(context = 'webgl') {
  const gl = document.createElement('canvas').getContext(context)
  if (!gl) {
    return {
      error: 'no webgl'
    }
  }
  const debugInfo = gl.getExtension('WEBGL_debug_renderer_info')
  if (debugInfo) {
    return {
      vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
      renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
    }
  }
  return {
    error: 'no WEBGL_debug_renderer_info'
  }
}

test('stealth: handles WebGLRenderingContext', async t => {
  const puppeteer = addExtra(vanillaPuppeteer).use(Plugin())
  const browser = await puppeteer.launch({ headless: true })
  const page = await browser.newPage()

  const videoCardInfo = await page.evaluate(getVideoCardInfo, 'webgl')
  t.is(videoCardInfo.error, undefined)
  t.is(videoCardInfo.vendor, 'Intel Inc.')
  t.is(videoCardInfo.renderer, 'Intel Iris OpenGL Engine')
})

test('stealth: handles WebGL2RenderingContext', async t => {
  const puppeteer = addExtra(vanillaPuppeteer).use(Plugin())
  const browser = await puppeteer.launch({ headless: true })
  const page = await browser.newPage()

  const videoCardInfo = await page.evaluate(getVideoCardInfo, 'webgl2')
  t.is(videoCardInfo.error, undefined)
  t.is(videoCardInfo.vendor, 'Intel Inc.')
  t.is(videoCardInfo.renderer, 'Intel Iris OpenGL Engine')
})

test('vanilla: normal toString stuff', async t => {
  const browser = await vanillaPuppeteer.launch({ headless: true })
  const page = await browser.newPage()

  const test1 = await page.evaluate(() => {
    return WebGLRenderingContext.prototype.getParameter.toString + ''
  })
  t.is(test1, 'function toString() { [native code] }')

  const test2 = await page.evaluate(() => {
    return WebGLRenderingContext.prototype.getParameter.toString()
  })
  t.is(test2, 'function getParameter() { [native code] }')
})

test('stealth: will not leak toString stuff', async t => {
  const puppeteer = addExtra(vanillaPuppeteer).use(Plugin())
  const browser = await puppeteer.launch({ headless: true })
  const page = await browser.newPage()

  const test1 = await page.evaluate(() => {
    return WebGLRenderingContext.prototype.getParameter.toString + ''
  })
  t.is(test1, 'function toString() { [native code] }') 

  const test2 = await page.evaluate(() => {
    return WebGLRenderingContext.prototype.getParameter.toString()
  })
  t.is(test2, 'function getParameter() { [native code] }')
})

test('stealth: sets user opts correctly', async t => {
  const puppeteer = addExtra(vanillaPuppeteer).use(
    Plugin({ vendor: 'alice', renderer: 'bob' })
  )
  const browser = await puppeteer.launch({ headless: true })
  const page = await browser.newPage()

  const videoCardInfo = await page.evaluate(getVideoCardInfo, 'webgl')
  t.is(videoCardInfo.error, undefined)
  t.is(videoCardInfo.vendor, 'alice')
  t.is(videoCardInfo.renderer, 'bob')
})

test('stealth: does not affect protoype', async t => {
  const puppeteer = addExtra(vanillaPuppeteer).use(
    Plugin({ vendor: 'alice', renderer: 'bob' })
  )
  const browser = await puppeteer.launch({ headless: true })
  const page = await browser.newPage()

  const result = await page.evaluate(() => {
    try {
      return WebGLRenderingContext.prototype.getParameter(37445)
    } catch (err) {
      return err.message
    }
  })
  t.is(result, 'Illegal invocation')
})

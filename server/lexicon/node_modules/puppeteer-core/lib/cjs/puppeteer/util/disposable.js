"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncDisposableStack = exports.DisposableStack = exports.asyncDisposeSymbol = exports.disposeSymbol = void 0;
Symbol.dispose ??= Symbol('dispose');
Symbol.asyncDispose ??= Symbol('asyncDispose');
exports.disposeSymbol = Symbol.dispose;
exports.asyncDisposeSymbol = Symbol.asyncDispose;
class DisposableStack {
    #disposed = false;
    #stack = [];
    get disposed() {
        return this.#disposed;
    }
    dispose() {
        if (this.#disposed) {
            return;
        }
        this.#disposed = true;
        for (const resource of this.#stack.reverse()) {
            resource[exports.disposeSymbol]();
        }
    }
    use(value) {
        if (value) {
            this.#stack.push(value);
        }
        return value;
    }
    adopt(value, onDispose) {
        this.#stack.push({
            [exports.disposeSymbol]() {
                onDispose(value);
            },
        });
        return value;
    }
    defer(onDispose) {
        this.#stack.push({
            [exports.disposeSymbol]() {
                onDispose();
            },
        });
    }
    move() {
        if (this.#disposed) {
            throw new ReferenceError('a disposed stack can not use anything new'); 
        }
        const stack = new DisposableStack(); 
        stack.#stack = this.#stack;
        this.#disposed = true;
        return stack;
    }
    [exports.disposeSymbol] = this.dispose;
    [Symbol.toStringTag] = 'DisposableStack';
}
exports.DisposableStack = DisposableStack;
class AsyncDisposableStack {
    #disposed = false;
    #stack = [];
    get disposed() {
        return this.#disposed;
    }
    async dispose() {
        if (this.#disposed) {
            return;
        }
        this.#disposed = true;
        for (const resource of this.#stack.reverse()) {
            await resource[exports.asyncDisposeSymbol]();
        }
    }
    use(value) {
        if (value) {
            this.#stack.push(value);
        }
        return value;
    }
    adopt(value, onDispose) {
        this.#stack.push({
            [exports.asyncDisposeSymbol]() {
                return onDispose(value);
            },
        });
        return value;
    }
    defer(onDispose) {
        this.#stack.push({
            [exports.asyncDisposeSymbol]() {
                return onDispose();
            },
        });
    }
    move() {
        if (this.#disposed) {
            throw new ReferenceError('a disposed stack can not use anything new'); 
        }
        const stack = new AsyncDisposableStack(); 
        stack.#stack = this.#stack;
        this.#disposed = true;
        return stack;
    }
    [exports.asyncDisposeSymbol] = this.dispose;
    [Symbol.toStringTag] = 'AsyncDisposableStack';
}
exports.AsyncDisposableStack = AsyncDisposableStack;

import { getReadableAsTypedArray, getReadableFromProtocolStream, } from '../common/util.js';
import { assert } from '../util/assert.js';
import { Deferred } from '../util/Deferred.js';
import { isErrorLike } from '../util/ErrorLike.js';
export class Tracing {
    #client;
    #recording = false;
    #path;
    constructor(client) {
        this.#client = client;
    }
    updateClient(client) {
        this.#client = client;
    }
    async start(options = {}) {
        assert(!this.#recording, 'Cannot start recording trace while already recording trace.');
        const defaultCategories = [
            '-*',
            'devtools.timeline',
            'v8.execute',
            'disabled-by-default-devtools.timeline',
            'disabled-by-default-devtools.timeline.frame',
            'toplevel',
            'blink.console',
            'blink.user_timing',
            'latencyInfo',
            'disabled-by-default-devtools.timeline.stack',
            'disabled-by-default-v8.cpu_profiler',
        ];
        const { path, screenshots = false, categories = defaultCategories } = options;
        if (screenshots) {
            categories.push('disabled-by-default-devtools.screenshot');
        }
        const excludedCategories = categories
            .filter(cat => {
            return cat.startsWith('-');
        })
            .map(cat => {
            return cat.slice(1);
        });
        const includedCategories = categories.filter(cat => {
            return !cat.startsWith('-');
        });
        this.#path = path;
        this.#recording = true;
        await this.#client.send('Tracing.start', {
            transferMode: 'ReturnAsStream',
            traceConfig: {
                excludedCategories,
                includedCategories,
            },
        });
    }
    async stop() {
        const contentDeferred = Deferred.create();
        this.#client.once('Tracing.tracingComplete', async (event) => {
            try {
                assert(event.stream, 'Missing "stream"');
                const readable = await getReadableFromProtocolStream(this.#client, event.stream);
                const typedArray = await getReadableAsTypedArray(readable, this.#path);
                contentDeferred.resolve(typedArray ?? undefined);
            }
            catch (error) {
                if (isErrorLike(error)) {
                    contentDeferred.reject(error);
                }
                else {
                    contentDeferred.reject(new Error(`Unknown error: ${error}`));
                }
            }
        });
        await this.#client.send('Tracing.end');
        this.#recording = false;
        return await contentDeferred.valueOrThrow();
    }
}

Symbol.dispose ??= Symbol('dispose');
Symbol.asyncDispose ??= Symbol('asyncDispose');
export const disposeSymbol = Symbol.dispose;
export const asyncDisposeSymbol = Symbol.asyncDispose;
export class DisposableStack {
    #disposed = false;
    #stack = [];
    get disposed() {
        return this.#disposed;
    }
    dispose() {
        if (this.#disposed) {
            return;
        }
        this.#disposed = true;
        for (const resource of this.#stack.reverse()) {
            resource[disposeSymbol]();
        }
    }
    use(value) {
        if (value) {
            this.#stack.push(value);
        }
        return value;
    }
    adopt(value, onDispose) {
        this.#stack.push({
            [disposeSymbol]() {
                onDispose(value);
            },
        });
        return value;
    }
    defer(onDispose) {
        this.#stack.push({
            [disposeSymbol]() {
                onDispose();
            },
        });
    }
    move() {
        if (this.#disposed) {
            throw new ReferenceError('a disposed stack can not use anything new'); 
        }
        const stack = new DisposableStack(); 
        stack.#stack = this.#stack;
        this.#disposed = true;
        return stack;
    }
    [disposeSymbol] = this.dispose;
    [Symbol.toStringTag] = 'DisposableStack';
}
export class AsyncDisposableStack {
    #disposed = false;
    #stack = [];
    get disposed() {
        return this.#disposed;
    }
    async dispose() {
        if (this.#disposed) {
            return;
        }
        this.#disposed = true;
        for (const resource of this.#stack.reverse()) {
            await resource[asyncDisposeSymbol]();
        }
    }
    use(value) {
        if (value) {
            this.#stack.push(value);
        }
        return value;
    }
    adopt(value, onDispose) {
        this.#stack.push({
            [asyncDisposeSymbol]() {
                return onDispose(value);
            },
        });
        return value;
    }
    defer(onDispose) {
        this.#stack.push({
            [asyncDisposeSymbol]() {
                return onDispose();
            },
        });
    }
    move() {
        if (this.#disposed) {
            throw new ReferenceError('a disposed stack can not use anything new'); 
        }
        const stack = new AsyncDisposableStack(); 
        stack.#stack = this.#stack;
        this.#disposed = true;
        return stack;
    }
    [asyncDisposeSymbol] = this.dispose;
    [Symbol.toStringTag] = 'AsyncDisposableStack';
}

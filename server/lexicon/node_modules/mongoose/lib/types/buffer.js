
'use strict';

const Binary = require('bson').Binary;
const utils = require('../utils');


function MongooseBuffer(value, encode, offset) {
  let val = value;
  if (value == null) {
    val = 0;
  }

  let encoding;
  let path;
  let doc;

  if (Array.isArray(encode)) {
    
    path = encode[0];
    doc = encode[1];
  } else {
    encoding = encode;
  }

  let buf;
  if (typeof val === 'number' || val instanceof Number) {
    buf = Buffer.alloc(val);
  } else { 
    buf = Buffer.from(val, encoding, offset);
  }
  utils.decorate(buf, MongooseBuffer.mixin);
  buf.isMongooseBuffer = true;

  
  buf[MongooseBuffer.pathSymbol] = path;
  buf[parentSymbol] = doc;

  buf._subtype = 0;
  return buf;
}

const pathSymbol = Symbol.for('mongoose#Buffer#_path');
const parentSymbol = Symbol.for('mongoose#Buffer#_parent');
MongooseBuffer.pathSymbol = pathSymbol;


MongooseBuffer.mixin = {


  _subtype: undefined,


  _markModified: function() {
    const parent = this[parentSymbol];

    if (parent) {
      parent.markModified(this[MongooseBuffer.pathSymbol]);
    }
    return this;
  },


  write: function() {
    const written = Buffer.prototype.write.apply(this, arguments);

    if (written > 0) {
      this._markModified();
    }

    return written;
  },


  copy: function(target) {
    const ret = Buffer.prototype.copy.apply(this, arguments);

    if (target && target.isMongooseBuffer) {
      target._markModified();
    }

    return ret;
  }
};


utils.each(
  [
    
    'writeUInt8', 'writeUInt16', 'writeUInt32', 'writeInt8', 'writeInt16', 'writeInt32',
    'writeFloat', 'writeDouble', 'fill',
    'utf8Write', 'binaryWrite', 'asciiWrite', 'set',

    
    'writeUInt16LE', 'writeUInt16BE', 'writeUInt32LE', 'writeUInt32BE',
    'writeInt16LE', 'writeInt16BE', 'writeInt32LE', 'writeInt32BE', 'writeFloatLE', 'writeFloatBE', 'writeDoubleLE', 'writeDoubleBE']
  , function(method) {
    if (!Buffer.prototype[method]) {
      return;
    }
    MongooseBuffer.mixin[method] = function() {
      const ret = Buffer.prototype[method].apply(this, arguments);
      this._markModified();
      return ret;
    };
  });


MongooseBuffer.mixin.toObject = function(options) {
  const subtype = typeof options === 'number'
    ? options
    : (this._subtype || 0);
  return new Binary(Buffer.from(this), subtype);
};

MongooseBuffer.mixin.$toObject = MongooseBuffer.mixin.toObject;


MongooseBuffer.mixin.toBSON = function() {
  return new Binary(this, this._subtype || 0);
};


MongooseBuffer.mixin.equals = function(other) {
  if (!Buffer.isBuffer(other)) {
    return false;
  }

  if (this.length !== other.length) {
    return false;
  }

  for (let i = 0; i < this.length; ++i) {
    if (this[i] !== other[i]) {
      return false;
    }
  }

  return true;
};


MongooseBuffer.mixin.subtype = function(subtype) {
  if (typeof subtype !== 'number') {
    throw new TypeError('Invalid subtype. Expected a number');
  }

  if (this._subtype !== subtype) {
    this._markModified();
  }

  this._subtype = subtype;
};


MongooseBuffer.Binary = Binary;

module.exports = MongooseBuffer;

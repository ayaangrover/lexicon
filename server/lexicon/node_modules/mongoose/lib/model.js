'use strict';


const Aggregate = require('./aggregate');
const ChangeStream = require('./cursor/changeStream');
const Document = require('./document');
const DocumentNotFoundError = require('./error/notFound');
const EventEmitter = require('events').EventEmitter;
const Kareem = require('kareem');
const MongooseBulkWriteError = require('./error/bulkWriteError');
const MongooseError = require('./error/index');
const ObjectParameterError = require('./error/objectParameter');
const OverwriteModelError = require('./error/overwriteModel');
const Query = require('./query');
const SaveOptions = require('./options/saveOptions');
const Schema = require('./schema');
const ValidationError = require('./error/validation');
const VersionError = require('./error/version');
const ParallelSaveError = require('./error/parallelSave');
const applyDefaultsHelper = require('./helpers/document/applyDefaults');
const applyDefaultsToPOJO = require('./helpers/model/applyDefaultsToPOJO');
const applyEmbeddedDiscriminators = require('./helpers/discriminator/applyEmbeddedDiscriminators');
const applyHooks = require('./helpers/model/applyHooks');
const applyMethods = require('./helpers/model/applyMethods');
const applyProjection = require('./helpers/projection/applyProjection');
const applyReadConcern = require('./helpers/schema/applyReadConcern');
const applySchemaCollation = require('./helpers/indexes/applySchemaCollation');
const applyStaticHooks = require('./helpers/model/applyStaticHooks');
const applyStatics = require('./helpers/model/applyStatics');
const applyTimestampsHelper = require('./helpers/document/applyTimestamps');
const applyWriteConcern = require('./helpers/schema/applyWriteConcern');
const applyVirtualsHelper = require('./helpers/document/applyVirtuals');
const assignVals = require('./helpers/populate/assignVals');
const castBulkWrite = require('./helpers/model/castBulkWrite');
const clone = require('./helpers/clone');
const createPopulateQueryFilter = require('./helpers/populate/createPopulateQueryFilter');
const decorateUpdateWithVersionKey = require('./helpers/update/decorateUpdateWithVersionKey');
const getDefaultBulkwriteResult = require('./helpers/getDefaultBulkwriteResult');
const getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');
const discriminator = require('./helpers/model/discriminator');
const each = require('./helpers/each');
const get = require('./helpers/get');
const getConstructorName = require('./helpers/getConstructorName');
const getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');
const getModelsMapForPopulate = require('./helpers/populate/getModelsMapForPopulate');
const immediate = require('./helpers/immediate');
const internalToObjectOptions = require('./options').internalToObjectOptions;
const isDefaultIdIndex = require('./helpers/indexes/isDefaultIdIndex');
const isIndexEqual = require('./helpers/indexes/isIndexEqual');
const isTimeseriesIndex = require('./helpers/indexes/isTimeseriesIndex');
const {
  getRelatedDBIndexes,
  getRelatedSchemaIndexes
} = require('./helpers/indexes/getRelatedIndexes');
const decorateDiscriminatorIndexOptions = require('./helpers/indexes/decorateDiscriminatorIndexOptions');
const isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');
const leanPopulateMap = require('./helpers/populate/leanPopulateMap');
const parallelLimit = require('./helpers/parallelLimit');
const prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');
const pushNestedArrayPaths = require('./helpers/model/pushNestedArrayPaths');
const removeDeselectedForeignField = require('./helpers/populate/removeDeselectedForeignField');
const setDottedPath = require('./helpers/path/setDottedPath');
const util = require('util');
const utils = require('./utils');
const minimize = require('./helpers/minimize');
const MongooseBulkSaveIncompleteError = require('./error/bulkSaveIncompleteError');
const ObjectExpectedError = require('./error/objectExpected');
const decorateBulkWriteResult = require('./helpers/model/decorateBulkWriteResult');

const modelCollectionSymbol = Symbol('mongoose#Model#collection');
const modelDbSymbol = Symbol('mongoose#Model#db');
const modelSymbol = require('./helpers/symbols').modelSymbol;
const subclassedSymbol = Symbol('mongoose#Model#subclassed');

const { VERSION_INC, VERSION_WHERE, VERSION_ALL } = Document;

const saveToObjectOptions = Object.assign({}, internalToObjectOptions, {
  bson: true
});


function Model(doc, fields, skipId) {
  if (fields instanceof Schema) {
    throw new TypeError('2nd argument to `Model` constructor must be a POJO or string, ' +
      '**not** a schema. Make sure you\'re calling `mongoose.model()`, not ' +
      '`mongoose.Model()`.');
  }
  if (typeof doc === 'string') {
    throw new TypeError('First argument to `Model` constructor must be an object, ' +
      '**not** a string. Make sure you\'re calling `mongoose.model()`, not ' +
      '`mongoose.Model()`.');
  }
  Document.call(this, doc, fields, skipId);
}


Object.setPrototypeOf(Model.prototype, Document.prototype);
Model.prototype.$isMongooseModelPrototype = true;


Model.prototype.db;


Model.useConnection = function useConnection(connection) {
  if (!connection) {
    throw new Error('Please provide a connection.');
  }
  if (this.db) {
    delete this.db.models[this.modelName];
    delete this.prototype.db;
    delete this.prototype[modelDbSymbol];
    delete this.prototype.collection;
    delete this.prototype.$collection;
    delete this.prototype[modelCollectionSymbol];
  }

  this.db = connection;
  const collection = connection.collection(this.modelName, connection.options);
  this.prototype.collection = collection;
  this.prototype.$collection = collection;
  this.prototype[modelCollectionSymbol] = collection;
  this.prototype.db = connection;
  this.prototype[modelDbSymbol] = connection;
  this.collection = collection;
  this.$__collection = collection;
  connection.models[this.modelName] = this;

  return this;
};


Model.prototype.collection;



Model.prototype.$__collection;


Model.prototype.modelName;


Model.prototype.$where;


Model.prototype.baseModelName;


Model.events;


Model._middleware;


function _applyCustomWhere(doc, where) {
  if (doc.$where == null) {
    return;
  }
  for (const key of Object.keys(doc.$where)) {
    where[key] = doc.$where[key];
  }
}


Model.prototype.$__handleSave = function(options, callback) {
  const saveOptions = {};

  applyWriteConcern(this.$__schema, options);
  if (typeof options.writeConcern !== 'undefined') {
    saveOptions.writeConcern = {};
    if ('w' in options.writeConcern) {
      saveOptions.writeConcern.w = options.writeConcern.w;
    }
    if ('j' in options.writeConcern) {
      saveOptions.writeConcern.j = options.writeConcern.j;
    }
    if ('wtimeout' in options.writeConcern) {
      saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;
    }
  } else {
    if ('w' in options) {
      saveOptions.w = options.w;
    }
    if ('j' in options) {
      saveOptions.j = options.j;
    }
    if ('wtimeout' in options) {
      saveOptions.wtimeout = options.wtimeout;
    }
  }
  if ('checkKeys' in options) {
    saveOptions.checkKeys = options.checkKeys;
  }

  const session = this.$session();
  const asyncLocalStorage = this[modelDbSymbol].base.transactionAsyncLocalStorage?.getStore();
  if (session != null) {
    saveOptions.session = session;
  } else if (!options.hasOwnProperty('session') && asyncLocalStorage?.session != null) {
    
    saveOptions.session = asyncLocalStorage.session;
  }
  if (this.$isNew) {
    
    const obj = this.toObject(saveToObjectOptions);
    if ((obj || {})._id === void 0) {
      
      
      
      
      
      immediate(function() {
        callback(new MongooseError('document must have an _id before saving'));
      });
      return;
    }

    this.$__version(true, obj);
    this[modelCollectionSymbol].insertOne(obj, saveOptions).then(
      ret => callback(null, ret),
      err => {
        _setIsNew(this, true);

        callback(err, null);
      }
    );

    this.$__reset();
    _setIsNew(this, false);
    
    this.$__.inserting = true;
    return;
  }

  
  
  this.$__.inserting = false;
  const delta = this.$__delta();

  if (options.pathsToSave) {
    for (const key in delta[1]['$set']) {
      if (options.pathsToSave.includes(key)) {
        continue;
      } else if (options.pathsToSave.some(pathToSave => key.slice(0, pathToSave.length) === pathToSave && key.charAt(pathToSave.length) === '.')) {
        continue;
      } else {
        delete delta[1]['$set'][key];
      }
    }
  }
  if (delta) {
    if (delta instanceof MongooseError) {
      callback(delta);
      return;
    }

    const where = this.$__where(delta[0]);
    if (where instanceof MongooseError) {
      callback(where);
      return;
    }

    _applyCustomWhere(this, where);

    const update = delta[1];
    if (this.$__schema.options.minimize) {
      for (const updateOp of Object.values(update)) {
        if (updateOp == null) {
          continue;
        }
        for (const key of Object.keys(updateOp)) {
          if (updateOp[key] == null || typeof updateOp[key] !== 'object') {
            continue;
          }
          if (!utils.isPOJO(updateOp[key])) {
            continue;
          }
          minimize(updateOp[key]);
          if (Object.keys(updateOp[key]).length === 0) {
            delete updateOp[key];
            update.$unset = update.$unset || {};
            update.$unset[key] = 1;
          }
        }
      }
    }

    this[modelCollectionSymbol].updateOne(where, update, saveOptions).then(
      ret => {
        if (ret == null) {
          ret = { $where: where };
        } else {
          ret.$where = where;
        }
        callback(null, ret);
      },
      err => {
        this.$__undoReset();

        callback(err);
      }
    );
  } else {
    handleEmptyUpdate.call(this);
    return;
  }

  
  this.$__.modifiedPaths = this.modifiedPaths();
  this.$__reset();

  _setIsNew(this, false);

  function handleEmptyUpdate() {
    const optionsWithCustomValues = Object.assign({}, options, saveOptions);
    const where = this.$__where();
    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
    if (optimisticConcurrency && !Array.isArray(optimisticConcurrency)) {
      const key = this.$__schema.options.versionKey;
      const val = this.$__getValue(key);
      if (val != null) {
        where[key] = val;
      }
    }

    applyReadConcern(this.$__schema, optionsWithCustomValues);
    this.constructor.collection.findOne(where, optionsWithCustomValues)
      .then(documentExists => {
        const matchedCount = !documentExists ? 0 : 1;
        callback(null, { $where: where, matchedCount });
      })
      .catch(callback);
  }
};


Model.prototype.$__save = function(options, callback) {
  this.$__handleSave(options, (error, result) => {
    if (error) {
      error = this.$__schema._transformDuplicateKeyError(error);
      const hooks = this.$__schema.s.hooks;
      return hooks.execPost('save:error', this, [this], { error: error }, (error) => {
        callback(error, this);
      });
    }
    let numAffected = 0;
    const writeConcern = options != null ?
      options.writeConcern != null ?
        options.writeConcern.w :
        options.w :
      0;
    if (writeConcern !== 0) {
      
      
      if (result != null) {
        if (Array.isArray(result)) {
          numAffected = result.length;
        } else if (result.matchedCount != null) {
          numAffected = result.matchedCount;
        } else {
          numAffected = result;
        }
      }

      const versionBump = this.$__.version;
      
      if (versionBump && !this.$__.inserting) {
        const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);
        this.$__.version = undefined;
        const key = this.$__schema.options.versionKey;
        const version = this.$__getValue(key) || 0;
        if (numAffected <= 0) {
          
          this.$__undoReset();
          const err = this.$__.$versionError ||
            new VersionError(this, version, this.$__.modifiedPaths);
          return callback(err);
        }

        
        if (doIncrement) {
          this.$__setValue(key, version + 1);
        }
      }
      if (result != null && numAffected <= 0) {
        this.$__undoReset();
        error = new DocumentNotFoundError(result.$where,
          this.constructor.modelName, numAffected, result);
        const hooks = this.$__schema.s.hooks;
        return hooks.execPost('save:error', this, [this], { error: error }, (error) => {
          callback(error, this);
        });
      }
    }
    this.$__.saving = undefined;
    this.$__.savedState = {};
    this.$emit('save', this, numAffected);
    this.constructor.emit('save', this, numAffected);
    callback(null, this);
  });
};


function generateVersionError(doc, modifiedPaths) {
  const key = doc.$__schema.options.versionKey;
  if (!key) {
    return null;
  }
  const version = doc.$__getValue(key) || 0;
  return new VersionError(doc, version, modifiedPaths);
}


Model.prototype.save = async function save(options) {
  if (typeof options === 'function' || typeof arguments[1] === 'function') {
    throw new MongooseError('Model.prototype.save() no longer accepts a callback');
  }

  let parallelSave;
  this.$op = 'save';

  if (this.$__.saving) {
    parallelSave = new ParallelSaveError(this);
  } else {
    this.$__.saving = new ParallelSaveError(this);
  }

  options = new SaveOptions(options);
  if (options.hasOwnProperty('session')) {
    this.$session(options.session);
  }
  if (this.$__.timestamps != null) {
    options.timestamps = this.$__.timestamps;
  }
  this.$__.$versionError = generateVersionError(this, this.modifiedPaths());

  if (parallelSave) {
    this.$__handleReject(parallelSave);
    throw parallelSave;
  }

  this.$__.saveOptions = options;

  await new Promise((resolve, reject) => {
    this.$__save(options, error => {
      this.$__.saving = null;
      this.$__.saveOptions = null;
      this.$__.$versionError = null;
      this.$op = null;
      if (error != null) {
        this.$__handleReject(error);
        return reject(error);
      }

      resolve();
    });
  });

  return this;
};

Model.prototype.$save = Model.prototype.save;


Model.prototype.$__version = function(where, delta) {
  const key = this.$__schema.options.versionKey;
  if (where === true) {
    
    if (key) {
      setDottedPath(delta, key, 0);
      this.$__setValue(key, 0);
    }
    return;
  }

  if (key === false) {
    return;
  }

  

  
  
  
  

  if (!this.$__isSelected(key)) {
    return;
  }

  
  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
    const value = this.$__getValue(key);
    if (value != null) where[key] = value;
  }

  if (VERSION_INC === (VERSION_INC & this.$__.version)) {
    if (get(delta.$set, key, null) != null) {
      
      
      
      ++delta.$set[key];
    } else {
      delta.$inc = delta.$inc || {};
      delta.$inc[key] = 1;
    }
  }
};


Model.prototype.increment = function increment() {
  this.$__.version = VERSION_ALL;
  return this;
};


Model.prototype.$__where = function _where(where) {
  where || (where = {});

  if (!where._id) {
    where._id = this._doc._id;
  }

  if (this._doc._id === void 0) {
    return new MongooseError('No _id found on document!');
  }

  return where;
};


Model.prototype.deleteOne = function deleteOne(options) {
  if (typeof options === 'function' ||
      typeof arguments[1] === 'function') {
    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');
  }

  if (!options) {
    options = {};
  }

  if (options.hasOwnProperty('session')) {
    this.$session(options.session);
  }

  const self = this;
  const where = this.$__where();
  if (where instanceof Error) {
    throw where;
  }
  const query = self.constructor.deleteOne(where, options);

  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }

  query.pre(function queryPreDeleteOne(cb) {
    self.constructor._middleware.execPre('deleteOne', self, [self], cb);
  });
  query.pre(function callSubdocPreHooks(cb) {
    each(self.$getAllSubdocs(), (subdoc, cb) => {
      subdoc.constructor._middleware.execPre('deleteOne', subdoc, [subdoc], cb);
    }, cb);
  });
  query.pre(function skipIfAlreadyDeleted(cb) {
    if (self.$__.isDeleted) {
      return cb(Kareem.skipWrappedFunction());
    }
    return cb();
  });
  query.post(function callSubdocPostHooks(cb) {
    each(self.$getAllSubdocs(), (subdoc, cb) => {
      subdoc.constructor._middleware.execPost('deleteOne', subdoc, [subdoc], {}, cb);
    }, cb);
  });
  query.post(function queryPostDeleteOne(cb) {
    self.constructor._middleware.execPost('deleteOne', self, [self], {}, cb);
  });

  return query;
};


Model.prototype.$model = function $model(name) {
  if (arguments.length === 0) {
    return this.constructor;
  }
  return this[modelDbSymbol].model(name);
};


Model.prototype.model = Model.prototype.$model;


Model.exists = function exists(filter, options) {
  _checkContext(this, 'exists');
  if (typeof arguments[2] === 'function') {
    throw new MongooseError('Model.exists() no longer accepts a callback');
  }

  const query = this.findOne(filter).
    select({ _id: 1 }).
    lean().
    setOptions(options);

  return query;
};


Model.discriminator = function(name, schema, options) {
  let model;
  if (typeof name === 'function') {
    model = name;
    name = utils.getFunctionName(model);
    if (!(model.prototype instanceof Model)) {
      throw new MongooseError('The provided class ' + name + ' must extend Model');
    }
  }

  options = options || {};
  const value = utils.isPOJO(options) ? options.value : options;
  const clone = typeof options.clone === 'boolean' ? options.clone : true;
  const mergePlugins = typeof options.mergePlugins === 'boolean' ? options.mergePlugins : true;
  const overwriteModels = typeof options.overwriteModels === 'boolean' ? options.overwriteModels : false;

  _checkContext(this, 'discriminator');

  if (utils.isObject(schema) && !schema.instanceOfSchema) {
    schema = new Schema(schema);
  }
  if (schema instanceof Schema && clone) {
    schema = schema.clone();
  }

  schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks, overwriteModels);
  if (this.db.models[name] && !schema.options.overwriteModels && !overwriteModels) {
    throw new OverwriteModelError(name);
  }

  schema.$isRootDiscriminator = true;
  schema.$globalPluginsApplied = true;

  model = this.db.model(model || name, schema, this.$__collection.name);
  this.discriminators[name] = model;
  const d = this.discriminators[name];
  Object.setPrototypeOf(d.prototype, this.prototype);
  Object.defineProperty(d, 'baseModelName', {
    value: this.modelName,
    configurable: true,
    writable: false
  });

  
  applyMethods(d, schema);
  applyStatics(d, schema);

  if (this[subclassedSymbol] != null) {
    for (const submodel of this[subclassedSymbol]) {
      submodel.discriminators = submodel.discriminators || {};
      submodel.discriminators[name] =
        model.__subclass(model.db, schema, submodel.collection.name);
    }
  }

  return d;
};


function _checkContext(ctx, fnName) {
  
  
  if (ctx == null || ctx === global) {
    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +
      'model as `this`. Make sure you are calling `MyModel.' + fnName + '()` ' +
      'where `MyModel` is a Mongoose model.');
  } else if (ctx[modelSymbol] == null) {
    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +
      'model as `this`. Make sure you are not calling ' +
      '`new Model.' + fnName + '()`');
  }
}




for (const i in EventEmitter.prototype) {
  Model[i] = EventEmitter.prototype[i];
}


Model.init = function init() {
  _checkContext(this, 'init');
  if (typeof arguments[0] === 'function') {
    throw new MongooseError('Model.init() no longer accepts a callback');
  }

  this.schema.emit('init', this);

  if (this.$init != null) {
    return this.$init;
  }

  const conn = this.db;
  const _ensureIndexes = async() => {
    const autoIndex = utils.getOption(
      'autoIndex',
      this.schema.options,
      conn.config,
      conn.base.options
    );
    if (!autoIndex) {
      return;
    }
    return await this.ensureIndexes({ _automatic: true });
  };
  const _createSearchIndexes = async() => {
    const autoSearchIndex = utils.getOption(
      'autoSearchIndex',
      this.schema.options,
      conn.config,
      conn.base.options
    );
    if (!autoSearchIndex) {
      return;
    }

    const results = [];
    for (const searchIndex of this.schema._searchIndexes) {
      results.push(await this.createSearchIndex(searchIndex));
    }
    return results;
  };
  const _createCollection = async() => {
    let autoCreate = utils.getOption(
      'autoCreate',
      this.schema.options,
      conn.config
      
      
    );
    if (autoCreate == null) {
      
      await conn._waitForConnect(true);
      autoCreate = utils.getOption(
        'autoCreate',
        this.schema.options,
        conn.config,
        conn.base.options
      );
    }

    if (!autoCreate) {
      return;
    }

    return await this.createCollection();
  };

  this.$init = _createCollection().
    then(() => _ensureIndexes()).
    then(() => _createSearchIndexes());

  const _catch = this.$init.catch;
  const _this = this;
  this.$init.catch = function() {
    _this.$caught = true;
    return _catch.apply(_this.$init, arguments);
  };

  return this.$init;
};



Model.createCollection = async function createCollection(options) {
  _checkContext(this, 'createCollection');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {
    throw new MongooseError('Model.createCollection() no longer accepts a callback');
  }

  const shouldSkip = await new Promise((resolve, reject) => {
    this.hooks.execPre('createCollection', this, [options], (err) => {
      if (err != null) {
        if (err instanceof Kareem.skipWrappedFunction) {
          return resolve(true);
        }
        return reject(err);
      }
      resolve();
    });
  });

  const collectionOptions = this &&
    this.schema &&
    this.schema.options &&
    this.schema.options.collectionOptions;
  if (collectionOptions != null) {
    options = Object.assign({}, collectionOptions, options);
  }

  const schemaCollation = this &&
    this.schema &&
    this.schema.options &&
    this.schema.options.collation;
  if (schemaCollation != null) {
    options = Object.assign({ collation: schemaCollation }, options);
  }
  const capped = this &&
    this.schema &&
    this.schema.options &&
    this.schema.options.capped;
  if (capped != null) {
    if (typeof capped === 'number') {
      options = Object.assign({ capped: true, size: capped }, options);
    } else if (typeof capped === 'object') {
      options = Object.assign({ capped: true }, capped, options);
    }
  }
  const timeseries = this &&
    this.schema &&
    this.schema.options &&
    this.schema.options.timeseries;
  if (timeseries != null) {
    options = Object.assign({ timeseries }, options);
    if (options.expireAfterSeconds != null) {
      
    } else if (options.expires != null) {
      utils.expires(options);
    } else if (this.schema.options.expireAfterSeconds != null) {
      options.expireAfterSeconds = this.schema.options.expireAfterSeconds;
    } else if (this.schema.options.expires != null) {
      options.expires = this.schema.options.expires;
      utils.expires(options);
    }
  }

  const clusteredIndex = this &&
    this.schema &&
    this.schema.options &&
    this.schema.options.clusteredIndex;
  if (clusteredIndex != null) {
    options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);
  }

  try {
    if (!shouldSkip) {
      await this.db.createCollection(this.$__collection.collectionName, options);
    }
  } catch (err) {
    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {
      await new Promise((resolve, reject) => {
        const _opts = { error: err };
        this.hooks.execPost('createCollection', this, [null], _opts, (err) => {
          if (err != null) {
            return reject(err);
          }
          resolve();
        });
      });
    }
  }

  await new Promise((resolve, reject) => {
    this.hooks.execPost('createCollection', this, [this.$__collection], (err) => {
      if (err != null) {
        return reject(err);
      }
      resolve();
    });
  });

  return this.$__collection;
};


Model.syncIndexes = async function syncIndexes(options) {
  _checkContext(this, 'syncIndexes');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {
    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');
  }

  const autoCreate = options?.autoCreate ?? this.schema.options?.autoCreate ?? this.db.config.autoCreate ?? true;

  if (autoCreate) {
    try {
      await this.createCollection();
    } catch (err) {
      if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {
        throw err;
      }
    }
  }

  const diffIndexesResult = await this.diffIndexes({ indexOptionsToCreate: true });
  const dropped = await this.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });
  await this.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });

  return dropped;
};


Model.createSearchIndex = async function createSearchIndex(description) {
  _checkContext(this, 'createSearchIndex');

  return await this.$__collection.createSearchIndex(description);
};


Model.updateSearchIndex = async function updateSearchIndex(name, definition) {
  _checkContext(this, 'updateSearchIndex');

  return await this.$__collection.updateSearchIndex(name, definition);
};


Model.dropSearchIndex = async function dropSearchIndex(name) {
  _checkContext(this, 'dropSearchIndex');

  return await this.$__collection.dropSearchIndex(name);
};


Model.listSearchIndexes = async function listSearchIndexes(options) {
  _checkContext(this, 'listSearchIndexes');

  const cursor = await this.$__collection.listSearchIndexes(options);

  return await cursor.toArray();
};


Model.diffIndexes = async function diffIndexes(options) {
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {
    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');
  }

  const model = this;

  let dbIndexes = await model.listIndexes().catch(err => {
    if (err.codeName == 'NamespaceNotFound') {
      return undefined;
    }
    throw err;
  });
  if (dbIndexes === undefined) {
    dbIndexes = [];
  }
  dbIndexes = getRelatedDBIndexes(model, dbIndexes);

  const schema = model.schema;
  const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());

  const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);
  const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options);

  return { toDrop, toCreate };
};

function getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options) {
  const toCreate = [];
  const indexOptionsToCreate = options?.indexOptionsToCreate ?? false;

  for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {
    let found = false;

    const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));

    for (const index of dbIndexes) {
      if (isDefaultIdIndex(index)) {
        continue;
      }
      if (
        isIndexEqual(schemaIndexKeysObject, options, index) &&
        !toDrop.includes(index.name)
      ) {
        found = true;
        break;
      }
    }

    if (!found) {
      if (indexOptionsToCreate) {
        toCreate.push([schemaIndexKeysObject, schemaIndexOptions]);
      } else {
        toCreate.push(schemaIndexKeysObject);
      }
    }
  }

  return toCreate;
}

function getIndexesToDrop(schema, schemaIndexes, dbIndexes) {
  const toDrop = [];

  for (const dbIndex of dbIndexes) {
    let found = false;
    
    if (isDefaultIdIndex(dbIndex)) {
      continue;
    }
    
    if (isTimeseriesIndex(dbIndex, schema.options)) {
      continue;
    }

    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {
      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));
      applySchemaCollation(schemaIndexKeysObject, options, schema.options);

      if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {
        found = true;
        break;
      }
    }

    if (found) {
      continue;
    }

    toDrop.push(dbIndex.name);
  }

  return toDrop;
}

Model.cleanIndexes = async function cleanIndexes(options) {
  _checkContext(this, 'cleanIndexes');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {
    throw new MongooseError('Model.cleanIndexes() no longer accepts a callback');
  }
  const model = this;

  if (Array.isArray(options && options.toDrop)) {
    const res = await _dropIndexes(options.toDrop, model, options);
    return res;
  }

  const res = await model.diffIndexes();
  return await _dropIndexes(res.toDrop, model, options);
};

async function _dropIndexes(toDrop, model, options) {
  if (toDrop.length === 0) {
    return [];
  }

  const collection = model.$__collection;
  if (options && options.hideIndexes) {
    await Promise.all(toDrop.map(indexName => {
      return model.db.db.command({
        collMod: collection.collectionName,
        index: { name: indexName, hidden: true }
      });
    }));
  } else {
    await Promise.all(toDrop.map(indexName => collection.dropIndex(indexName)));
  }

  return toDrop;
}


Model.listIndexes = async function listIndexes() {
  _checkContext(this, 'listIndexes');
  if (typeof arguments[0] === 'function') {
    throw new MongooseError('Model.listIndexes() no longer accepts a callback');
  }

  if (this.$__collection.buffer) {
    await new Promise(resolve => {
      this.$__collection.addQueue(resolve);
    });
  }

  return this.$__collection.listIndexes().toArray();
};


Model.ensureIndexes = async function ensureIndexes(options) {
  _checkContext(this, 'ensureIndexes');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {
    throw new MongooseError('Model.ensureIndexes() no longer accepts a callback');
  }

  await new Promise((resolve, reject) => {
    _ensureIndexes(this, options, (err) => {
      if (err != null) {
        return reject(err);
      }
      resolve();
    });
  });
};


Model.createIndexes = async function createIndexes(options) {
  _checkContext(this, 'createIndexes');

  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {
    throw new MongooseError('Model.createIndexes() no longer accepts a callback');
  }

  return this.ensureIndexes(options);
};



function _ensureIndexes(model, options, callback) {
  const indexes = Array.isArray(options?.toCreate) ? options.toCreate : model.schema.indexes();
  let indexError;

  options = options || {};
  const done = function(err) {
    if (err && !model.$caught) {
      model.emit('error', err);
    }
    model.emit('index', err || indexError);
    callback && callback(err || indexError);
  };

  for (const index of indexes) {
    if (isDefaultIdIndex(index)) {
      utils.warn('mongoose: Cannot specify a custom index on `_id` for ' +
        'model name "' + model.modelName + '", ' +
        'MongoDB does not allow overwriting the default `_id` index. See ' +
        'https:
    }
  }

  if (!indexes.length) {
    immediate(function() {
      done();
    });
    return;
  }
  
  

  const indexSingleDone = function(err, fields, options, name) {
    model.emit('index-single-done', err, fields, options, name);
  };
  const indexSingleStart = function(fields, options) {
    model.emit('index-single-start', fields, options);
  };

  const baseSchema = model.schema._baseSchema;
  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];

  immediate(function() {
    
    if (options._automatic && !model.collection.collection) {
      model.collection.addQueue(create, []);
    } else {
      create();
    }
  });


  function create() {
    if (options._automatic) {
      if (model.schema.options.autoIndex === false ||
          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {
        return done();
      }
    }

    const index = indexes.shift();
    if (!index) {
      return done();
    }
    if (options._automatic && index[1]._autoIndex === false) {
      return create();
    }

    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {
      return create();
    }

    const indexFields = clone(index[0]);
    const indexOptions = clone(index[1]);

    delete indexOptions._autoIndex;
    decorateDiscriminatorIndexOptions(model.schema, indexOptions);
    applyWriteConcern(model.schema, indexOptions);
    applySchemaCollation(indexFields, indexOptions, model.schema.options);

    indexSingleStart(indexFields, options);

    if ('background' in options) {
      indexOptions.background = options.background;
    }

    
    let promise = null;
    try {
      promise = model.collection.createIndex(indexFields, indexOptions);
    } catch (err) {
      if (!indexError) {
        indexError = err;
      }
      if (!model.$caught) {
        model.emit('error', err);
      }

      indexSingleDone(err, indexFields, indexOptions);
      create();
      return;
    }

    promise.then(
      name => {
        indexSingleDone(null, indexFields, indexOptions, name);
        create();
      },
      err => {
        if (!indexError) {
          indexError = err;
        }
        if (!model.$caught) {
          model.emit('error', err);
        }

        indexSingleDone(err, indexFields, indexOptions);
        create();
      }
    );
  }
}


Model.schema;


Model.db;


Model.collection;

Model.$__collection;


Model.base;


Model.discriminators;

Model.translateAliases = function translateAliases(fields, errorOnDuplicates) {
  _checkContext(this, 'translateAliases');

  const translate = (key, value) => {
    let alias;
    const translated = [];
    const fieldKeys = key.split('.');
    let currentSchema = this.schema;
    for (const i in fieldKeys) {
      const name = fieldKeys[i];
      if (currentSchema && currentSchema.aliases[name]) {
        alias = currentSchema.aliases[name];
        if (errorOnDuplicates && alias in fields) {
          throw new MongooseError(`Provided object has both field "${name}" and its alias "${alias}"`);
        }
        
        translated.push(alias);
      } else {
        alias = name;
        
        translated.push(name);
      }

      
      if (currentSchema && currentSchema.paths[alias]) {
        currentSchema = currentSchema.paths[alias].schema;
      }
      else
        currentSchema = null;
    }

    const translatedKey = translated.join('.');
    if (fields instanceof Map)
      fields.set(translatedKey, value);
    else
      fields[translatedKey] = value;

    if (translatedKey !== key) {
      
      if (fields instanceof Map) {
        
        fields.delete(key);
      } else {
        
        delete fields[key]; 
      }
    }
    return fields;
  };

  if (typeof fields === 'object') {
    
    if (fields instanceof Map) {
      
      for (const field of new Map(fields)) {
        fields = translate(field[0], field[1]);
      }
    } else {
      
      for (const key of Object.keys(fields)) {
        fields = translate(key, fields[key]);
        if (key[0] === '$') {
          if (Array.isArray(fields[key])) {
            for (const i in fields[key]) {
              
              fields[key][i] = this.translateAliases(fields[key][i]);
            }
          } else {
            this.translateAliases(fields[key]);
          }
        }
      }
    }

    return fields;
  } else {
    
    return fields;
  }
};


Model.deleteOne = function deleteOne(conditions, options) {
  _checkContext(this, 'deleteOne');

  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');
  }

  const mq = new this.Query({}, {}, this, this.$__collection);
  mq.setOptions(options);

  return mq.deleteOne(conditions);
};


Model.deleteMany = function deleteMany(conditions, options) {
  _checkContext(this, 'deleteMany');

  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Model.deleteMany() no longer accepts a callback');
  }

  const mq = new this.Query({}, {}, this, this.$__collection);
  mq.setOptions(options);

  return mq.deleteMany(conditions);
};


Model.find = function find(conditions, projection, options) {
  _checkContext(this, 'find');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {
    throw new MongooseError('Model.find() no longer accepts a callback');
  }

  const mq = new this.Query({}, {}, this, this.$__collection);
  mq.select(projection);
  mq.setOptions(options);

  return mq.find(conditions);
};


Model.findById = function findById(id, projection, options) {
  _checkContext(this, 'findById');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Model.findById() no longer accepts a callback');
  }

  if (typeof id === 'undefined') {
    id = null;
  }

  return this.findOne({ _id: id }, projection, options);
};


Model.findOne = function findOne(conditions, projection, options) {
  _checkContext(this, 'findOne');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Model.findOne() no longer accepts a callback');
  }

  const mq = new this.Query({}, {}, this, this.$__collection);
  mq.select(projection);
  mq.setOptions(options);

  return mq.findOne(conditions);
};


Model.estimatedDocumentCount = function estimatedDocumentCount(options) {
  _checkContext(this, 'estimatedDocumentCount');

  const mq = new this.Query({}, {}, this, this.$__collection);

  return mq.estimatedDocumentCount(options);
};


Model.countDocuments = function countDocuments(conditions, options) {
  _checkContext(this, 'countDocuments');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Model.countDocuments() no longer accepts a callback');
  }

  const mq = new this.Query({}, {}, this, this.$__collection);
  if (options != null) {
    mq.setOptions(options);
  }

  return mq.countDocuments(conditions);
};



Model.distinct = function distinct(field, conditions, options) {
  _checkContext(this, 'distinct');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Model.distinct() no longer accepts a callback');
  }

  const mq = new this.Query({}, {}, this, this.$__collection);
  if (options != null) {
    mq.setOptions(options);
  }

  return mq.distinct(field, conditions);
};


Model.where = function where(path, val) {
  _checkContext(this, 'where');

  void val; 
  const mq = new this.Query({}, {}, this, this.$__collection).find({});
  return mq.where.apply(mq, arguments);
};


Model.$where = function $where() {
  _checkContext(this, '$where');

  const mq = new this.Query({}, {}, this, this.$__collection).find({});
  return mq.$where.apply(mq, arguments);
};


Model.findOneAndUpdate = function(conditions, update, options) {
  _checkContext(this, 'findOneAndUpdate');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {
    throw new MongooseError('Model.findOneAndUpdate() no longer accepts a callback');
  }

  if (arguments.length === 1) {
    update = conditions;
    conditions = null;
    options = null;
  }

  let fields;
  if (options) {
    fields = options.fields || options.projection;
  }

  update = clone(update, {
    depopulate: true,
    _isNested: true
  });

  decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);

  const mq = new this.Query({}, {}, this, this.$__collection);
  mq.select(fields);

  return mq.findOneAndUpdate(conditions, update, options);
};


Model.findByIdAndUpdate = function(id, update, options) {
  _checkContext(this, 'findByIdAndUpdate');
  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {
    throw new MongooseError('Model.findByIdAndUpdate() no longer accepts a callback');
  }

  
  if (id instanceof Document) {
    id = id._doc._id;
  }

  return this.findOneAndUpdate.call(this, { _id: id }, update, options);
};


Model.findOneAndDelete = function(conditions, options) {
  _checkContext(this, 'findOneAndDelete');

  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Model.findOneAndDelete() no longer accepts a callback');
  }

  let fields;
  if (options) {
    fields = options.select;
    options.select = undefined;
  }

  const mq = new this.Query({}, {}, this, this.$__collection);
  mq.select(fields);

  return mq.findOneAndDelete(conditions, options);
};


Model.findByIdAndDelete = function(id, options) {
  _checkContext(this, 'findByIdAndDelete');

  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Model.findByIdAndDelete() no longer accepts a callback');
  }

  return this.findOneAndDelete({ _id: id }, options);
};


Model.findOneAndReplace = function(filter, replacement, options) {
  _checkContext(this, 'findOneAndReplace');

  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {
    throw new MongooseError('Model.findOneAndReplace() no longer accepts a callback');
  }

  let fields;
  if (options) {
    fields = options.select;
    options.select = undefined;
  }

  const mq = new this.Query({}, {}, this, this.$__collection);
  mq.select(fields);

  return mq.findOneAndReplace(filter, replacement, options);
};


Model.create = async function create(doc, options) {
  if (typeof options === 'function' ||
      typeof arguments[2] === 'function') {
    throw new MongooseError('Model.create() no longer accepts a callback');
  }

  _checkContext(this, 'create');

  let args;
  const discriminatorKey = this.schema.options.discriminatorKey;

  if (Array.isArray(doc)) {
    args = doc;
    options = options != null && typeof options === 'object' ? options : {};
  } else {
    const last = arguments[arguments.length - 1];
    options = {};
    const hasCallback = typeof last === 'function' ||
      typeof options === 'function' ||
      typeof arguments[2] === 'function';
    if (hasCallback) {
      throw new MongooseError('Model.create() no longer accepts a callback');
    } else {
      args = [...arguments];
      
      
      
      
      if (args.length > 1 && !last) {
        args.pop();
      }
    }

    if (args.length === 2 &&
        args[0] != null &&
        args[1] != null &&
        args[0].session == null &&
        last &&
        getConstructorName(last.session) === 'ClientSession' &&
        !this.schema.path('session')) {
      
      
      utils.warn('WARNING: to pass a `session` to `Model.create()` in ' +
        'Mongoose, you **must** pass an array as the first argument. See: ' +
        'https:
    }
  }

  if (args.length === 0) {
    return Array.isArray(doc) ? [] : null;
  }
  let res = [];
  const immediateError = typeof options.aggregateErrors === 'boolean' ? !options.aggregateErrors : true;

  delete options.aggregateErrors; 

  if (options.session && !options.ordered && args.length > 1) {
    throw new MongooseError('Cannot call `create()` with a session and multiple documents unless `ordered: true` is set');
  }

  if (options.ordered) {
    for (let i = 0; i < args.length; i++) {
      try {
        const doc = args[i];
        const Model = this.discriminators && doc[discriminatorKey] != null ?
          this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :
          this;
        if (Model == null) {
          throw new MongooseError(`Discriminator "${doc[discriminatorKey]}" not ` +
          `found for model "${this.modelName}"`);
        }
        let toSave = doc;
        if (!(toSave instanceof Model)) {
          toSave = new Model(toSave);
        }

        await toSave.$save(options);
        res.push(toSave);
      } catch (err) {
        if (!immediateError) {
          res.push(err);
        } else {
          throw err;
        }
      }
    }
    return res;
  } else if (!immediateError) {
    res = await Promise.allSettled(args.map(async doc => {
      const Model = this.discriminators && doc[discriminatorKey] != null ?
        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :
        this;
      if (Model == null) {
        throw new MongooseError(`Discriminator "${doc[discriminatorKey]}" not ` +
            `found for model "${this.modelName}"`);
      }
      let toSave = doc;

      if (!(toSave instanceof Model)) {
        toSave = new Model(toSave);
      }

      await toSave.$save(options);

      return toSave;
    }));
    res = res.map(result => result.status === 'fulfilled' ? result.value : result.reason);
  } else {
    let firstError = null;
    res = await Promise.all(args.map(async doc => {
      const Model = this.discriminators && doc[discriminatorKey] != null ?
        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :
        this;
      if (Model == null) {
        throw new MongooseError(`Discriminator "${doc[discriminatorKey]}" not ` +
            `found for model "${this.modelName}"`);
      }
      try {
        let toSave = doc;

        if (!(toSave instanceof Model)) {
          toSave = new Model(toSave);
        }

        await toSave.$save(options);

        return toSave;
      } catch (err) {
        if (!firstError) {
          firstError = err;
        }
      }
    }));
    if (firstError) {
      throw firstError;
    }
  }


  if (!Array.isArray(doc) && args.length === 1) {
    return res[0];
  }

  return res;
};


Model.insertOne = async function insertOne(doc, options) {
  _checkContext(this, 'insertOne');

  const discriminatorKey = this.schema.options.discriminatorKey;
  const Model = this.discriminators && doc[discriminatorKey] != null ?
    this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :
    this;
  if (Model == null) {
    throw new MongooseError(
      `Discriminator "${doc[discriminatorKey]}" not found for model "${this.modelName}"`
    );
  }
  if (!(doc instanceof Model)) {
    doc = new Model(doc);
  }

  return await doc.$save(options);
};


Model.watch = function(pipeline, options) {
  _checkContext(this, 'watch');

  const changeStreamThunk = cb => {
    pipeline = pipeline || [];
    prepareDiscriminatorPipeline(pipeline, this.schema, 'fullDocument');
    if (this.$__collection.buffer) {
      this.$__collection.addQueue(() => {
        if (this.closed) {
          return;
        }
        const driverChangeStream = this.$__collection.watch(pipeline, options);
        cb(null, driverChangeStream);
      });
    } else {
      const driverChangeStream = this.$__collection.watch(pipeline, options);
      cb(null, driverChangeStream);
    }
  };

  options = options || {};
  options.model = this;

  return new ChangeStream(changeStreamThunk, pipeline, options);
};


Model.startSession = function() {
  _checkContext(this, 'startSession');

  return this.db.startSession.apply(this.db, arguments);
};


Model.insertMany = async function insertMany(arr, options) {
  _checkContext(this, 'insertMany');
  if (typeof options === 'function' ||
    typeof arguments[2] === 'function') {
    throw new MongooseError('Model.insertMany() no longer accepts a callback');
  }

  return new Promise((resolve, reject) => {
    this.$__insertMany(arr, options, (err, res) => {
      if (err != null) {
        return reject(err);
      }
      resolve(res);
    });
  });
};


Model.$__insertMany = function(arr, options, callback) {
  const _this = this;
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }

  callback = callback || utils.noop;
  options = options || {};
  const limit = options.limit || 1000;
  const rawResult = !!options.rawResult;
  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
  const throwOnValidationError = typeof options.throwOnValidationError === 'boolean' ? options.throwOnValidationError : false;
  const lean = !!options.lean;

  const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();
  if ((!options || !options.hasOwnProperty('session')) && asyncLocalStorage?.session != null) {
    options = { ...options, session: asyncLocalStorage.session };
  }

  if (!Array.isArray(arr)) {
    arr = [arr];
  }

  const validationErrors = [];
  const validationErrorsToOriginalOrder = new Map();
  const results = ordered ? null : new Array(arr.length);
  const toExecute = arr.map((doc, index) =>
    callback => {
      
      if (lean) {
        
        
        
        return immediate(() => callback(null, doc));
      }
      let createdNewDoc = false;
      if (!(doc instanceof _this)) {
        if (doc != null && typeof doc !== 'object') {
          return callback(new ObjectParameterError(doc, 'arr.' + index, 'insertMany'));
        }
        try {
          doc = new _this(doc);
          createdNewDoc = true;
        } catch (err) {
          return callback(err);
        }
      }

      if (options.session != null) {
        doc.$session(options.session);
      }
      
      if (lean) {
        
        
        
        return immediate(() => callback(null, doc));
      }
      doc.$validate(createdNewDoc ? { _skipParallelValidateCheck: true } : null).then(
        () => { callback(null, doc); },
        error => {
          if (ordered === false) {
            validationErrors.push(error);
            validationErrorsToOriginalOrder.set(error, index);
            results[index] = error;
            return callback(null, null);
          }
          callback(error);
        }
      );
    });

  parallelLimit(toExecute, limit, function(error, docs) {
    if (error) {
      callback(error, null);
      return;
    }

    const originalDocIndex = new Map();
    const validDocIndexToOriginalIndex = new Map();
    for (let i = 0; i < docs.length; ++i) {
      originalDocIndex.set(docs[i], i);
    }

    
    const docAttributes = docs.filter(function(doc) {
      return doc != null;
    });
    for (let i = 0; i < docAttributes.length; ++i) {
      validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));
    }

    
    
    
    
    if (validationErrors.length > 0) {
      validationErrors.sort((err1, err2) => {
        return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);
      });
    }

    
    if (docAttributes.length === 0) {
      if (throwOnValidationError) {
        return callback(new MongooseBulkWriteError(
          validationErrors,
          results,
          null,
          'insertMany'
        ));
      }
      if (rawResult) {
        const res = {
          acknowledged: true,
          insertedCount: 0,
          insertedIds: {}
        };
        decorateBulkWriteResult(res, validationErrors, validationErrors);
        return callback(null, res);
      }
      callback(null, []);
      return;
    }
    const docObjects = lean ? docAttributes : docAttributes.map(function(doc) {
      if (doc.$__schema.options.versionKey) {
        doc[doc.$__schema.options.versionKey] = 0;
      }
      const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);
      if (shouldSetTimestamps) {
        doc.initializeTimestamps();
      }
      if (doc.$__hasOnlyPrimitiveValues()) {
        return doc.$__toObjectShallow();
      }
      return doc.toObject(internalToObjectOptions);
    });

    _this.$__collection.insertMany(docObjects, options).then(
      res => {
        if (!lean) {
          for (const attribute of docAttributes) {
            attribute.$__reset();
            _setIsNew(attribute, false);
          }
        }

        if (ordered === false && throwOnValidationError && validationErrors.length > 0) {
          for (let i = 0; i < results.length; ++i) {
            if (results[i] === void 0) {
              results[i] = docs[i];
            }
          }
          return callback(new MongooseBulkWriteError(
            validationErrors,
            results,
            res,
            'insertMany'
          ));
        }

        if (rawResult) {
          if (ordered === false) {
            for (let i = 0; i < results.length; ++i) {
              if (results[i] === void 0) {
                results[i] = docs[i];
              }
            }

            
            
            decorateBulkWriteResult(res, validationErrors, results);
          }
          return callback(null, res);
        }

        if (options.populate != null) {
          return _this.populate(docAttributes, options.populate).then(
            docs => { callback(null, docs); },
            err => {
              if (err != null) {
                err.insertedDocs = docAttributes;
              }
              throw err;
            }
          );
        }

        callback(null, docAttributes);
      },
      error => {
        
        
        if (error.writeErrors == null &&
            (error.result && error.result.result && error.result.result.writeErrors) != null) {
          error.writeErrors = error.result.result.writeErrors;
        }

        
        const hasWriteErrors = error && error.writeErrors;
        const erroredIndexes = new Set((error && error.writeErrors || []).map(err => err.index));

        if (error.writeErrors != null) {
          for (let i = 0; i < error.writeErrors.length; ++i) {
            const originalIndex = validDocIndexToOriginalIndex.get(error.writeErrors[i].index);
            error.writeErrors[i] = { ...error.writeErrors[i], index: originalIndex };
            if (!ordered) {
              results[originalIndex] = error.writeErrors[i];
            }
          }
        }

        if (!ordered) {
          for (let i = 0; i < results.length; ++i) {
            if (results[i] === void 0) {
              results[i] = docs[i];
            }
          }

          error.results = results;
        }

        let firstErroredIndex = -1;
        error.insertedDocs = docAttributes.
          filter((doc, i) => {
            const isErrored = !hasWriteErrors || erroredIndexes.has(i);

            if (ordered) {
              if (firstErroredIndex > -1) {
                return i < firstErroredIndex;
              }

              if (isErrored) {
                firstErroredIndex = i;
              }
            }

            return !isErrored;
          }).
          map(function setIsNewForInsertedDoc(doc) {
            if (lean) {
              return doc;
            }
            doc.$__reset();
            _setIsNew(doc, false);
            return doc;
          });

        if (rawResult && ordered === false) {
          decorateBulkWriteResult(error, validationErrors, results);
        }

        callback(error, null);
      }
    );
  });
};


function _setIsNew(doc, val) {
  doc.$isNew = val;
  doc.$emit('isNew', val);
  doc.constructor.emit('isNew', val);

  const subdocs = doc.$getAllSubdocs({ useCache: true });
  for (const subdoc of subdocs) {
    subdoc.$isNew = val;
    subdoc.$emit('isNew', val);
  }
}


Model.bulkWrite = async function bulkWrite(ops, options) {
  _checkContext(this, 'bulkWrite');

  if (typeof options === 'function' ||
      typeof arguments[2] === 'function') {
    throw new MongooseError('Model.bulkWrite() no longer accepts a callback');
  }
  options = options || {};

  const shouldSkip = await new Promise((resolve, reject) => {
    this.hooks.execPre('bulkWrite', this, [ops, options], (err) => {
      if (err != null) {
        if (err instanceof Kareem.skipWrappedFunction) {
          return resolve(err);
        }
        return reject(err);
      }
      resolve();
    });
  });

  if (shouldSkip) {
    return shouldSkip.args[0];
  }

  const ordered = options.ordered == null ? true : options.ordered;

  if (ops.length === 0) {
    const BulkWriteResult = this.base.driver.get().BulkWriteResult;
    const bulkWriteResult = new BulkWriteResult(getDefaultBulkwriteResult(), false);
    bulkWriteResult.n = 0;
    decorateBulkWriteResult(bulkWriteResult, [], []);
    return bulkWriteResult;
  }

  const validations = ops.map(op => castBulkWrite(this, op, options));
  const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();
  if ((!options || !options.hasOwnProperty('session')) && asyncLocalStorage?.session != null) {
    options = { ...options, session: asyncLocalStorage.session };
  }

  let res = null;
  if (ordered) {
    await new Promise((resolve, reject) => {
      each(validations, (fn, cb) => fn(cb), error => {
        if (error) {
          return reject(error);
        }

        resolve();
      });
    });

    try {
      res = await this.$__collection.bulkWrite(ops, options);
    } catch (error) {
      await new Promise((resolve, reject) => {
        const _opts = { error: error };
        this.hooks.execPost('bulkWrite', this, [null], _opts, (err) => {
          if (err != null) {
            return reject(err);
          }
          resolve();
        });
      });
    }
  } else {
    let remaining = validations.length;
    let validOps = [];
    let validationErrors = [];
    const results = [];
    await new Promise((resolve) => {
      for (let i = 0; i < validations.length; ++i) {
        validations[i]((err) => {
          if (err == null) {
            validOps.push(i);
          } else {
            validationErrors.push({ index: i, error: err });
            results[i] = err;
          }
          if (--remaining <= 0) {
            resolve();
          }
        });
      }
    });

    validationErrors = validationErrors.
      sort((v1, v2) => v1.index - v2.index).
      map(v => v.error);

    const validOpIndexes = validOps;
    validOps = validOps.sort().map(index => ops[index]);

    if (validOps.length === 0) {
      if (options.throwOnValidationError && validationErrors.length) {
        throw new MongooseBulkWriteError(
          validationErrors,
          results,
          res,
          'bulkWrite'
        );
      }
      const BulkWriteResult = this.base.driver.get().BulkWriteResult;
      const bulkWriteResult = new BulkWriteResult(getDefaultBulkwriteResult(), false);
      bulkWriteResult.result = getDefaultBulkwriteResult();
      decorateBulkWriteResult(bulkWriteResult, validationErrors, results);
      return bulkWriteResult;
    }

    let error;
    [res, error] = await this.$__collection.bulkWrite(validOps, options).
      then(res => ([res, null])).
      catch(error => ([null, error]));

    const writeErrorsByIndex = {};
    if (error?.writeErrors) {
      for (const writeError of error.writeErrors) {
        writeErrorsByIndex[writeError.err.index] = writeError;
      }
    }
    for (let i = 0; i < validOpIndexes.length; ++i) {
      results[validOpIndexes[i]] = writeErrorsByIndex[i] ?? null;
    }
    if (error) {
      if (validationErrors.length > 0) {
        decorateBulkWriteResult(error, validationErrors, results);
      }

      await new Promise((resolve, reject) => {
        const _opts = { error: error };
        this.hooks.execPost('bulkWrite', this, [null], _opts, (err) => {
          if (err != null) {
            return reject(err);
          }
          resolve();
        });
      });
    }

    if (validationErrors.length > 0) {
      if (options.throwOnValidationError) {
        throw new MongooseBulkWriteError(
          validationErrors,
          results,
          res,
          'bulkWrite'
        );
      } else {
        decorateBulkWriteResult(res, validationErrors, results);
      }
    }
  }

  await new Promise((resolve, reject) => {
    this.hooks.execPost('bulkWrite', this, [res], (err) => {
      if (err != null) {
        return reject(err);
      }
      resolve();
    });
  });

  return res;
};

Model.bulkSave = async function bulkSave(documents, options) {
  options = options || {};

  if (options.timestamps != null) {
    for (const document of documents) {
      document.$__.saveOptions = document.$__.saveOptions || {};
      document.$__.saveOptions.timestamps = options.timestamps;
    }
  } else {
    for (const document of documents) {
      if (document.$__.timestamps != null) {
        document.$__.saveOptions = document.$__.saveOptions || {};
        document.$__.saveOptions.timestamps = document.$__.timestamps;
      }
    }
  }

  await Promise.all(documents.map(doc => buildPreSavePromise(doc, options)));

  const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true, timestamps: options.timestamps });
  const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, { skipValidation: true, ...options }).then(
    (res) => ({ bulkWriteResult: res, bulkWriteError: null }),
    (err) => ({ bulkWriteResult: null, bulkWriteError: err })
  );
  
  if (bulkWriteError != null && bulkWriteError.name !== 'MongoBulkWriteError') {
    throw bulkWriteError;
  }

  const matchedCount = bulkWriteResult?.matchedCount ?? 0;
  const insertedCount = bulkWriteResult?.insertedCount ?? 0;
  if (writeOperations.length > 0 && matchedCount + insertedCount < writeOperations.length && !bulkWriteError) {
    throw new MongooseBulkSaveIncompleteError(
      this.modelName,
      documents,
      bulkWriteResult
    );
  }

  const successfulDocuments = [];
  for (let i = 0; i < documents.length; i++) {
    const document = documents[i];
    const documentError = bulkWriteError && bulkWriteError.writeErrors.find(writeError => {
      const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;
      return writeErrorDocumentId.toString() === document._doc._id.toString();
    });

    if (documentError == null) {
      successfulDocuments.push(document);
    }
  }
  await Promise.all(successfulDocuments.map(document => handleSuccessfulWrite(document)));

  if (bulkWriteError != null) {
    throw bulkWriteError;
  }

  return bulkWriteResult;
};

function buildPreSavePromise(document, options) {
  return new Promise((resolve, reject) => {
    document.schema.s.hooks.execPre('save', document, [options], (err) => {
      if (err) {
        reject(err);
        return;
      }
      resolve();
    });
  });
}

function handleSuccessfulWrite(document) {
  return new Promise((resolve, reject) => {
    if (document.$isNew) {
      _setIsNew(document, false);
    }

    document.$__reset();
    document.schema.s.hooks.execPost('save', document, [document], {}, (err) => {
      if (err) {
        reject(err);
        return;
      }
      resolve();
    });

  });
}


Model.applyDefaults = function applyDefaults(doc) {
  if (doc == null) {
    return doc;
  }
  if (doc.$__ != null) {
    applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);

    for (const subdoc of doc.$getAllSubdocs()) {
      applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);
    }

    return doc;
  }

  applyDefaultsToPOJO(doc, this.schema);

  return doc;
};


Model.applyVirtuals = function applyVirtuals(obj, virtualsToApply) {
  if (obj == null) {
    return obj;
  }
  
  if (obj.$__ != null) {
    return obj;
  }

  applyVirtualsHelper(this.schema, obj, virtualsToApply);

  return obj;
};


Model.applyTimestamps = function applyTimestamps(obj, options) {
  if (obj == null) {
    return obj;
  }
  
  if (obj.$__ != null) {
    return obj;
  }

  applyTimestampsHelper(this.schema, obj, options);

  return obj;
};


Model.castObject = function castObject(obj, options) {
  options = options || {};
  const ret = {};

  let schema = this.schema;
  const discriminatorKey = schema.options.discriminatorKey;
  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {
    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;
  }
  const paths = Object.keys(schema.paths);

  for (const path of paths) {
    const schemaType = schema.path(path);
    if (!schemaType || !schemaType.$isMongooseArray) {
      continue;
    }

    const val = get(obj, path);
    pushNestedArrayPaths(paths, val, path);
  }

  let error = null;

  for (const path of paths) {
    const schemaType = schema.path(path);
    if (schemaType == null) {
      continue;
    }

    let val = get(obj, path, void 0);

    if (val == null) {
      continue;
    }

    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');
    let cur = ret;
    for (let i = 0; i < pieces.length - 1; ++i) {
      if (cur[pieces[i]] == null) {
        cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];
      }
      cur = cur[pieces[i]];
    }

    if (schemaType.$isMongooseDocumentArray) {
      const castNonArraysOption = schemaType.options?.castNonArrays ?? schemaType.constructor.options.castNonArrays;
      if (!Array.isArray(val)) {
        if (!castNonArraysOption) {
          if (!options.ignoreCastErrors) {
            error = error || new ValidationError();
            error.addError(path, new ObjectExpectedError(path, val));
          }
        } else {
          cur[pieces[pieces.length - 1]] = [
            Model.castObject.call(schemaType.caster, val)
          ];
        }

        continue;
      }
    }
    if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {
      try {
        val = Model.castObject.call(schemaType.caster, val);
      } catch (err) {
        if (!options.ignoreCastErrors) {
          error = error || new ValidationError();
          error.addError(path, err);
        }
        continue;
      }

      cur[pieces[pieces.length - 1]] = val;
      continue;
    }

    try {
      val = schemaType.cast(val);
      cur[pieces[pieces.length - 1]] = val;
    } catch (err) {
      if (!options.ignoreCastErrors) {
        error = error || new ValidationError();
        error.addError(path, err);
      }

      continue;
    }
  }

  if (error != null) {
    throw error;
  }

  return ret;
};


Model.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {
  if (!Array.isArray(documents)) {
    throw new Error(`bulkSave expects an array of documents to be passed, received \`${documents}\` instead`);
  }

  setDefaultOptions();
  const discriminatorKey = this.schema.options.discriminatorKey;

  const writeOperations = documents.reduce((accumulator, document, i) => {
    if (!options.skipValidation) {
      if (!(document instanceof Document)) {
        throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);
      }
      const validationError = document.validateSync();
      if (validationError) {
        throw validationError;
      }
    }

    const isANewDocument = document.isNew;
    if (isANewDocument) {
      const writeOperation = { insertOne: { document } };
      utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);
      accumulator.push(writeOperation);

      return accumulator;
    }

    const delta = document.$__delta();
    const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);

    if (isDocumentWithChanges) {
      const where = document.$__where(delta[0]);
      const changes = delta[1];

      _applyCustomWhere(document, where);

      
      const shardKey = this.schema.options.shardKey;
      if (shardKey) {
        const paths = Object.keys(shardKey);
        const len = paths.length;

        for (let i = 0; i < len; ++i) {
          where[paths[i]] = document[paths[i]];
        }
      }

      
      
      if (document[discriminatorKey] != null && !(discriminatorKey in where)) {
        where[discriminatorKey] = document[discriminatorKey];
      }

      document.$__version(where, delta);
      const writeOperation = { updateOne: { filter: where, update: changes } };
      utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);
      accumulator.push(writeOperation);

      return accumulator;
    }

    return accumulator;
  }, []);

  return writeOperations;


  function setDefaultOptions() {
    options = options || {};
    if (options.skipValidation == null) {
      options.skipValidation = false;
    }
  }
};



Model.hydrate = function(obj, projection, options) {
  _checkContext(this, 'hydrate');

  if (projection != null) {
    if (obj != null && obj.$__ != null) {
      obj = obj.toObject(internalToObjectOptions);
    }
    obj = applyProjection(obj, projection);
  }
  const document = require('./queryHelpers').createModel(this, obj, projection);
  document.$init(obj, options);
  return document;
};


Model.updateMany = function updateMany(conditions, update, options) {
  _checkContext(this, 'updateMany');

  if (update == null) {
    throw new MongooseError('updateMany `update` parameter cannot be nullish');
  }

  return _update(this, 'updateMany', conditions, update, options);
};


Model.updateOne = function updateOne(conditions, doc, options) {
  _checkContext(this, 'updateOne');

  return _update(this, 'updateOne', conditions, doc, options);
};


Model.replaceOne = function replaceOne(conditions, doc, options) {
  _checkContext(this, 'replaceOne');

  const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;
  if (versionKey && !doc[versionKey]) {
    doc[versionKey] = 0;
  }

  return _update(this, 'replaceOne', conditions, doc, options);
};


function _update(model, op, conditions, doc, options) {
  const mq = new model.Query({}, {}, model, model.collection);

  
  
  if (conditions instanceof Document) {
    conditions = conditions.toObject();
  } else {
    conditions = clone(conditions);
  }
  options = typeof options === 'function' ? options : clone(options);

  const versionKey = model &&
  model.schema &&
  model.schema.options &&
  model.schema.options.versionKey || null;
  decorateUpdateWithVersionKey(doc, options, versionKey);

  return mq[op](conditions, doc, options);
}


Model.aggregate = function aggregate(pipeline, options) {
  _checkContext(this, 'aggregate');

  if (typeof options === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Model.aggregate() no longer accepts a callback');
  }

  const aggregate = new Aggregate(pipeline || []);
  aggregate.model(this);
  if (options != null) {
    aggregate.option(options);
  }

  return aggregate;
};


Model.validate = async function validate(obj, pathsOrOptions, context) {
  if ((arguments.length < 3) || (arguments.length === 3 && typeof arguments[2] === 'function')) {
    
    
    context = obj;
  }
  if (typeof context === 'function' || typeof arguments[3] === 'function') {
    throw new MongooseError('Model.validate() no longer accepts a callback');
  }

  let schema = this.schema;
  const discriminatorKey = schema.options.discriminatorKey;
  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {
    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;
  }
  let paths = Object.keys(schema.paths);

  if (pathsOrOptions != null) {
    const _pathsToValidate = typeof pathsOrOptions === 'string' ? new Set(pathsOrOptions.split(' ')) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);
    paths = paths.filter(p => {
      if (pathsOrOptions.pathsToSkip) {
        if (Array.isArray(pathsOrOptions.pathsToSkip)) {
          if (pathsOrOptions.pathsToSkip.find(x => x == p)) {
            return false;
          }
        } else if (typeof pathsOrOptions.pathsToSkip == 'string') {
          if (pathsOrOptions.pathsToSkip.includes(p)) {
            return false;
          }
        }
      }
      const pieces = p.split('.');
      let cur = pieces[0];

      for (const piece of pieces) {
        if (_pathsToValidate.has(cur)) {
          return true;
        }
        cur += '.' + piece;
      }

      return _pathsToValidate.has(p);
    });
  }

  for (const path of paths) {
    const schemaType = schema.path(path);
    if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {
      continue;
    }

    const val = get(obj, path);
    pushNestedArrayPaths(paths, val, path);
  }

  let error = null;
  paths = new Set(paths);

  try {
    obj = this.castObject(obj);
  } catch (err) {
    error = err;
    for (const key of Object.keys(error.errors || {})) {
      paths.delete(key);
    }
  }

  let remaining = paths.size;

  return new Promise((resolve, reject) => {
    for (const path of paths) {
      const schemaType = schema.path(path);
      if (schemaType == null) {
        _checkDone();
        continue;
      }

      const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');
      let cur = obj;
      for (let i = 0; i < pieces.length - 1; ++i) {
        cur = cur[pieces[i]];
      }

      const val = get(obj, path, void 0);

      schemaType.doValidate(val, err => {
        if (err) {
          error = error || new ValidationError();
          error.addError(path, err);
        }
        _checkDone();
      }, context, { path: path });
    }

    function _checkDone() {
      if (--remaining <= 0) {
        if (error) {
          reject(error);
        } else {
          resolve(obj);
        }
      }
    }
  });
};


Model.populate = async function populate(docs, paths) {
  _checkContext(this, 'populate');
  if (typeof paths === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Model.populate() no longer accepts a callback');
  }
  
  paths = utils.populate(paths);

  if (paths.length === 0) {
    return docs;
  }

  
  if (paths.find(p => p.ordered)) {
    
    
    
    for (const path of paths) {
      await _populatePath(this, docs, path);
    }
  } else {
    
    const promises = [];
    for (const path of paths) {
      promises.push(_populatePath(this, docs, path));
    }
    await Promise.all(promises);
  }

  return docs;
};

const excludeIdReg = /\s?-_id\s?/;
const excludeIdRegGlobal = /\s?-_id\s?/g;

async function _populatePath(model, docs, populateOptions) {
  if (populateOptions.strictPopulate == null) {
    if (populateOptions._localModel != null && populateOptions._localModel.schema._userProvidedOptions.strictPopulate != null) {
      populateOptions.strictPopulate = populateOptions._localModel.schema._userProvidedOptions.strictPopulate;
    } else if (populateOptions._localModel != null && model.base.options.strictPopulate != null) {
      populateOptions.strictPopulate = model.base.options.strictPopulate;
    } else if (model.base.options.strictPopulate != null) {
      populateOptions.strictPopulate = model.base.options.strictPopulate;
    }
  }

  
  if (!Array.isArray(docs)) {
    docs = [docs];
  }
  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {
    return;
  }

  const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);
  if (modelsMap instanceof MongooseError) {
    throw modelsMap;
  }
  const len = modelsMap.length;
  let vals = [];

  function flatten(item) {
    
    return undefined !== item;
  }

  let hasOne = false;
  const params = [];
  for (let i = 0; i < len; ++i) {
    const mod = modelsMap[i];
    let select = mod.options.select;
    let ids = utils.array.flatten(mod.ids, flatten);
    ids = utils.array.unique(ids);

    const assignmentOpts = {};
    assignmentOpts.sort = mod &&
      mod.options &&
      mod.options.options &&
      mod.options.options.sort || void 0;
    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);

    
    
    
    if (mod.options &&
        mod.options.options &&
        mod.options.options.lean &&
        mod.options.options.lean.transform) {
      mod.options.options._leanTransform = mod.options.options.lean.transform;
      mod.options.options.lean = true;
    }

    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {
      
      
      
      _assign(model, [], mod, assignmentOpts);
      continue;
    }

    hasOne = true;
    if (typeof populateOptions.foreignField === 'string') {
      mod.foreignField.clear();
      mod.foreignField.add(populateOptions.foreignField);
    }
    const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);
    if (assignmentOpts.excludeId) {
      
      
      
      if (typeof select === 'string') {
        select = select.replace(excludeIdRegGlobal, ' ');
      } else if (Array.isArray(select)) {
        select = select.filter(field => field !== '-_id');
      } else {
        
        select = { ...select };
        delete select._id;
      }
    }

    if (mod.options.options && mod.options.options.limit != null) {
      assignmentOpts.originalLimit = mod.options.options.limit;
    } else if (mod.options.limit != null) {
      assignmentOpts.originalLimit = mod.options.limit;
    }
    params.push([mod, match, select, assignmentOpts]);
  }
  if (!hasOne) {
    
    if (modelsMap.length !== 0) {
      return;
    }
    
    
    if (populateOptions.populate != null) {
      const opts = utils.populate(populateOptions.populate).map(pop => Object.assign({}, pop, {
        path: populateOptions.path + '.' + pop.path
      }));
      return model.populate(docs, opts);
    }
    return;
  }

  if (populateOptions.ordered) {
    
    
    for (const arr of params) {
      await _execPopulateQuery.apply(null, arr).then(valsFromDb => { vals = vals.concat(valsFromDb); });
    }
  } else {
    
    const promises = [];
    for (const arr of params) {
      promises.push(_execPopulateQuery.apply(null, arr).then(valsFromDb => { vals = vals.concat(valsFromDb); }));
    }

    await Promise.all(promises);
  }


  for (const arr of params) {
    const mod = arr[0];
    const assignmentOpts = arr[3];
    for (const val of vals) {
      mod.options._childDocs.push(val);
    }
    _assign(model, vals, mod, assignmentOpts);
  }

  for (const arr of params) {
    removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);
  }
  for (const arr of params) {
    const mod = arr[0];
    if (mod.options && mod.options.options && mod.options.options._leanTransform) {
      for (const doc of vals) {
        mod.options.options._leanTransform(doc);
      }
    }
  }
}


function _execPopulateQuery(mod, match, select) {
  let subPopulate = clone(mod.options.populate);
  const queryOptions = Object.assign({
    skip: mod.options.skip,
    limit: mod.options.limit,
    perDocumentLimit: mod.options.perDocumentLimit
  }, mod.options.options);

  if (mod.count) {
    delete queryOptions.skip;
  }

  if (queryOptions.perDocumentLimit != null) {
    queryOptions.limit = queryOptions.perDocumentLimit;
    delete queryOptions.perDocumentLimit;
  } else if (queryOptions.limit != null) {
    queryOptions.limit = queryOptions.limit * mod.ids.length;
  }

  const query = mod.model.find(match, select, queryOptions);
  
  
  
  
  for (const foreignField of mod.foreignField) {
    if (foreignField !== '_id' &&
        query.selectedInclusively() &&
        !isPathSelectedInclusive(query._fields, foreignField)) {
      query.select(foreignField);
    }
  }

  
  
  if (mod.count) {
    for (const foreignField of mod.foreignField) {
      query.select(foreignField);
    }
  }

  
  if (subPopulate) {
    
    
    if (mod.model.baseModelName != null) {
      if (Array.isArray(subPopulate)) {
        subPopulate.forEach(pop => { pop.strictPopulate = false; });
      } else if (typeof subPopulate === 'string') {
        subPopulate = { path: subPopulate, strictPopulate: false };
      } else {
        subPopulate.strictPopulate = false;
      }
    }
    const basePath = mod.options._fullPath || mod.options.path;

    if (Array.isArray(subPopulate)) {
      for (const pop of subPopulate) {
        pop._fullPath = basePath + '.' + pop.path;
      }
    } else if (typeof subPopulate === 'object') {
      subPopulate._fullPath = basePath + '.' + subPopulate.path;
    }

    query.populate(subPopulate);
  }

  return query.exec().then(
    docs => {
      for (const val of docs) {
        leanPopulateMap.set(val, mod.model);
      }
      return docs;
    }
  );
}


function _assign(model, vals, mod, assignmentOpts) {
  const options = mod.options;
  const isVirtual = mod.isVirtual;
  const justOne = mod.justOne;
  let _val;
  const lean = options &&
    options.options &&
    options.options.lean || false;
  const len = vals.length;
  const rawOrder = {};
  const rawDocs = {};
  let key;
  let val;

  
  const allIds = clone(mod.allIds);
  
  
  
  for (let i = 0; i < len; i++) {
    val = vals[i];
    if (val == null) {
      continue;
    }
    for (const foreignField of mod.foreignField) {
      _val = utils.getValue(foreignField, val);
      if (Array.isArray(_val)) {
        _val = utils.array.unique(utils.array.flatten(_val));

        for (let __val of _val) {
          if (__val instanceof Document) {
            __val = __val._doc._id;
          }
          key = String(__val);
          if (rawDocs[key]) {
            if (Array.isArray(rawDocs[key])) {
              rawDocs[key].push(val);
              rawOrder[key].push(i);
            } else {
              rawDocs[key] = [rawDocs[key], val];
              rawOrder[key] = [rawOrder[key], i];
            }
          } else {
            if (isVirtual && !justOne) {
              rawDocs[key] = [val];
              rawOrder[key] = [i];
            } else {
              rawDocs[key] = val;
              rawOrder[key] = i;
            }
          }
        }
      } else {
        if (_val instanceof Document) {
          _val = _val._doc._id;
        }
        key = String(_val);
        if (rawDocs[key]) {
          if (Array.isArray(rawDocs[key])) {
            rawDocs[key].push(val);
            rawOrder[key].push(i);
          } else if (isVirtual ||
            rawDocs[key].constructor !== val.constructor ||
            (rawDocs[key] instanceof Document ? String(rawDocs[key]._doc._id) : String(rawDocs[key]._id)) !== (val instanceof Document ? String(val._doc._id) : String(val._id))) {
            
            
            
            rawDocs[key] = [rawDocs[key], val];
            rawOrder[key] = [rawOrder[key], i];
          }
        } else {
          rawDocs[key] = val;
          rawOrder[key] = i;
        }
      }
      
      if (!lean) {
        val.$__.wasPopulated = val.$__.wasPopulated || { value: _val };
      }
    }
  }

  assignVals({
    originalModel: model,
    
    rawIds: mod.isVirtual ? allIds : mod.allIds,
    allIds: allIds,
    unpopulatedValues: mod.unpopulatedValues,
    foreignField: mod.foreignField,
    rawDocs: rawDocs,
    rawOrder: rawOrder,
    docs: mod.docs,
    path: options.path,
    options: assignmentOpts,
    justOne: mod.justOne,
    isVirtual: mod.isVirtual,
    allOptions: mod,
    populatedModel: mod.model,
    lean: lean,
    virtual: mod.virtual,
    count: mod.count,
    match: mod.match
  });
}


Model.compile = function compile(name, schema, collectionName, connection, base) {
  const versioningEnabled = schema.options.versionKey !== false;

  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
    
    const o = {};
    o[schema.options.versionKey] = Number;
    schema.add(o);
  }
  let model;
  if (typeof name === 'function' && name.prototype instanceof Model) {
    model = name;
    name = model.name;
    schema.loadClass(model, false);
    model.prototype.$isMongooseModelPrototype = true;
  } else {
    
    model = function model(doc, fields, skipId) {
      model.hooks.execPreSync('createModel', doc);
      if (!(this instanceof model)) {
        return new model(doc, fields, skipId);
      }
      const discriminatorKey = model.schema.options.discriminatorKey;

      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {
        Model.call(this, doc, fields, skipId);
        return;
      }

      
      const Discriminator = model.discriminators[doc[discriminatorKey]] ||
        getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);
      if (Discriminator != null) {
        return new Discriminator(doc, fields, skipId);
      }

      
      Model.call(this, doc, fields, skipId);
    };
  }

  model.hooks = schema.s.hooks.clone();
  model.base = base;
  model.modelName = name;

  if (!(model.prototype instanceof Model)) {
    Object.setPrototypeOf(model, Model);
    Object.setPrototypeOf(model.prototype, Model.prototype);
  }
  model.model = function model(name) {
    return this.db.model(name);
  };

  model.db = connection;
  model.prototype.db = connection;
  model.prototype[modelDbSymbol] = connection;
  model.discriminators = model.prototype.discriminators = undefined;
  model[modelSymbol] = true;
  model.events = new EventEmitter();

  schema._preCompile();

  const _userProvidedOptions = schema._userProvidedOptions || {};

  const collectionOptions = {
    schemaUserProvidedOptions: _userProvidedOptions,
    capped: schema.options.capped,
    Promise: model.base.Promise,
    modelName: name
  };
  if (schema.options.autoCreate !== void 0) {
    collectionOptions.autoCreate = schema.options.autoCreate;
  }

  const collection = connection.collection(
    collectionName,
    collectionOptions
  );

  model.prototype.collection = collection;
  model.prototype.$collection = collection;
  model.prototype[modelCollectionSymbol] = collection;

  model.prototype.$__setSchema(schema);

  
  applyMethods(model, schema);
  applyStatics(model, schema);
  applyHooks(model, schema);
  applyStaticHooks(model, schema.s.hooks, schema.statics);

  model.schema = model.prototype.$__schema;
  model.collection = collection;
  model.$__collection = collection;

  
  model.Query = function() {
    Query.apply(this, arguments);
  };
  Object.setPrototypeOf(model.Query.prototype, Query.prototype);
  model.Query.base = Query.base;
  model.Query.prototype.constructor = Query;
  model._applyQueryMiddleware();
  applyQueryMethods(model, schema.query);

  return model;
};


Model.$__updateConnection = function $__updateConnection(newConnection) {
  this.db = newConnection;
  this.prototype.db = newConnection;
  this.prototype[modelDbSymbol] = newConnection;

  const collection = newConnection.collection(
    this.collection.collectionName,
    this.collection.opts
  );

  this.prototype.collection = collection;
  this.prototype.$collection = collection;
  this.prototype[modelCollectionSymbol] = collection;

  this.collection = collection;
  this.$__collection = collection;
};


function applyQueryMethods(model, methods) {
  for (const i in methods) {
    model.Query.prototype[i] = methods[i];
  }
}


Model.__subclass = function subclass(conn, schema, collection) {
  
  const _this = this;

  const Model = function Model(doc, fields, skipId) {
    if (!(this instanceof Model)) {
      return new Model(doc, fields, skipId);
    }
    _this.call(this, doc, fields, skipId);
  };

  Object.setPrototypeOf(Model, _this);
  Object.setPrototypeOf(Model.prototype, _this.prototype);
  Model.db = conn;
  Model.prototype.db = conn;
  Model.prototype[modelDbSymbol] = conn;

  _this[subclassedSymbol] = _this[subclassedSymbol] || [];
  _this[subclassedSymbol].push(Model);
  if (_this.discriminators != null) {
    Model.discriminators = {};
    for (const key of Object.keys(_this.discriminators)) {
      Model.discriminators[key] = _this.discriminators[key].
        __subclass(_this.db, _this.discriminators[key].schema, collection);
    }
  }

  const s = schema && typeof schema !== 'string'
    ? schema
    : _this.prototype.$__schema;

  const options = s.options || {};
  const _userProvidedOptions = s._userProvidedOptions || {};

  if (!collection) {
    collection = _this.prototype.$__schema.get('collection') ||
      utils.toCollectionName(_this.modelName, this.base.pluralize());
  }

  const collectionOptions = {
    schemaUserProvidedOptions: _userProvidedOptions,
    capped: s && options.capped
  };

  Model.prototype.collection = conn.collection(collection, collectionOptions);
  Model.prototype.$collection = Model.prototype.collection;
  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;
  Model.collection = Model.prototype.collection;
  Model.$__collection = Model.collection;
  
  Model.init().catch(() => {});
  return Model;
};


Model.recompileSchema = function recompileSchema() {
  this.prototype.$__setSchema(this.schema);

  if (this.schema._applyDiscriminators != null) {
    for (const disc of this.schema._applyDiscriminators.keys()) {
      this.discriminator(disc, this.schema._applyDiscriminators.get(disc));
    }
  }

  delete this.schema._defaultToObjectOptionsMap;

  applyEmbeddedDiscriminators(this.schema, new WeakSet(), true);
};


Model.inspect = function() {
  return `Model { ${this.modelName} }`;
};


Model.namespace = function namespace() {
  return this.db.name + '.' + this.collection.collectionName;
};

if (util.inspect.custom) {
  
  Model[util.inspect.custom] = Model.inspect;
}


Model._applyQueryMiddleware = function _applyQueryMiddleware() {
  const Query = this.Query;
  const queryMiddleware = this.schema.s.hooks.filter(hook => {
    const contexts = _getContexts(hook);
    if (hook.name === 'validate') {
      return !!contexts.query;
    }
    if (hook.name === 'deleteOne' || hook.name === 'updateOne') {
      return !!contexts.query || Object.keys(contexts).length === 0;
    }
    if (hook.query != null || hook.document != null) {
      return !!hook.query;
    }
    return true;
  });

  Query.prototype._queryMiddleware = queryMiddleware;
};

function _getContexts(hook) {
  const ret = {};
  if (hook.hasOwnProperty('query')) {
    ret.query = hook.query;
  }
  if (hook.hasOwnProperty('document')) {
    ret.document = hook.document;
  }
  return ret;
}


module.exports = exports = Model;

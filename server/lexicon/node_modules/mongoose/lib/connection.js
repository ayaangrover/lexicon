'use strict';


const ChangeStream = require('./cursor/changeStream');
const EventEmitter = require('events').EventEmitter;
const Schema = require('./schema');
const STATES = require('./connectionState');
const MongooseBulkWriteError = require('./error/bulkWriteError');
const MongooseError = require('./error/index');
const ServerSelectionError = require('./error/serverSelection');
const SyncIndexesError = require('./error/syncIndexes');
const applyPlugins = require('./helpers/schema/applyPlugins');
const clone = require('./helpers/clone');
const driver = require('./driver');
const get = require('./helpers/get');
const getDefaultBulkwriteResult = require('./helpers/getDefaultBulkwriteResult');
const immediate = require('./helpers/immediate');
const utils = require('./utils');
const CreateCollectionsError = require('./error/createCollectionsError');
const castBulkWrite = require('./helpers/model/castBulkWrite');
const { modelSymbol } = require('./helpers/symbols');
const isPromise = require('./helpers/isPromise');
const decorateBulkWriteResult = require('./helpers/model/decorateBulkWriteResult');

const arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;
const sessionNewDocuments = require('./helpers/symbols').sessionNewDocuments;

const noPasswordAuthMechanisms = [
  'MONGODB-X509'
];


function Connection(base) {
  this.base = base;
  this.collections = {};
  this.models = {};
  this.config = {};
  this.replica = false;
  this.options = null;
  this.otherDbs = []; 
  this.relatedDbs = {}; 
  this.states = STATES;
  this._readyState = STATES.disconnected;
  this._closeCalled = false;
  this._hasOpened = false;
  this.plugins = [];
  if (typeof base === 'undefined' || !base.connections.length) {
    this.id = 0;
  } else {
    this.id = base.nextConnectionId;
  }

  
  
  this._queue = [];
}


Object.setPrototypeOf(Connection.prototype, EventEmitter.prototype);


Object.defineProperty(Connection.prototype, 'readyState', {
  get: function() {
    
    
    if (
      this._readyState === STATES.connected &&
      this._lastHeartbeatAt != null &&
      
      
      this.client?.topology?.s?.description?.type !== 'LoadBalanced' &&
      typeof this.client?.topology?.s?.description?.heartbeatFrequencyMS === 'number' &&
      Date.now() - this._lastHeartbeatAt >= this.client.topology.s.description.heartbeatFrequencyMS * 2) {
      return STATES.disconnected;
    }
    return this._readyState;
  },
  set: function(val) {
    if (!(val in STATES)) {
      throw new Error('Invalid connection state: ' + val);
    }

    if (this._readyState !== val) {
      this._readyState = val;
      
      for (const db of this.otherDbs) {
        db.readyState = val;
      }

      if (STATES.connected === val) {
        this._hasOpened = true;
      }

      this.emit(STATES[val]);
    }
  }
});


Connection.prototype.get = function getOption(key) {
  if (this.config.hasOwnProperty(key)) {
    return this.config[key];
  }

  return get(this.options, key);
};


Connection.prototype.set = function setOption(key, val) {
  if (this.config.hasOwnProperty(key)) {
    this.config[key] = val;
    return val;
  }

  this.options = this.options || {};
  this.options[key] = val;
  return val;
};


Connection.prototype.collections;


Connection.prototype.name;


Connection.prototype.models;


Connection.prototype.id;


Object.defineProperty(Connection.prototype, 'plugins', {
  configurable: false,
  enumerable: true,
  writable: true
});


Object.defineProperty(Connection.prototype, 'host', {
  configurable: true,
  enumerable: true,
  writable: true
});


Object.defineProperty(Connection.prototype, 'port', {
  configurable: true,
  enumerable: true,
  writable: true
});


Object.defineProperty(Connection.prototype, 'user', {
  configurable: true,
  enumerable: true,
  writable: true
});


Object.defineProperty(Connection.prototype, 'pass', {
  configurable: true,
  enumerable: true,
  writable: true
});


Connection.prototype.db;


Connection.prototype.client;


Connection.prototype.config;


Connection.prototype.createCollection = async function createCollection(collection, options) {
  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {
    throw new MongooseError('Connection.prototype.createCollection() no longer accepts a callback');
  }

  await this._waitForConnect();

  return this.db.createCollection(collection, options);
};



Connection.prototype.bulkWrite = async function bulkWrite(ops, options) {
  await this._waitForConnect();
  options = options || {};

  const ordered = options.ordered == null ? true : options.ordered;
  const asyncLocalStorage = this.base.transactionAsyncLocalStorage?.getStore();
  if ((!options || !options.hasOwnProperty('session')) && asyncLocalStorage?.session != null) {
    options = { ...options, session: asyncLocalStorage.session };
  }

  const now = this.base.now();

  let res = null;
  if (ordered) {
    const opsToSend = [];
    for (const op of ops) {
      if (typeof op.model !== 'string' && !op.model?.[modelSymbol]) {
        throw new MongooseError('Must specify model in Connection.prototype.bulkWrite() operations');
      }
      const Model = op.model[modelSymbol] ? op.model : this.model(op.model);

      if (op.name == null) {
        throw new MongooseError('Must specify operation name in Connection.prototype.bulkWrite()');
      }
      if (!castBulkWrite.cast.hasOwnProperty(op.name)) {
        throw new MongooseError(`Unrecognized bulkWrite() operation name ${op.name}`);
      }

      await castBulkWrite.cast[op.name](Model, op, options, now);
      opsToSend.push({ ...op, namespace: Model.namespace() });
    }

    res = await this.client.bulkWrite(opsToSend, options);
  } else {
    const validOps = [];
    const validOpIndexes = [];
    let validationErrors = [];
    const asyncValidations = [];
    const results = [];
    for (let i = 0; i < ops.length; ++i) {
      const op = ops[i];
      if (typeof op.model !== 'string' && !op.model?.[modelSymbol]) {
        const error = new MongooseError('Must specify model in Connection.prototype.bulkWrite() operations');
        validationErrors.push({ index: i, error: error });
        results[i] = error;
        continue;
      }
      let Model;
      try {
        Model = op.model[modelSymbol] ? op.model : this.model(op.model);
      } catch (error) {
        validationErrors.push({ index: i, error: error });
        continue;
      }
      if (op.name == null) {
        const error = new MongooseError('Must specify operation name in Connection.prototype.bulkWrite()');
        validationErrors.push({ index: i, error: error });
        results[i] = error;
        continue;
      }
      if (!castBulkWrite.cast.hasOwnProperty(op.name)) {
        const error = new MongooseError(`Unrecognized bulkWrite() operation name ${op.name}`);
        validationErrors.push({ index: i, error: error });
        results[i] = error;
        continue;
      }

      let maybePromise = null;
      try {
        maybePromise = castBulkWrite.cast[op.name](Model, op, options, now);
      } catch (error) {
        validationErrors.push({ index: i, error: error });
        results[i] = error;
        continue;
      }
      if (isPromise(maybePromise)) {
        asyncValidations.push(
          maybePromise.then(
            () => {
              validOps.push({ ...op, namespace: Model.namespace() });
              validOpIndexes.push(i);
            },
            error => {
              validationErrors.push({ index: i, error: error });
              results[i] = error;
            }
          )
        );
      } else {
        validOps.push({ ...op, namespace: Model.namespace() });
        validOpIndexes.push(i);
      }
    }

    if (asyncValidations.length > 0) {
      await Promise.all(asyncValidations);
    }

    validationErrors = validationErrors.
      sort((v1, v2) => v1.index - v2.index).
      map(v => v.error);

    if (validOps.length === 0) {
      if (options.throwOnValidationError && validationErrors.length) {
        throw new MongooseBulkWriteError(
          validationErrors,
          results,
          res,
          'bulkWrite'
        );
      }
      const BulkWriteResult = this.base.driver.get().BulkWriteResult;
      const res = new BulkWriteResult(getDefaultBulkwriteResult(), false);
      return decorateBulkWriteResult(res, validationErrors, results);
    }

    let error;
    [res, error] = await this.client.bulkWrite(validOps, options).
      then(res => ([res, null])).
      catch(err => ([null, err]));

    for (let i = 0; i < validOpIndexes.length; ++i) {
      results[validOpIndexes[i]] = null;
    }
    if (error) {
      if (validationErrors.length > 0) {
        decorateBulkWriteResult(error, validationErrors, results);
        error.mongoose = error.mongoose || {};
        error.mongoose.validationErrors = validationErrors;
      }
    }

    if (validationErrors.length > 0) {
      if (options.throwOnValidationError) {
        throw new MongooseBulkWriteError(
          validationErrors,
          results,
          res,
          'bulkWrite'
        );
      } else {
        decorateBulkWriteResult(res, validationErrors, results);
      }
    }
  }

  return res;
};


Connection.prototype.createCollections = async function createCollections(options = {}) {
  const result = {};
  const errorsMap = { };

  const { continueOnError } = options;
  delete options.continueOnError;
  for (const model of Object.values(this.models)) {
    try {
      result[model.modelName] = await model.createCollection({});
    } catch (err) {
      if (!continueOnError) {
        errorsMap[model.modelName] = err;
        break;
      } else {
        result[model.modelName] = err;
      }
    }
  }

  if (!continueOnError && Object.keys(errorsMap).length) {
    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');
    const createCollectionsError = new CreateCollectionsError(message, errorsMap);
    throw createCollectionsError;
  }
  return result;
};


Connection.prototype.withSession = async function withSession(executor) {
  if (arguments.length === 0) {
    throw new Error('Please provide an executor function');
  }
  return await this.client.withSession(executor);
};


Connection.prototype.startSession = async function startSession(options) {
  if (arguments.length >= 2 && typeof arguments[1] === 'function') {
    throw new MongooseError('Connection.prototype.startSession() no longer accepts a callback');
  }

  await this._waitForConnect();

  const session = this.client.startSession(options);
  return session;
};


Connection.prototype.transaction = function transaction(fn, options) {
  return this.startSession().then(session => {
    session[sessionNewDocuments] = new Map();
    return session.withTransaction(() => _wrapUserTransaction(fn, session, this.base), options).
      then(res => {
        delete session[sessionNewDocuments];
        return res;
      }).
      catch(err => {
        delete session[sessionNewDocuments];
        throw err;
      }).
      finally(() => {
        session.endSession().catch(() => {});
      });
  });
};


async function _wrapUserTransaction(fn, session, mongoose) {
  try {
    const res = mongoose.transactionAsyncLocalStorage == null
      ? await fn(session)
      : await new Promise(resolve => {
        mongoose.transactionAsyncLocalStorage.run(
          { session },
          () => resolve(fn(session))
        );
      });
    return res;
  } catch (err) {
    _resetSessionDocuments(session);
    throw err;
  }
}

function _resetSessionDocuments(session) {
  for (const doc of session[sessionNewDocuments].keys()) {
    const state = session[sessionNewDocuments].get(doc);
    if (state.hasOwnProperty('isNew')) {
      doc.$isNew = state.isNew;
    }
    if (state.hasOwnProperty('versionKey')) {
      doc.set(doc.schema.options.versionKey, state.versionKey);
    }

    if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {
      doc.$__.activePaths.states.modify = {};
    }
    for (const path of state.modifiedPaths) {
      const currentState = doc.$__.activePaths.paths[path];
      if (currentState != null) {
        delete doc.$__.activePaths[currentState][path];
      }
      doc.$__.activePaths.paths[path] = 'modify';
      doc.$__.activePaths.states.modify[path] = true;
    }

    for (const path of state.atomics.keys()) {
      const val = doc.$__getValue(path);
      if (val == null) {
        continue;
      }
      val[arrayAtomicsSymbol] = state.atomics.get(path);
    }
  }
}


Connection.prototype.dropCollection = async function dropCollection(collection) {
  if (arguments.length >= 2 && typeof arguments[1] === 'function') {
    throw new MongooseError('Connection.prototype.dropCollection() no longer accepts a callback');
  }

  await this._waitForConnect();

  return this.db.dropCollection(collection);
};


Connection.prototype._waitForConnect = async function _waitForConnect(noTimeout) {
  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {
    const bufferTimeoutMS = this._getBufferTimeoutMS();
    let timeout = null;
    let timedOut = false;
    
    const queueElement = {};

    
    const waitForConnectPromise = new Promise(resolve => {
      queueElement.fn = resolve;
      this._queue.push(queueElement);
    });

    if (noTimeout) {
      await waitForConnectPromise;
    } else {
      await Promise.race([
        waitForConnectPromise,
        new Promise(resolve => {
          timeout = setTimeout(
            () => {
              timedOut = true;
              resolve();
            },
            bufferTimeoutMS
          );
        })
      ]);
    }

    if (timedOut) {
      const index = this._queue.indexOf(queueElement);
      if (index !== -1) {
        this._queue.splice(index, 1);
      }
      const message = 'Connection operation buffering timed out after ' + bufferTimeoutMS + 'ms';
      throw new MongooseError(message);
    } else if (timeout != null) {
      
      
      clearTimeout(timeout);
    }
  }
};


Connection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
  if (this.config.bufferTimeoutMS != null) {
    return this.config.bufferTimeoutMS;
  }
  if (this.base != null && this.base.get('bufferTimeoutMS') != null) {
    return this.base.get('bufferTimeoutMS');
  }
  return 10000;
};


Connection.prototype.listCollections = async function listCollections() {
  await this._waitForConnect();

  const cursor = this.db.listCollections();
  return await cursor.toArray();
};


Connection.prototype.listDatabases = async function listDatabases() {
  
  throw new MongooseError('listDatabases() not implemented by driver');
};


Connection.prototype.dropDatabase = async function dropDatabase() {
  if (arguments.length >= 1 && typeof arguments[0] === 'function') {
    throw new MongooseError('Connection.prototype.dropDatabase() no longer accepts a callback');
  }

  await this._waitForConnect();

  
  
  
  
  for (const model of Object.values(this.models)) {
    delete model.$init;
  }

  return this.db.dropDatabase();
};


Connection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
  if (this.config.bufferCommands != null) {
    return this.config.bufferCommands;
  }
  if (this.base.get('bufferCommands') != null) {
    return this.base.get('bufferCommands');
  }
  return true;
};


Connection.prototype.error = function error(err, callback) {
  if (callback) {
    callback(err);
    return null;
  }
  if (this.listeners('error').length > 0) {
    this.emit('error', err);
  }
  return Promise.reject(err);
};


Connection.prototype.onOpen = function() {
  this.readyState = STATES.connected;

  for (const d of this._queue) {
    d.fn.apply(d.ctx, d.args);
  }
  this._queue = [];

  
  
  for (const i in this.collections) {
    if (utils.object.hasOwnProperty(this.collections, i)) {
      this.collections[i].onOpen();
    }
  }

  this.emit('open');
};


Connection.prototype.openUri = async function openUri(uri, options) {
  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
    if (this._connectionString === uri) {
      return this;
    }
  }

  this._closeCalled = false;

  
  
  
  let _fireAndForget = false;
  if (options && '_fireAndForget' in options) {
    _fireAndForget = options._fireAndForget;
    delete options._fireAndForget;
  }

  try {
    _validateArgs.apply(arguments);
  } catch (err) {
    if (_fireAndForget) {
      throw err;
    }
    this.$initialConnection = Promise.reject(err);
    throw err;
  }

  this.$initialConnection = this.createClient(uri, options).
    then(() => this).
    catch(err => {
      this.readyState = STATES.disconnected;
      if (this.listeners('error').length > 0) {
        immediate(() => this.emit('error', err));
      }
      throw err;
    });

  for (const model of Object.values(this.models)) {
    
    model.init().catch(function $modelInitNoop() {});
  }

  
  
  
  if (_fireAndForget) {
    return this;
  }

  try {
    await this.$initialConnection;
  } catch (err) {
    throw _handleConnectionErrors(err);
  }

  return this;
};




Connection.prototype.on = function on(event, callback) {
  if (event === 'error' && this.$initialConnection) {
    this.$initialConnection.catch(() => {});
  }
  return EventEmitter.prototype.on.call(this, event, callback);
};




Connection.prototype.once = function on(event, callback) {
  if (event === 'error' && this.$initialConnection) {
    this.$initialConnection.catch(() => {});
  }
  return EventEmitter.prototype.once.call(this, event, callback);
};


function _validateArgs(uri, options, callback) {
  if (typeof options === 'function' && callback == null) {
    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');
  } else if (typeof callback === 'function') {
    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');
  }
}


function _handleConnectionErrors(err) {
  if (err?.name === 'MongoServerSelectionError') {
    const originalError = err;
    err = new ServerSelectionError();
    err.assimilateError(originalError);
  }

  return err;
}


Connection.prototype.destroy = async function destroy(force) {
  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {
    throw new MongooseError('Connection.prototype.destroy() no longer accepts a callback');
  }

  if (force != null && typeof force === 'object') {
    this.$wasForceClosed = !!force.force;
  } else {
    this.$wasForceClosed = !!force;
  }

  return this._close(force, true);
};


Connection.prototype.close = async function close(force) {
  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {
    throw new MongooseError('Connection.prototype.close() no longer accepts a callback');
  }

  if (force != null && typeof force === 'object') {
    this.$wasForceClosed = !!force.force;
  } else {
    this.$wasForceClosed = !!force;
  }

  if (this._lastHeartbeatAt != null) {
    this._lastHeartbeatAt = null;
  }

  for (const model of Object.values(this.models)) {
    
    
    
    delete model.$init;
  }

  return this._close(force, false);
};

Connection.prototype._close = async function _close(force, destroy) {
  const _this = this;
  const closeCalled = this._closeCalled;
  this._closeCalled = true;
  this._destroyCalled = destroy;
  if (this.client != null) {
    this.client._closeCalled = true;
    this.client._destroyCalled = destroy;
  }

  const conn = this;
  switch (this.readyState) {
    case STATES.disconnected:
      if (destroy && this.base.connections.indexOf(conn) !== -1) {
        this.base.connections.splice(this.base.connections.indexOf(conn), 1);
      }
      if (!closeCalled) {
        await this.doClose(force);
        this.onClose(force);
      }
      break;

    case STATES.connected:
      this.readyState = STATES.disconnecting;
      await this.doClose(force);
      if (destroy && _this.base.connections.indexOf(conn) !== -1) {
        this.base.connections.splice(this.base.connections.indexOf(conn), 1);
      }
      this.onClose(force);

      break;
    case STATES.connecting:
      return new Promise((resolve, reject) => {
        const _rerunClose = () => {
          this.removeListener('open', _rerunClose);
          this.removeListener('error', _rerunClose);
          if (destroy) {
            this.destroy(force).then(resolve, reject);
          } else {
            this.close(force).then(resolve, reject);
          }
        };

        this.once('open', _rerunClose);
        this.once('error', _rerunClose);
      });

    case STATES.disconnecting:
      return new Promise(resolve => {
        this.once('close', () => {
          if (destroy && this.base.connections.indexOf(conn) !== -1) {
            this.base.connections.splice(this.base.connections.indexOf(conn), 1);
          }
          resolve();
        });
      });
  }

  return this;
};


Connection.prototype.doClose = function doClose() {
  throw new Error('Connection#doClose unimplemented by driver');
};


Connection.prototype.onClose = function onClose(force) {
  this.readyState = STATES.disconnected;

  
  
  for (const i in this.collections) {
    if (utils.object.hasOwnProperty(this.collections, i)) {
      this.collections[i].onClose(force);
    }
  }

  this.emit('close', force);

  for (const db of this.otherDbs) {
    this._destroyCalled ? db.destroy({ force: force, skipCloseClient: true }) : db.close({ force: force, skipCloseClient: true });
  }
};


Connection.prototype.collection = function(name, options) {
  const defaultOptions = {
    autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,
    autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate,
    autoSearchIndex: this.config.autoSearchIndex != null ? this.config.autoSearchIndex : this.base.options.autoSearchIndex
  };
  options = Object.assign({}, defaultOptions, options ? clone(options) : {});
  options.$wasForceClosed = this.$wasForceClosed;
  const Collection = this.base && this.base.__driver && this.base.__driver.Collection || driver.get().Collection;
  if (!(name in this.collections)) {
    this.collections[name] = new Collection(name, this, options);
  }
  return this.collections[name];
};


Connection.prototype.plugin = function(fn, opts) {
  this.plugins.push([fn, opts]);
  return this;
};


Connection.prototype.model = function model(name, schema, collection, options) {
  if (!(this instanceof Connection)) {
    throw new MongooseError('`connection.model()` should not be run with ' +
      '`new`. If you are doing `new db.model(foo)(bar)`, use ' +
      '`db.model(foo)(bar)` instead');
  }

  let fn;
  if (typeof name === 'function') {
    fn = name;
    name = fn.name;
  }

  
  if (typeof schema === 'string') {
    collection = schema;
    schema = false;
  }

  if (utils.isObject(schema)) {
    if (!schema.instanceOfSchema) {
      schema = new Schema(schema);
    } else if (!(schema instanceof this.base.Schema)) {
      schema = schema._clone(this.base.Schema);
    }
  }
  if (schema && !schema.instanceOfSchema) {
    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +
      'schema or a POJO');
  }

  const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };
  const opts = Object.assign(defaultOptions, options, { connection: this });
  if (this.models[name] && !collection && opts.overwriteModels !== true) {
    
    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
      throw new MongooseError.OverwriteModelError(name);
    }
    return this.models[name];
  }

  let model;

  if (schema && schema.instanceOfSchema) {
    applyPlugins(schema, this.plugins, null, '$connectionPluginsApplied');

    
    model = this.base._model(fn || name, schema, collection, opts);

    
    
    if (!this.models[name]) {
      this.models[name] = model;
    }

    
    model.init().catch(function $modelInitNoop() {});

    return model;
  }

  if (this.models[name] && collection) {
    
    model = this.models[name];
    schema = model.prototype.schema;
    const sub = model.__subclass(this, schema, collection);
    
    return sub;
  }

  if (arguments.length === 1) {
    model = this.models[name];
    if (!model) {
      throw new MongooseError.MissingSchemaError(name);
    }
    return model;
  }

  if (!model) {
    throw new MongooseError.MissingSchemaError(name);
  }

  if (this === model.prototype.db
      && (!collection || collection === model.collection.name)) {
    

    
    
    if (!this.models[name]) {
      this.models[name] = model;
    }

    return model;
  }
  this.models[name] = model.__subclass(this, schema, collection);
  return this.models[name];
};


Connection.prototype.deleteModel = function deleteModel(name) {
  if (typeof name === 'string') {
    const model = this.model(name);
    if (model == null) {
      return this;
    }
    const collectionName = model.collection.name;
    delete this.models[name];
    delete this.collections[collectionName];

    this.emit('deleteModel', model);
  } else if (name instanceof RegExp) {
    const pattern = name;
    const names = this.modelNames();
    for (const name of names) {
      if (pattern.test(name)) {
        this.deleteModel(name);
      }
    }
  } else {
    throw new Error('First parameter to `deleteModel()` must be a string ' +
      'or regexp, got "' + name + '"');
  }

  return this;
};


Connection.prototype.watch = function watch(pipeline, options) {
  const changeStreamThunk = cb => {
    immediate(() => {
      if (this.readyState === STATES.connecting) {
        this.once('open', function() {
          const driverChangeStream = this.db.watch(pipeline, options);
          cb(null, driverChangeStream);
        });
      } else {
        const driverChangeStream = this.db.watch(pipeline, options);
        cb(null, driverChangeStream);
      }
    });
  };

  const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);
  return changeStream;
};


Connection.prototype.asPromise = async function asPromise() {
  try {
    await this.$initialConnection;
    return this;
  } catch (err) {
    throw _handleConnectionErrors(err);
  }
};


Connection.prototype.modelNames = function modelNames() {
  return Object.keys(this.models);
};

Connection.prototype.shouldAuthenticate = function shouldAuthenticate() {
  return this.user != null &&
    (this.pass != null || this.authMechanismDoesNotRequirePassword());
};

Connection.prototype.authMechanismDoesNotRequirePassword = function authMechanismDoesNotRequirePassword() {
  if (this.options && this.options.auth) {
    return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;
  }
  return true;
};

Connection.prototype.optionsProvideAuthenticationData = function optionsProvideAuthenticationData(options) {
  return (options) &&
      (options.user) &&
      ((options.pass) || this.authMechanismDoesNotRequirePassword());
};


Connection.prototype.getClient = function getClient() {
  return this.client;
};


Connection.prototype.setClient = function setClient() {
  throw new MongooseError('Connection#setClient not implemented by driver');
};


Connection.prototype.createClient = function createClient() {
  throw new MongooseError('Connection#createClient not implemented by driver');
};

Connection.prototype.syncIndexes = async function syncIndexes(options = {}) {
  const result = {};
  const errorsMap = { };

  const { continueOnError } = options;
  delete options.continueOnError;

  for (const model of Object.values(this.models)) {
    try {
      result[model.modelName] = await model.syncIndexes(options);
    } catch (err) {
      if (!continueOnError) {
        errorsMap[model.modelName] = err;
        break;
      } else {
        result[model.modelName] = err;
      }
    }
  }

  if (!continueOnError && Object.keys(errorsMap).length) {
    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');
    const syncIndexesError = new SyncIndexesError(message, errorsMap);
    throw syncIndexesError;
  }

  return result;
};





Connection.STATES = STATES;
module.exports = Connection;

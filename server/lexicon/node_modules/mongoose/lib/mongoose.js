'use strict';


const Document = require('./document');
const EventEmitter = require('events').EventEmitter;
const Kareem = require('kareem');
const Schema = require('./schema');
const SchemaType = require('./schemaType');
const SchemaTypes = require('./schema/index');
const VirtualType = require('./virtualType');
const STATES = require('./connectionState');
const VALID_OPTIONS = require('./validOptions');
const Types = require('./types');
const Query = require('./query');
const Model = require('./model');
const applyPlugins = require('./helpers/schema/applyPlugins');
const builtinPlugins = require('./plugins');
const driver = require('./driver');
const legacyPluralize = require('./helpers/pluralize');
const utils = require('./utils');
const pkg = require('../package.json');
const cast = require('./cast');

const Aggregate = require('./aggregate');
const trusted = require('./helpers/query/trusted').trusted;
const sanitizeFilter = require('./helpers/query/sanitizeFilter');
const isBsonType = require('./helpers/isBsonType');
const MongooseError = require('./error/mongooseError');
const SetOptionError = require('./error/setOptionError');
const applyEmbeddedDiscriminators = require('./helpers/discriminator/applyEmbeddedDiscriminators');

const defaultMongooseSymbol = Symbol.for('mongoose:default');
const defaultConnectionSymbol = Symbol('mongoose:defaultConnection');

require('./helpers/printJestWarning');

const objectIdHexRegexp = /^[0-9A-Fa-f]{24}$/;

const { AsyncLocalStorage } = require('node:async_hooks');

function Mongoose(options) {
  this.connections = [];
  this.nextConnectionId = 0;
  this.models = {};
  this.events = new EventEmitter();
  this.__driver = driver.get();
  
  this.options = Object.assign({
    pluralization: true,
    autoIndex: true,
    autoCreate: true,
    autoSearchIndex: false
  }, options);
  const createInitialConnection = utils.getOption('createInitialConnection', this.options) ?? true;
  if (createInitialConnection && this.__driver != null) {
    _createDefaultConnection(this);
  }

  if (this.options.pluralization) {
    this._pluralize = legacyPluralize;
  }

  
  
  if (!options || !options[defaultMongooseSymbol]) {
    const _this = this;
    this.Schema = function() {
      this.base = _this;
      return Schema.apply(this, arguments);
    };
    this.Schema.prototype = Object.create(Schema.prototype);

    Object.assign(this.Schema, Schema);
    this.Schema.base = this;
    this.Schema.Types = Object.assign({}, Schema.Types);
  } else {
    
    
    
    for (const key of ['Schema', 'model']) {
      this[key] = Mongoose.prototype[key];
    }
  }
  this.Schema.prototype.base = this;

  if (options?.transactionAsyncLocalStorage) {
    this.transactionAsyncLocalStorage = new AsyncLocalStorage();
  }

  Object.defineProperty(this, 'plugins', {
    configurable: false,
    enumerable: true,
    writable: false,
    value: Object.values(builtinPlugins).map(plugin => ([plugin, { deduplicate: true }]))
  });
}

Mongoose.prototype.cast = cast;
Mongoose.prototype.STATES = STATES;

Mongoose.prototype.ConnectionStates = STATES;


Mongoose.prototype.driver = driver;


Mongoose.prototype.setDriver = function setDriver(driver) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  if (_mongoose.__driver === driver) {
    return _mongoose;
  }

  const openConnection = _mongoose.connections && _mongoose.connections.find(conn => conn.readyState !== STATES.disconnected);
  if (openConnection) {
    const msg = 'Cannot modify Mongoose driver if a connection is already open. ' +
      'Call `mongoose.disconnect()` before modifying the driver';
    throw new MongooseError(msg);
  }
  _mongoose.__driver = driver;

  if (Array.isArray(driver.plugins)) {
    for (const plugin of driver.plugins) {
      if (typeof plugin === 'function') {
        _mongoose.plugin(plugin);
      }
    }
  }

  if (driver.SchemaTypes != null) {
    Object.assign(mongoose.Schema.Types, driver.SchemaTypes);
  }

  const Connection = driver.Connection;
  const oldDefaultConnection = _mongoose.connections[0];
  _mongoose.connections = [new Connection(_mongoose)];
  _mongoose.connections[0].models = _mongoose.models;
  if (oldDefaultConnection == null) {
    return _mongoose;
  }

  
  
  for (const model of Object.values(_mongoose.models)) {
    if (model.db !== oldDefaultConnection) {
      continue;
    }
    model.$__updateConnection(_mongoose.connections[0]);
  }

  return _mongoose;
};


Mongoose.prototype.set = function getsetOptions(key, value) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  if (arguments.length === 1 && typeof key !== 'object') {
    if (VALID_OPTIONS.indexOf(key) === -1) {
      const error = new SetOptionError();
      error.addError(key, new SetOptionError.SetOptionInnerError(key));
      throw error;
    }

    return _mongoose.options[key];
  }

  let options = {};

  if (arguments.length === 2) {
    options = { [key]: value };
  }

  if (arguments.length === 1 && typeof key === 'object') {
    options = key;
  }

  
  let error = undefined;

  for (const [optionKey, optionValue] of Object.entries(options)) {
    if (VALID_OPTIONS.indexOf(optionKey) === -1) {
      if (!error) {
        error = new SetOptionError();
      }
      error.addError(optionKey, new SetOptionError.SetOptionInnerError(optionKey));
      continue;
    }

    _mongoose.options[optionKey] = optionValue;

    if (optionKey === 'objectIdGetter') {
      if (optionValue) {
        Object.defineProperty(_mongoose.Types.ObjectId.prototype, '_id', {
          enumerable: false,
          configurable: true,
          get: function() {
            return this;
          }
        });
      } else {
        delete _mongoose.Types.ObjectId.prototype._id;
      }
    } else if (optionKey === 'transactionAsyncLocalStorage') {
      if (optionValue && !_mongoose.transactionAsyncLocalStorage) {
        _mongoose.transactionAsyncLocalStorage = new AsyncLocalStorage();
      } else if (!optionValue && _mongoose.transactionAsyncLocalStorage) {
        delete _mongoose.transactionAsyncLocalStorage;
      }
    } else if (optionKey === 'createInitialConnection') {
      if (optionValue && !_mongoose.connection) {
        _createDefaultConnection(_mongoose);
      } else if (optionValue === false && _mongoose.connection && _mongoose.connection[defaultConnectionSymbol]) {
        if (_mongoose.connection.readyState === STATES.disconnected && Object.keys(_mongoose.connection.models).length === 0) {
          _mongoose.connections.shift();
        }
      }
    }
  }

  if (error) {
    throw error;
  }

  return _mongoose;
};


Mongoose.prototype.get = Mongoose.prototype.set;


Mongoose.prototype.createConnection = function createConnection(uri, options) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  const Connection = _mongoose.__driver.Connection;
  const conn = new Connection(_mongoose);
  _mongoose.connections.push(conn);
  _mongoose.nextConnectionId++;
  _mongoose.events.emit('createConnection', conn);

  if (arguments.length > 0) {
    conn.openUri(uri, { ...options, _fireAndForget: true });
  }

  return conn;
};


Mongoose.prototype.connect = async function connect(uri, options) {
  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {
    throw new MongooseError('Mongoose.prototype.connect() no longer accepts a callback');
  }

  const _mongoose = this instanceof Mongoose ? this : mongoose;
  if (_mongoose.connection == null) {
    _createDefaultConnection(_mongoose);
  }
  const conn = _mongoose.connection;

  return conn.openUri(uri, options).then(() => _mongoose);
};


Mongoose.prototype.disconnect = async function disconnect() {
  if (arguments.length >= 1 && typeof arguments[0] === 'function') {
    throw new MongooseError('Mongoose.prototype.disconnect() no longer accepts a callback');
  }

  const _mongoose = this instanceof Mongoose ? this : mongoose;

  const remaining = _mongoose.connections.length;
  if (remaining <= 0) {
    return;
  }
  await Promise.all(_mongoose.connections.map(conn => conn.close()));
};


Mongoose.prototype.startSession = function startSession() {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);
};


Mongoose.prototype.pluralize = function pluralize(fn) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  if (arguments.length > 0) {
    _mongoose._pluralize = fn;
  }
  return _mongoose._pluralize;
};


Mongoose.prototype.model = function model(name, schema, collection, options) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  if (typeof schema === 'string') {
    collection = schema;
    schema = false;
  }

  if (arguments.length === 1) {
    const model = _mongoose.models[name];
    if (!model) {
      throw new _mongoose.Error.MissingSchemaError(name);
    }
    return model;
  }

  if (utils.isObject(schema) && !(schema instanceof Schema)) {
    schema = new Schema(schema);
  }
  if (schema && !(schema instanceof Schema)) {
    throw new _mongoose.Error('The 2nd parameter to `mongoose.model()` should be a ' +
      'schema or a POJO');
  }

  
  options = options || {};

  const originalSchema = schema;
  if (schema) {
    if (_mongoose.get('cloneSchemas')) {
      schema = schema.clone();
    }
    _mongoose._applyPlugins(schema);
  }

  
  
  const overwriteModels = _mongoose.options.hasOwnProperty('overwriteModels') ?
    _mongoose.options.overwriteModels :
    options.overwriteModels;
  if (_mongoose.models.hasOwnProperty(name) && options.cache !== false && overwriteModels !== true) {
    if (originalSchema &&
        originalSchema.instanceOfSchema &&
        originalSchema !== _mongoose.models[name].schema) {
      throw new _mongoose.Error.OverwriteModelError(name);
    }
    if (collection && collection !== _mongoose.models[name].collection.name) {
      
      const model = _mongoose.models[name];
      schema = model.prototype.schema;
      const sub = model.__subclass(_mongoose.connection, schema, collection);
      
      return sub;
    }
    return _mongoose.models[name];
  }
  if (schema == null) {
    throw new _mongoose.Error.MissingSchemaError(name);
  }

  const model = _mongoose._model(name, schema, collection, options);
  _mongoose.connection.models[name] = model;
  _mongoose.models[name] = model;

  return model;
};


Mongoose.prototype._model = function _model(name, schema, collection, options) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  let model;
  if (typeof name === 'function') {
    model = name;
    name = model.name;
    if (!(model.prototype instanceof Model)) {
      throw new _mongoose.Error('The provided class ' + name + ' must extend Model');
    }
  }

  if (schema) {
    if (_mongoose.get('cloneSchemas')) {
      schema = schema.clone();
    }
    _mongoose._applyPlugins(schema);
  }

  
  if (schema == null || !('pluralization' in schema.options)) {
    schema.options.pluralization = _mongoose.options.pluralization;
  }

  if (!collection) {
    collection = schema.get('collection') ||
      utils.toCollectionName(name, _mongoose.pluralize());
  }

  applyEmbeddedDiscriminators(schema);

  const connection = options.connection || _mongoose.connection;
  model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);
  
  model.init().catch(function $modelInitNoop() {});

  connection.emit('model', model);

  if (schema._applyDiscriminators != null) {
    for (const disc of schema._applyDiscriminators.keys()) {
      const {
        schema: discriminatorSchema,
        options
      } = schema._applyDiscriminators.get(disc);
      model.discriminator(disc, discriminatorSchema, options);
    }
  }

  return model;
};


Mongoose.prototype.deleteModel = function deleteModel(name) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  _mongoose.connection.deleteModel(name);
  delete _mongoose.models[name];
  return _mongoose;
};


Mongoose.prototype.modelNames = function modelNames() {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  const names = Object.keys(_mongoose.models);
  return names;
};


Mongoose.prototype._applyPlugins = function _applyPlugins(schema, options) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  options = options || {};
  options.applyPluginsToDiscriminators = _mongoose.options && _mongoose.options.applyPluginsToDiscriminators || false;
  options.applyPluginsToChildSchemas = typeof (_mongoose.options && _mongoose.options.applyPluginsToChildSchemas) === 'boolean' ?
    _mongoose.options.applyPluginsToChildSchemas :
    true;
  applyPlugins(schema, _mongoose.plugins, options, '$globalPluginsApplied');
};


Mongoose.prototype.plugin = function plugin(fn, opts) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  _mongoose.plugins.push([fn, opts]);
  return _mongoose;
};


Mongoose.prototype.__defineGetter__('connection', function() {
  return this.connections[0];
});

Mongoose.prototype.__defineSetter__('connection', function(v) {
  if (v instanceof this.__driver.Connection) {
    this.connections[0] = v;
    this.models = v.models;
  }
});


Mongoose.prototype.connections;


Mongoose.prototype.nextConnectionId;


Mongoose.prototype.Aggregate = Aggregate;


Object.defineProperty(Mongoose.prototype, 'Collection', {
  get: function() {
    return this.__driver.Collection;
  },
  set: function(Collection) {
    this.__driver.Collection = Collection;
  }
});


Object.defineProperty(Mongoose.prototype, 'Connection', {
  get: function() {
    return this.__driver.Connection;
  },
  set: function(Connection) {
    if (Connection === this.__driver.Connection) {
      return;
    }

    this.__driver.Connection = Connection;
  }
});


Mongoose.prototype.version = pkg.version;


Mongoose.prototype.Mongoose = Mongoose;


Mongoose.prototype.Schema = Schema;


Mongoose.prototype.SchemaType = SchemaType;


Mongoose.prototype.SchemaTypes = Schema.Types;


Mongoose.prototype.VirtualType = VirtualType;


Mongoose.prototype.Types = Types;


Mongoose.prototype.Query = Query;


Mongoose.prototype.Model = Model;


Mongoose.prototype.Document = Document;


Mongoose.prototype.DocumentProvider = require('./documentProvider');


Mongoose.prototype.ObjectId = SchemaTypes.ObjectId;


Mongoose.prototype.isValidObjectId = function isValidObjectId(v) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  return _mongoose.Types.ObjectId.isValid(v);
};


Mongoose.prototype.isObjectIdOrHexString = function isObjectIdOrHexString(v) {
  return isBsonType(v, 'ObjectId') || (typeof v === 'string' && objectIdHexRegexp.test(v));
};

Mongoose.prototype.syncIndexes = function syncIndexes(options) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  return _mongoose.connection.syncIndexes(options);
};


Mongoose.prototype.Decimal128 = SchemaTypes.Decimal128;



Mongoose.prototype.Mixed = SchemaTypes.Mixed;


Mongoose.prototype.Date = SchemaTypes.Date;


Mongoose.prototype.Number = SchemaTypes.Number;


Mongoose.prototype.Error = MongooseError;
Mongoose.prototype.MongooseError = MongooseError;


Mongoose.prototype.now = function now() { return new Date(); };


Mongoose.prototype.CastError = MongooseError.CastError;


Mongoose.prototype.SchemaTypeOptions = require('./options/schemaTypeOptions');


Mongoose.prototype.mquery = require('mquery');


Mongoose.prototype.sanitizeFilter = sanitizeFilter;


Mongoose.prototype.trusted = trusted;


Mongoose.prototype.skipMiddlewareFunction = Kareem.skipWrappedFunction;


Mongoose.prototype.overwriteMiddlewareResult = Kareem.overwriteResult;


Mongoose.prototype.omitUndefined = require('./helpers/omitUndefined');


function _createDefaultConnection(mongoose) {
  if (mongoose.connection) {
    return;
  }
  const conn = mongoose.createConnection(); 
  conn[defaultConnectionSymbol] = true;
  conn.models = mongoose.models;
}


const mongoose = module.exports = exports = new Mongoose({
  [defaultMongooseSymbol]: true
});

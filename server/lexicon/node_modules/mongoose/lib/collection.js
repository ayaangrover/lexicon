'use strict';


const EventEmitter = require('events').EventEmitter;
const STATES = require('./connectionState');
const immediate = require('./helpers/immediate');


function Collection(name, conn, opts) {
  if (opts === void 0) {
    opts = {};
  }

  this.opts = opts;
  this.name = name;
  this.collectionName = name;
  this.conn = conn;
  this.queue = [];
  this.buffer = !conn?._hasOpened;
  this.emitter = new EventEmitter();

  if (STATES.connected === this.conn.readyState) {
    this.onOpen();
  }
}


Collection.prototype.name;


Collection.prototype.collectionName;


Collection.prototype.conn;


Collection.prototype.onOpen = function() {
  this.buffer = false;
  immediate(() => this.doQueue());
};


Collection.prototype.onClose = function() {};


Collection.prototype.addQueue = function(name, args) {
  this.queue.push([name, args]);
  return this;
};


Collection.prototype.removeQueue = function(name, args) {
  const index = this.queue.findIndex(v => v[0] === name && v[1] === args);
  if (index === -1) {
    return false;
  }
  this.queue.splice(index, 1);
  return true;
};


Collection.prototype.doQueue = function() {
  for (const method of this.queue) {
    if (typeof method[0] === 'function') {
      method[0].apply(this, method[1]);
    } else {
      this[method[0]].apply(this, method[1]);
    }
  }
  this.queue = [];
  const _this = this;
  immediate(function() {
    _this.emitter.emit('queue');
  });
  return this;
};


Collection.prototype.ensureIndex = function() {
  throw new Error('Collection#ensureIndex unimplemented by driver');
};


Collection.prototype.createIndex = function() {
  throw new Error('Collection#createIndex unimplemented by driver');
};


Collection.prototype.findAndModify = function() {
  throw new Error('Collection#findAndModify unimplemented by driver');
};


Collection.prototype.findOneAndUpdate = function() {
  throw new Error('Collection#findOneAndUpdate unimplemented by driver');
};


Collection.prototype.findOneAndDelete = function() {
  throw new Error('Collection#findOneAndDelete unimplemented by driver');
};


Collection.prototype.findOneAndReplace = function() {
  throw new Error('Collection#findOneAndReplace unimplemented by driver');
};


Collection.prototype.findOne = function() {
  throw new Error('Collection#findOne unimplemented by driver');
};


Collection.prototype.find = function() {
  throw new Error('Collection#find unimplemented by driver');
};


Collection.prototype.insert = function() {
  throw new Error('Collection#insert unimplemented by driver');
};


Collection.prototype.insertOne = function() {
  throw new Error('Collection#insertOne unimplemented by driver');
};


Collection.prototype.insertMany = function() {
  throw new Error('Collection#insertMany unimplemented by driver');
};


Collection.prototype.save = function() {
  throw new Error('Collection#save unimplemented by driver');
};


Collection.prototype.updateOne = function() {
  throw new Error('Collection#updateOne unimplemented by driver');
};


Collection.prototype.updateMany = function() {
  throw new Error('Collection#updateMany unimplemented by driver');
};


Collection.prototype.deleteOne = function() {
  throw new Error('Collection#deleteOne unimplemented by driver');
};


Collection.prototype.deleteMany = function() {
  throw new Error('Collection#deleteMany unimplemented by driver');
};


Collection.prototype.getIndexes = function() {
  throw new Error('Collection#getIndexes unimplemented by driver');
};


Collection.prototype.watch = function() {
  throw new Error('Collection#watch unimplemented by driver');
};


Collection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
  const opts = this.opts;

  if (opts.bufferCommands != null) {
    return opts.bufferCommands;
  }
  if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {
    return opts.schemaUserProvidedOptions.bufferCommands;
  }

  return this.conn._shouldBufferCommands();
};


Collection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
  const conn = this.conn;
  const opts = this.opts;

  if (opts.bufferTimeoutMS != null) {
    return opts.bufferTimeoutMS;
  }
  if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {
    return opts.schemaUserProvidedOptions.bufferTimeoutMS;
  }
  return conn._getBufferTimeoutMS();
};


module.exports = Collection;

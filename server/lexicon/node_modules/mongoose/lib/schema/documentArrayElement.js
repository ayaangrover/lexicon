
'use strict';

const MongooseError = require('../error/mongooseError');
const SchemaType = require('../schemaType');
const SchemaSubdocument = require('./subdocument');
const getConstructor = require('../helpers/discriminator/getConstructor');


function SchemaDocumentArrayElement(path, options) {
  this.$parentSchemaType = options && options.$parentSchemaType;
  if (!this.$parentSchemaType) {
    throw new MongooseError('Cannot create DocumentArrayElement schematype without a parent');
  }
  delete options.$parentSchemaType;

  SchemaType.call(this, path, options, 'DocumentArrayElement');

  this.$isMongooseDocumentArrayElement = true;
}

SchemaDocumentArrayElement.schemaName = 'DocumentArrayElement';

SchemaDocumentArrayElement.defaultOptions = {};

SchemaDocumentArrayElement.prototype = Object.create(SchemaType.prototype);
SchemaDocumentArrayElement.prototype.constructor = SchemaDocumentArrayElement;


SchemaDocumentArrayElement.prototype.cast = function(...args) {
  return this.$parentSchemaType.cast(...args)[0];
};


SchemaDocumentArrayElement.prototype.doValidate = function(value, fn, scope, options) {
  const Constructor = getConstructor(this.caster, value);

  if (value && !(value instanceof Constructor)) {
    value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);
  }

  return SchemaSubdocument.prototype.doValidate.call(this, value, fn, scope, options);
};


SchemaDocumentArrayElement.prototype.clone = function() {
  this.options.$parentSchemaType = this.$parentSchemaType;
  const ret = SchemaType.prototype.clone.apply(this, arguments);
  delete this.options.$parentSchemaType;

  ret.caster = this.caster;
  ret.schema = this.schema;

  return ret;
};


module.exports = SchemaDocumentArrayElement;

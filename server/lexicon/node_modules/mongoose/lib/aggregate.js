'use strict';


const AggregationCursor = require('./cursor/aggregationCursor');
const MongooseError = require('./error/mongooseError');
const Query = require('./query');
const { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require('./helpers/query/applyGlobalOption');
const clone = require('./helpers/clone');
const getConstructorName = require('./helpers/getConstructorName');
const prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');
const stringifyFunctionOperators = require('./helpers/aggregate/stringifyFunctionOperators');
const utils = require('./utils');
const { modelSymbol } = require('./helpers/symbols');
const read = Query.prototype.read;
const readConcern = Query.prototype.readConcern;

const validRedactStringValues = new Set(['$$DESCEND', '$$PRUNE', '$$KEEP']);


function Aggregate(pipeline, modelOrConn) {
  this._pipeline = [];
  if (modelOrConn == null || modelOrConn[modelSymbol]) {
    this._model = modelOrConn;
  } else {
    this._connection = modelOrConn;
  }
  this.options = {};

  if (arguments.length === 1 && Array.isArray(pipeline)) {
    this.append.apply(this, pipeline);
  }
}


Aggregate.prototype.options;


Aggregate.prototype._optionsForExec = function() {
  const options = this.options || {};

  const asyncLocalStorage = this.model()?.db?.base.transactionAsyncLocalStorage?.getStore();
  if (!options.hasOwnProperty('session') && asyncLocalStorage?.session != null) {
    options.session = asyncLocalStorage.session;
  }

  return options;
};


Aggregate.prototype.model = function(model) {
  if (arguments.length === 0) {
    return this._model;
  }

  this._model = model;
  if (model.schema != null) {
    if (this.options.readPreference == null &&
      model.schema.options.read != null) {
      this.options.readPreference = model.schema.options.read;
    }
    if (this.options.collation == null &&
      model.schema.options.collation != null) {
      this.options.collation = model.schema.options.collation;
    }
  }

  return model;
};


Aggregate.prototype.append = function() {
  const args = (arguments.length === 1 && Array.isArray(arguments[0]))
    ? arguments[0]
    : [...arguments];

  if (!args.every(isOperator)) {
    throw new Error('Arguments must be aggregate pipeline operators');
  }

  this._pipeline = this._pipeline.concat(args);

  return this;
};

Aggregate.prototype.addFields = function(arg) {
  if (typeof arg !== 'object' || arg === null || Array.isArray(arg)) {
    throw new Error('Invalid addFields() argument. Must be an object');
  }
  return this.append({ $addFields: Object.assign({}, arg) });
};


Aggregate.prototype.project = function(arg) {
  const fields = {};

  if (typeof arg === 'object' && !Array.isArray(arg)) {
    Object.keys(arg).forEach(function(field) {
      fields[field] = arg[field];
    });
  } else if (arguments.length === 1 && typeof arg === 'string') {
    arg.split(/\s+/).forEach(function(field) {
      if (!field) {
        return;
      }
      const include = field[0] === '-' ? 0 : 1;
      if (include === 0) {
        field = field.substring(1);
      }
      fields[field] = include;
    });
  } else {
    throw new Error('Invalid project() argument. Must be string or object');
  }

  return this.append({ $project: fields });
};









Aggregate.prototype.near = function(arg) {
  if (arg == null) {
    throw new MongooseError('Aggregate `near()` must be called with non-nullish argument');
  }
  if (arg.near == null) {
    throw new MongooseError('Aggregate `near()` argument must have a `near` property');
  }
  const coordinates = Array.isArray(arg.near) ? arg.near : arg.near.coordinates;
  if (typeof arg.near === 'object' && (!Array.isArray(coordinates) || coordinates.length < 2 || coordinates.find(c => typeof c !== 'number'))) {
    throw new MongooseError(`Aggregate \`near()\` argument has invalid coordinates, got "${coordinates}"`);
  }

  const op = {};
  op.$geoNear = arg;
  return this.append(op);
};


'group match skip limit out densify fill'.split(' ').forEach(function($operator) {
  Aggregate.prototype[$operator] = function(arg) {
    const op = {};
    op['$' + $operator] = arg;
    return this.append(op);
  };
});


Aggregate.prototype.unwind = function() {
  const args = [...arguments];

  const res = [];
  for (const arg of args) {
    if (arg && typeof arg === 'object') {
      res.push({ $unwind: arg });
    } else if (typeof arg === 'string') {
      res.push({
        $unwind: (arg[0] === '$') ? arg : '$' + arg
      });
    } else {
      throw new Error('Invalid arg "' + arg + '" to unwind(), ' +
        'must be string or object');
    }
  }

  return this.append.apply(this, res);
};


Aggregate.prototype.replaceRoot = function(newRoot) {
  let ret;

  if (typeof newRoot === 'string') {
    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;
  } else {
    ret = newRoot;
  }

  return this.append({
    $replaceRoot: {
      newRoot: ret
    }
  });
};


Aggregate.prototype.count = function(fieldName) {
  return this.append({ $count: fieldName });
};


Aggregate.prototype.sortByCount = function(arg) {
  if (arg && typeof arg === 'object') {
    return this.append({ $sortByCount: arg });
  } else if (typeof arg === 'string') {
    return this.append({
      $sortByCount: (arg[0] === '$') ? arg : '$' + arg
    });
  } else {
    throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), ' +
      'must be string or object');
  }
};


Aggregate.prototype.lookup = function(options) {
  return this.append({ $lookup: options });
};


Aggregate.prototype.graphLookup = function(options) {
  const cloneOptions = {};
  if (options) {
    if (!utils.isObject(options)) {
      throw new TypeError('Invalid graphLookup() argument. Must be an object.');
    }

    utils.mergeClone(cloneOptions, options);
    const startWith = cloneOptions.startWith;

    if (startWith && typeof startWith === 'string') {
      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ?
        cloneOptions.startWith :
        '$' + cloneOptions.startWith;
    }

  }
  return this.append({ $graphLookup: cloneOptions });
};


Aggregate.prototype.sample = function(size) {
  return this.append({ $sample: { size: size } });
};


Aggregate.prototype.sort = function(arg) {
  

  const sort = {};

  if (getConstructorName(arg) === 'Object') {
    const desc = ['desc', 'descending', -1];
    Object.keys(arg).forEach(function(field) {
      
      if (arg[field] instanceof Object && arg[field].$meta) {
        sort[field] = arg[field];
        return;
      }
      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
    });
  } else if (arguments.length === 1 && typeof arg === 'string') {
    arg.split(/\s+/).forEach(function(field) {
      if (!field) {
        return;
      }
      const ascend = field[0] === '-' ? -1 : 1;
      if (ascend === -1) {
        field = field.substring(1);
      }
      sort[field] = ascend;
    });
  } else {
    throw new TypeError('Invalid sort() argument. Must be a string or object.');
  }

  return this.append({ $sort: sort });
};


Aggregate.prototype.unionWith = function(options) {
  return this.append({ $unionWith: options });
};



Aggregate.prototype.read = function(pref, tags) {
  read.call(this, pref, tags);
  return this;
};


Aggregate.prototype.readConcern = function(level) {
  readConcern.call(this, level);
  return this;
};


Aggregate.prototype.redact = function(expression, thenExpr, elseExpr) {
  if (arguments.length === 3) {
    if ((typeof thenExpr === 'string' && !validRedactStringValues.has(thenExpr)) ||
      (typeof elseExpr === 'string' && !validRedactStringValues.has(elseExpr))) {
      throw new Error('If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP');
    }

    expression = {
      $cond: {
        if: expression,
        then: thenExpr,
        else: elseExpr
      }
    };
  } else if (arguments.length !== 1) {
    throw new TypeError('Invalid arguments');
  }

  return this.append({ $redact: expression });
};


Aggregate.prototype.explain = async function explain(verbosity) {
  if (typeof verbosity === 'function' || typeof arguments[1] === 'function') {
    throw new MongooseError('Aggregate.prototype.explain() no longer accepts a callback');
  }
  const model = this._model;

  if (!this._pipeline.length) {
    throw new Error('Aggregate has empty pipeline');
  }

  prepareDiscriminatorPipeline(this._pipeline, this._model.schema);

  await new Promise((resolve, reject) => {
    model.hooks.execPre('aggregate', this, error => {
      if (error) {
        const _opts = { error: error };
        return model.hooks.execPost('aggregate', this, [null], _opts, error => {
          reject(error);
        });
      } else {
        resolve();
      }
    });
  });

  const cursor = model.collection.aggregate(this._pipeline, this.options);

  if (verbosity == null) {
    verbosity = true;
  }

  let result = null;
  try {
    result = await cursor.explain(verbosity);
  } catch (error) {
    await new Promise((resolve, reject) => {
      const _opts = { error: error };
      model.hooks.execPost('aggregate', this, [null], _opts, error => {
        if (error) {
          return reject(error);
        }
        return resolve();
      });
    });
  }

  const _opts = { error: null };
  await new Promise((resolve, reject) => {
    model.hooks.execPost('aggregate', this, [result], _opts, error => {
      if (error) {
        return reject(error);
      }
      return resolve();
    });
  });

  return result;
};


Aggregate.prototype.allowDiskUse = function(value) {
  this.options.allowDiskUse = value;
  return this;
};


Aggregate.prototype.hint = function(value) {
  this.options.hint = value;
  return this;
};


Aggregate.prototype.session = function(session) {
  if (session == null) {
    delete this.options.session;
  } else {
    this.options.session = session;
  }
  return this;
};


Aggregate.prototype.option = function(value) {
  for (const key in value) {
    this.options[key] = value[key];
  }
  return this;
};


Aggregate.prototype.cursor = function(options) {
  this._optionsForExec();
  this.options.cursor = options || {};
  return new AggregationCursor(this); 
};


Aggregate.prototype.collation = function(collation) {
  this.options.collation = collation;
  return this;
};


Aggregate.prototype.facet = function(options) {
  return this.append({ $facet: options });
};


Aggregate.prototype.search = function(options) {
  return this.append({ $search: options });
};


Aggregate.prototype.pipeline = function() {
  return this._pipeline;
};


Aggregate.prototype.exec = async function exec() {
  if (!this._model && !this._connection) {
    throw new Error('Aggregate not bound to any Model');
  }
  if (typeof arguments[0] === 'function') {
    throw new MongooseError('Aggregate.prototype.exec() no longer accepts a callback');
  }

  if (this._connection) {
    if (!this._pipeline.length) {
      throw new MongooseError('Aggregate has empty pipeline');
    }

    this._optionsForExec();

    const cursor = await this._connection.client.db().aggregate(this._pipeline, this.options);
    return await cursor.toArray();
  }

  const model = this._model;
  const collection = this._model.collection;

  applyGlobalMaxTimeMS(this.options, model.db.options, model.base.options);
  applyGlobalDiskUse(this.options, model.db.options, model.base.options);

  this._optionsForExec();

  if (this.options && this.options.cursor) {
    return new AggregationCursor(this);
  }

  prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
  stringifyFunctionOperators(this._pipeline);

  await new Promise((resolve, reject) => {
    model.hooks.execPre('aggregate', this, error => {
      if (error) {
        const _opts = { error: error };
        return model.hooks.execPost('aggregate', this, [null], _opts, error => {
          reject(error);
        });
      } else {
        resolve();
      }
    });
  });

  if (!this._pipeline.length) {
    throw new MongooseError('Aggregate has empty pipeline');
  }

  const options = clone(this.options || {});

  let result;
  try {
    const cursor = await collection.aggregate(this._pipeline, options);
    result = await cursor.toArray();
  } catch (error) {
    await new Promise((resolve, reject) => {
      const _opts = { error: error };
      model.hooks.execPost('aggregate', this, [null], _opts, (error) => {
        if (error) {
          return reject(error);
        }

        resolve();
      });
    });
  }

  const _opts = { error: null };
  await new Promise((resolve, reject) => {
    model.hooks.execPost('aggregate', this, [result], _opts, error => {
      if (error) {
        return reject(error);
      }
      return resolve();
    });
  });

  return result;
};

Aggregate.prototype.then = function(resolve, reject) {
  return this.exec().then(resolve, reject);
};


Aggregate.prototype.catch = function(reject) {
  return this.exec().then(null, reject);
};


Aggregate.prototype.finally = function(onFinally) {
  return this.exec().finally(onFinally);
};


if (Symbol.asyncIterator != null) {
  Aggregate.prototype[Symbol.asyncIterator] = function() {
    return this.cursor({ useMongooseAggCursor: true }).transformNull()._transformForAsyncIterator();
  };
}



function isOperator(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }

  const k = Object.keys(obj);

  return k.length === 1 && k[0][0] === '$';
}


Aggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;


module.exports = Aggregate;

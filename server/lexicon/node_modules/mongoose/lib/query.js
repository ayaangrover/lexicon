'use strict';


const CastError = require('./error/cast');
const DocumentNotFoundError = require('./error/notFound');
const Kareem = require('kareem');
const MongooseError = require('./error/mongooseError');
const ObjectParameterError = require('./error/objectParameter');
const QueryCursor = require('./cursor/queryCursor');
const ValidationError = require('./error/validation');
const { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require('./helpers/query/applyGlobalOption');
const handleReadPreferenceAliases = require('./helpers/query/handleReadPreferenceAliases');
const applyReadConcern = require('./helpers/schema/applyReadConcern');
const applyWriteConcern = require('./helpers/schema/applyWriteConcern');
const cast = require('./cast');
const castArrayFilters = require('./helpers/update/castArrayFilters');
const castNumber = require('./cast/number');
const castUpdate = require('./helpers/query/castUpdate');
const clone = require('./helpers/clone');
const getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');
const helpers = require('./queryHelpers');
const internalToObjectOptions = require('./options').internalToObjectOptions;
const isExclusive = require('./helpers/projection/isExclusive');
const isInclusive = require('./helpers/projection/isInclusive');
const isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');
const isSubpath = require('./helpers/projection/isSubpath');
const mpath = require('mpath');
const mquery = require('mquery');
const parseProjection = require('./helpers/projection/parseProjection');
const removeUnusedArrayFilters = require('./helpers/update/removeUnusedArrayFilters');
const sanitizeFilter = require('./helpers/query/sanitizeFilter');
const sanitizeProjection = require('./helpers/query/sanitizeProjection');
const selectPopulatedFields = require('./helpers/query/selectPopulatedFields');
const setDefaultsOnInsert = require('./helpers/setDefaultsOnInsert');
const specialProperties = require('./helpers/specialProperties');
const updateValidators = require('./helpers/updateValidators');
const util = require('util');
const utils = require('./utils');
const queryMiddlewareFunctions = require('./constants').queryMiddlewareFunctions;

const queryOptionMethods = new Set([
  'allowDiskUse',
  'batchSize',
  'collation',
  'comment',
  'explain',
  'hint',
  'j',
  'lean',
  'limit',
  'maxTimeMS',
  'populate',
  'projection',
  'read',
  'select',
  'skip',
  'slice',
  'sort',
  'tailable',
  'w',
  'writeConcern',
  'wtimeout'
]);




const opToThunk = new Map([
  ['countDocuments', '_countDocuments'],
  ['distinct', '__distinct'],
  ['estimatedDocumentCount', '_estimatedDocumentCount'],
  ['find', '_find'],
  ['findOne', '_findOne'],
  ['findOneAndReplace', '_findOneAndReplace'],
  ['findOneAndUpdate', '_findOneAndUpdate'],
  ['replaceOne', '_replaceOne'],
  ['updateMany', '_updateMany'],
  ['updateOne', '_updateOne'],
  ['deleteMany', '_deleteMany'],
  ['deleteOne', '_deleteOne'],
  ['findOneAndDelete', '_findOneAndDelete']
]);


function Query(conditions, options, model, collection) {
  
  if (!this._mongooseOptions) {
    this._mongooseOptions = {};
  }
  options = options || {};

  this._transforms = [];
  this._hooks = new Kareem();
  this._executionStack = null;

  
  
  const keys = Object.keys(options);
  for (const key of keys) {
    this._mongooseOptions[key] = options[key];
  }

  if (collection) {
    this.mongooseCollection = collection;
  }

  if (model) {
    this.model = model;
    this.schema = model.schema;
  }

  
  
  if (this.model && this.model._mapreduce) {
    this.lean();
  }

  
  mquery.call(this, null, options);
  if (collection) {
    this.collection(collection);
  }

  if (conditions) {
    this.find(conditions);
  }

  this.options = this.options || {};

  
  
  this.$useProjection = true;

  const collation = this &&
    this.schema &&
    this.schema.options &&
    this.schema.options.collation || null;
  if (collation != null) {
    this.options.collation = collation;
  }
}


Query.prototype = new mquery();
Query.prototype.constructor = Query;



Query.prototype.count = undefined;
Query.prototype.findOneAndRemove = undefined;

Query.base = mquery.prototype;


Object.defineProperty(Query.prototype, '_distinct', {
  configurable: true,
  writable: true,
  enumerable: true,
  value: undefined
});


Query.use$geoWithin = mquery.use$geoWithin;


Query.prototype.toConstructor = function toConstructor() {
  const model = this.model;
  const coll = this.mongooseCollection;

  const CustomQuery = function(criteria, options) {
    if (!(this instanceof CustomQuery)) {
      return new CustomQuery(criteria, options);
    }
    this._mongooseOptions = clone(p._mongooseOptions);
    Query.call(this, criteria, options || null, model, coll);
  };

  util.inherits(CustomQuery, model.Query);

  
  const p = CustomQuery.prototype;

  p.options = {};

  
  
  
  const options = Object.assign({}, this.options);
  if (options.sort != null) {
    p.sort(options.sort);
    delete options.sort;
  }
  p.setOptions(options);

  p.op = this.op;
  p._validateOp();
  p._conditions = clone(this._conditions);
  p._fields = clone(this._fields);
  p._update = clone(this._update, {
    flattenDecimals: false
  });
  p._path = this._path;
  p._distinct = this._distinct;
  p._collection = this._collection;
  p._mongooseOptions = this._mongooseOptions;

  return CustomQuery;
};


Query.prototype.clone = function() {
  const model = this.model;
  const collection = this.mongooseCollection;

  const q = new this.model.Query({}, {}, model, collection);

  
  
  
  const options = Object.assign({}, this.options);
  if (options.sort != null) {
    q.sort(options.sort);
    delete options.sort;
  }
  q.setOptions(options);

  q.op = this.op;
  q._validateOp();
  q._conditions = clone(this._conditions);
  q._fields = clone(this._fields);
  q._update = clone(this._update, {
    flattenDecimals: false
  });
  q._path = this._path;
  q._distinct = this._distinct;
  q._collection = this._collection;
  q._mongooseOptions = this._mongooseOptions;

  return q;
};




Query.prototype.slice = function() {
  if (arguments.length === 0) {
    return this;
  }

  this._validate('slice');

  let path;
  let val;

  if (arguments.length === 1) {
    const arg = arguments[0];
    if (typeof arg === 'object' && !Array.isArray(arg)) {
      const keys = Object.keys(arg);
      const numKeys = keys.length;
      for (let i = 0; i < numKeys; ++i) {
        this.slice(keys[i], arg[keys[i]]);
      }
      return this;
    }
    this._ensurePath('slice');
    path = this._path;
    val = arguments[0];
  } else if (arguments.length === 2) {
    if ('number' === typeof arguments[0]) {
      this._ensurePath('slice');
      path = this._path;
      val = [arguments[0], arguments[1]];
    } else {
      path = arguments[0];
      val = arguments[1];
    }
  } else if (arguments.length === 3) {
    path = arguments[0];
    val = [arguments[1], arguments[2]];
  }

  const p = {};
  p[path] = { $slice: val };
  this.select(p);

  return this;
};


const validOpsSet = new Set(queryMiddlewareFunctions);

Query.prototype._validateOp = function() {
  if (this.op != null && !validOpsSet.has(this.op)) {
    this.error(new Error('Query has invalid `op`: "' + this.op + '"'));
  }
};

















Query.prototype.mod = function() {
  let val;
  let path;

  if (arguments.length === 1) {
    this._ensurePath('mod');
    val = arguments[0];
    path = this._path;
  } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
    this._ensurePath('mod');
    val = [arguments[0], arguments[1]];
    path = this._path;
  } else if (arguments.length === 3) {
    val = [arguments[1], arguments[2]];
    path = arguments[0];
  } else {
    val = arguments[1];
    path = arguments[0];
  }

  const conds = this._conditions[path] || (this._conditions[path] = {});
  conds.$mod = val;
  return this;
};





Query.prototype.limit = function limit(v) {
  this._validate('limit');

  if (typeof v === 'string') {
    try {
      v = castNumber(v);
    } catch (err) {
      throw new CastError('Number', v, 'limit');
    }
  }

  this.options.limit = v;
  return this;
};


Query.prototype.skip = function skip(v) {
  this._validate('skip');

  if (typeof v === 'string') {
    try {
      v = castNumber(v);
    } catch (err) {
      throw new CastError('Number', v, 'skip');
    }
  }

  this.options.skip = v;
  return this;
};





Query.prototype.projection = function(arg) {
  if (arguments.length === 0) {
    return this._fields;
  }

  this._fields = {};
  this._userProvidedFields = {};
  this.select(arg);
  return this._fields;
};


Query.prototype.select = function select() {
  let arg = arguments[0];
  if (!arg) return this;

  if (arguments.length !== 1) {
    throw new Error('Invalid select: select only takes 1 argument');
  }

  this._validate('select');

  const fields = this._fields || (this._fields = {});
  const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});
  let sanitizeProjection = undefined;
  if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, 'sanitizeProjection')) {
    sanitizeProjection = this.model.db.options.sanitizeProjection;
  } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, 'sanitizeProjection')) {
    sanitizeProjection = this.model.base.options.sanitizeProjection;
  } else {
    sanitizeProjection = this._mongooseOptions.sanitizeProjection;
  }

  function sanitizeValue(value) {
    return typeof value === 'string' && sanitizeProjection ? value = 1 : value;
  }
  arg = parseProjection(arg, true); 
  if (utils.isObject(arg)) {
    if (this.selectedInclusively()) {
      Object.entries(arg).forEach(([key, value]) => {
        if (value) {
          
          if (fields['-' + key] != null) {
            delete fields['-' + key];
          }
          fields[key] = userProvidedFields[key] = sanitizeValue(value);
        } else {
          
          Object.keys(userProvidedFields).forEach(field => {
            if (isSubpath(key, field)) {
              delete fields[field];
              delete userProvidedFields[field];
            }
          });
        }
      });
    } else if (this.selectedExclusively()) {
      Object.entries(arg).forEach(([key, value]) => {
        if (!value) {
          
          if (fields['+' + key] != null) {
            delete fields['+' + key];
          }
          fields[key] = userProvidedFields[key] = sanitizeValue(value);
        } else {
          
          Object.keys(userProvidedFields).forEach(field => {
            if (isSubpath(key, field)) {
              delete fields[field];
              delete userProvidedFields[field];
            }
          });
        }
      });
    } else {
      const keys = Object.keys(arg);
      for (let i = 0; i < keys.length; ++i) {
        const value = arg[keys[i]];
        const key = keys[i];
        fields[key] = sanitizeValue(value);
        userProvidedFields[key] = sanitizeValue(value);
      }
    }

    return this;
  }

  throw new TypeError('Invalid select() argument. Must be string or object.');
};


Query.prototype.schemaLevelProjections = function schemaLevelProjections(value) {
  this._mongooseOptions.schemaLevelProjections = value;

  return this;
};


Query.prototype.sanitizeProjection = function sanitizeProjection(value) {
  this._mongooseOptions.sanitizeProjection = value;

  return this;
};


Query.prototype.read = function read(mode, tags) {
  if (typeof mode === 'string') {
    mode = handleReadPreferenceAliases(mode);
    this.options.readPreference = { mode, tags };
  } else {
    this.options.readPreference = mode;
  }
  return this;
};


Query.prototype.toString = function toString() {
  if (this.op === 'count' ||
      this.op === 'countDocuments' ||
      this.op === 'find' ||
      this.op === 'findOne' ||
      this.op === 'deleteMany' ||
      this.op === 'deleteOne' ||
      this.op === 'findOneAndDelete' ||
      this.op === 'remove') {
    return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)})`;
  }
  if (this.op === 'distinct') {
    return `${this.model.modelName}.distinct('${this._distinct}', ${util.inspect(this._conditions)})`;
  }
  if (this.op === 'findOneAndReplace' ||
      this.op === 'findOneAndUpdate' ||
      this.op === 'replaceOne' ||
      this.op === 'update' ||
      this.op === 'updateMany' ||
      this.op === 'updateOne') {
    return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)}, ${util.inspect(this._update)})`;
  }

  
  return `${this.model.modelName}.${this.op}()`;
};


Query.prototype.session = function session(v) {
  if (v == null) {
    delete this.options.session;
  }
  this.options.session = v;
  return this;
};


Query.prototype.writeConcern = function writeConcern(val) {
  if (val == null) {
    delete this.options.writeConcern;
    return this;
  }
  this.options.writeConcern = val;
  return this;
};


Query.prototype.w = function w(val) {
  if (val == null) {
    delete this.options.w;
  }
  if (this.options.writeConcern != null) {
    this.options.writeConcern.w = val;
  } else {
    this.options.w = val;
  }
  return this;
};


Query.prototype.j = function j(val) {
  if (val == null) {
    delete this.options.j;
  }
  if (this.options.writeConcern != null) {
    this.options.writeConcern.j = val;
  } else {
    this.options.j = val;
  }
  return this;
};


Query.prototype.wtimeout = function wtimeout(ms) {
  if (ms == null) {
    delete this.options.wtimeout;
  }
  if (this.options.writeConcern != null) {
    this.options.writeConcern.wtimeout = ms;
  } else {
    this.options.wtimeout = ms;
  }
  return this;
};



Query.prototype.getOptions = function() {
  return this.options;
};


Query.prototype.setOptions = function(options, overwrite) {
  
  if (overwrite) {
    
    this._mongooseOptions = (options && clone(options)) || {};
    this.options = options || {};

    if ('populate' in options) {
      this.populate(this._mongooseOptions);
    }
    return this;
  }
  if (options == null) {
    return this;
  }
  if (typeof options !== 'object') {
    throw new Error('Options must be an object, got "' + options + '"');
  }

  options = Object.assign({}, options);

  if (Array.isArray(options.populate)) {
    const populate = options.populate;
    delete options.populate;
    const _numPopulate = populate.length;
    for (let i = 0; i < _numPopulate; ++i) {
      this.populate(populate[i]);
    }
  }

  if ('setDefaultsOnInsert' in options) {
    this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;
    delete options.setDefaultsOnInsert;
  }
  if ('overwriteDiscriminatorKey' in options) {
    this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;
    delete options.overwriteDiscriminatorKey;
  }
  if ('overwriteImmutable' in options) {
    this._mongooseOptions.overwriteImmutable = options.overwriteImmutable;
    delete options.overwriteImmutable;
  }
  if ('sanitizeProjection' in options) {
    if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {
      sanitizeProjection(this._fields);
    }

    this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;
    delete options.sanitizeProjection;
  }
  if ('sanitizeFilter' in options) {
    this._mongooseOptions.sanitizeFilter = options.sanitizeFilter;
    delete options.sanitizeFilter;
  }
  if ('timestamps' in options) {
    this._mongooseOptions.timestamps = options.timestamps;
    delete options.timestamps;
  }
  if ('defaults' in options) {
    this._mongooseOptions.defaults = options.defaults;
    
  }
  if ('translateAliases' in options) {
    this._mongooseOptions.translateAliases = options.translateAliases;
    delete options.translateAliases;
  }
  if ('schemaLevelProjections' in options) {
    this._mongooseOptions.schemaLevelProjections = options.schemaLevelProjections;
    delete options.schemaLevelProjections;
  }

  if (options.lean == null && this.schema && 'lean' in this.schema.options) {
    this._mongooseOptions.lean = this.schema.options.lean;
  }

  if (typeof options.limit === 'string') {
    try {
      options.limit = castNumber(options.limit);
    } catch (err) {
      throw new CastError('Number', options.limit, 'limit');
    }
  }
  if (typeof options.skip === 'string') {
    try {
      options.skip = castNumber(options.skip);
    } catch (err) {
      throw new CastError('Number', options.skip, 'skip');
    }
  }

  
  for (const key of Object.keys(options)) {
    if (queryOptionMethods.has(key)) {
      const args = Array.isArray(options[key]) ?
        options[key] :
        [options[key]];
      this[key].apply(this, args);
    } else {
      this.options[key] = options[key];
    }
  }

  return this;
};


Query.prototype.explain = function explain(verbose) {
  if (arguments.length === 0) {
    this.options.explain = true;
  } else if (verbose === false) {
    delete this.options.explain;
  } else {
    this.options.explain = verbose;
  }
  return this;
};


Query.prototype.allowDiskUse = function(v) {
  if (arguments.length === 0) {
    this.options.allowDiskUse = true;
  } else if (v === false) {
    delete this.options.allowDiskUse;
  } else {
    this.options.allowDiskUse = v;
  }
  return this;
};


Query.prototype.maxTimeMS = function(ms) {
  this.options.maxTimeMS = ms;
  return this;
};


Query.prototype.getFilter = function() {
  return this._conditions;
};


Query.prototype.getQuery = function() {
  return this._conditions;
};


Query.prototype.setQuery = function(val) {
  this._conditions = val;
};


Query.prototype.getUpdate = function() {
  return this._update;
};


Query.prototype.setUpdate = function(val) {
  this._update = val;
};


Query.prototype._fieldsForExec = function() {
  if (this._fields == null) {
    return null;
  }
  if (Object.keys(this._fields).length === 0) {
    return null;
  }
  return clone(this._fields);
};



Query.prototype._updateForExec = function() {
  const update = clone(this._update, {
    transform: false,
    depopulate: true
  });
  const ops = Object.keys(update);
  let i = ops.length;
  const ret = {};

  while (i--) {
    const op = ops[i];

    if ('$' !== op[0]) {
      
      if (!ret.$set) {
        if (update.$set) {
          ret.$set = update.$set;
        } else {
          ret.$set = {};
        }
      }
      ret.$set[op] = update[op];
      ops.splice(i, 1);
      if (!~ops.indexOf('$set')) ops.push('$set');
    } else if ('$set' === op) {
      if (!ret.$set) {
        ret[op] = update[op];
      }
    } else {
      ret[op] = update[op];
    }
  }

  return ret;
};




Query.prototype._optionsForExec = function(model) {
  const options = clone(this.options);
  delete options.populate;
  model = model || this.model;

  if (!model) {
    return options;
  }
  applyReadConcern(model.schema, options);
  
  applyWriteConcern(model.schema, options);

  const asyncLocalStorage = this.model?.db?.base.transactionAsyncLocalStorage?.getStore();
  if (!this.options.hasOwnProperty('session') && asyncLocalStorage?.session != null) {
    options.session = asyncLocalStorage.session;
  }

  const readPreference = model &&
  model.schema &&
  model.schema.options &&
  model.schema.options.read;
  if (!('readPreference' in options) && readPreference) {
    options.readPreference = readPreference;
  }

  if (options.upsert !== void 0) {
    options.upsert = !!options.upsert;
  }
  if (options.writeConcern) {
    if (options.j) {
      options.writeConcern.j = options.j;
      delete options.j;
    }
    if (options.w) {
      options.writeConcern.w = options.w;
      delete options.w;
    }
    if (options.wtimeout) {
      options.writeConcern.wtimeout = options.wtimeout;
      delete options.wtimeout;
    }
  }

  this._applyPaths();
  if (this._fields != null) {
    this._fields = this._castFields(this._fields);
    const projection = this._fieldsForExec();
    if (projection != null) {
      options.projection = projection;
    }
  }

  return options;
};


Query.prototype.lean = function(v) {
  this._mongooseOptions.lean = arguments.length ? v : true;
  return this;
};


Query.prototype.set = function(path, val) {
  if (typeof path === 'object') {
    const keys = Object.keys(path);
    for (const key of keys) {
      this.set(key, path[key]);
    }
    return this;
  }

  this._update = this._update || {};
  if (path in this._update) {
    delete this._update[path];
  }
  this._update.$set = this._update.$set || {};
  this._update.$set[path] = val;
  return this;
};


Query.prototype.get = function get(path) {
  const update = this._update;
  if (update == null) {
    return void 0;
  }
  const $set = update.$set;
  if ($set == null) {
    return update[path];
  }

  if (utils.hasUserDefinedProperty(update, path)) {
    return update[path];
  }
  if (utils.hasUserDefinedProperty($set, path)) {
    return $set[path];
  }

  return void 0;
};


Query.prototype.error = function error(err) {
  if (arguments.length === 0) {
    return this._error;
  }

  this._error = err;
  return this;
};


Query.prototype._unsetCastError = function _unsetCastError() {
  if (this._error == null || !(this._error instanceof CastError)) {
    return;
  }
  return this.error(null);
};


Query.prototype.mongooseOptions = function(v) {
  if (arguments.length > 0) {
    this._mongooseOptions = v;
  }
  return this._mongooseOptions;
};


Query.prototype._castConditions = function() {
  let sanitizeFilterOpt = undefined;
  if (this.model?.db.options?.sanitizeFilter != null) {
    sanitizeFilterOpt = this.model.db.options.sanitizeFilter;
  } else if (this.model?.base.options?.sanitizeFilter != null) {
    sanitizeFilterOpt = this.model.base.options.sanitizeFilter;
  } else {
    sanitizeFilterOpt = this._mongooseOptions.sanitizeFilter;
  }

  if (sanitizeFilterOpt) {
    sanitizeFilter(this._conditions);
  }

  try {
    this.cast(this.model);
    this._unsetCastError();
  } catch (err) {
    this.error(err);
  }
};


function _castArrayFilters(query) {
  try {
    castArrayFilters(query);
  } catch (err) {
    query.error(err);
  }
}

Query.prototype._find = async function _find() {
  this._applyTranslateAliases();
  this._castConditions();

  if (this.error() != null) {
    throw this.error();
  }

  const mongooseOptions = this._mongooseOptions;
  const userProvidedFields = this._userProvidedFields || {};

  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);

  
  
  const completeManyOptions = {
    session: this && this.options && this.options.session || null,
    lean: mongooseOptions.lean || null
  };

  const options = this._optionsForExec();

  const filter = this._conditions;
  const fields = options.projection;

  const cursor = await this.mongooseCollection.find(filter, options);
  if (options.explain) {
    return cursor.explain();
  }

  let docs = await cursor.toArray();
  if (docs.length === 0) {
    return docs;
  }

  if (!mongooseOptions.populate) {
    const versionKey = this.schema.options.versionKey;
    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
      docs.forEach((doc) => {
        if (versionKey in doc) {
          delete doc[versionKey];
        }
      });
    }
    return mongooseOptions.lean ?
      _completeManyLean(this.model.schema, docs, null, completeManyOptions) :
      this._completeMany(docs, fields, userProvidedFields, completeManyOptions);
  }

  const pop = helpers.preparePopulationOptionsMQ(this, mongooseOptions);

  if (mongooseOptions.lean) {
    return this.model.populate(docs, pop);
  }

  docs = await this._completeMany(docs, fields, userProvidedFields, completeManyOptions);
  await this.model.populate(docs, pop);

  return docs;
};


Query.prototype.find = function(conditions) {
  if (typeof conditions === 'function' ||
      typeof arguments[1] === 'function') {
    throw new MongooseError('Query.prototype.find() no longer accepts a callback');
  }

  this.op = 'find';

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);

    prepareDiscriminatorCriteria(this);
  } else if (conditions != null) {
    this.error(new ObjectParameterError(conditions, 'filter', 'find'));
  }

  return this;
};


Query.prototype.merge = function(source) {
  if (!source) {
    return this;
  }

  const opts = { overwrite: true };

  if (source instanceof Query) {
    

    if (source._conditions) {
      opts.omit = {};
      if (this._conditions && this._conditions.$and && source._conditions.$and) {
        opts.omit['$and'] = true;
        this._conditions.$and = this._conditions.$and.concat(source._conditions.$and);
      }
      if (this._conditions && this._conditions.$or && source._conditions.$or) {
        opts.omit['$or'] = true;
        this._conditions.$or = this._conditions.$or.concat(source._conditions.$or);
      }
      utils.merge(this._conditions, source._conditions, opts);
    }

    if (source._fields) {
      this._fields || (this._fields = {});
      utils.merge(this._fields, source._fields, opts);
    }

    if (source.options) {
      this.options || (this.options = {});
      utils.merge(this.options, source.options, opts);
    }

    if (source._update) {
      this._update || (this._update = {});
      utils.mergeClone(this._update, source._update);
    }

    if (source._distinct) {
      this._distinct = source._distinct;
    }

    utils.merge(this._mongooseOptions, source._mongooseOptions);

    return this;
  } else if (this.model != null && source instanceof this.model.base.Types.ObjectId) {
    utils.merge(this._conditions, { _id: source }, opts);

    return this;
  } else if (source && source.$__) {
    source = source.toObject(internalToObjectOptions);
  }

  opts.omit = {};
  if (Array.isArray(source.$and)) {
    opts.omit['$and'] = true;
    if (!this._conditions) {
      this._conditions = {};
    }
    this._conditions.$and = (this._conditions.$and || []).concat(
      source.$and.map(el => utils.isPOJO(el) ? utils.merge({}, el) : el)
    );
  }
  if (Array.isArray(source.$or)) {
    opts.omit['$or'] = true;
    if (!this._conditions) {
      this._conditions = {};
    }
    this._conditions.$or = (this._conditions.$or || []).concat(
      source.$or.map(el => utils.isPOJO(el) ? utils.merge({}, el) : el)
    );
  }

  
  utils.merge(this._conditions, source, opts);

  return this;
};


Query.prototype.collation = function(value) {
  if (this.options == null) {
    this.options = {};
  }
  this.options.collation = value;
  return this;
};


Query.prototype._completeOne = function(doc, res, projection, callback) {
  if (!doc && !this.options.includeResultMetadata) {
    return callback(null, null);
  }

  const model = this.model;
  const userProvidedFields = this._userProvidedFields || {};
  
  const mongooseOptions = this._mongooseOptions;

  const options = this.options;
  if (!options.lean && mongooseOptions.lean) {
    options.lean = mongooseOptions.lean;
  }

  if (options.explain) {
    return callback(null, doc);
  }

  if (!mongooseOptions.populate) {
    const versionKey = this.schema.options.versionKey;
    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
      if (versionKey in doc) {
        delete doc[versionKey];
      }
    }
    return mongooseOptions.lean ?
      _completeOneLean(model.schema, doc, null, res, options, callback) :
      completeOne(model, doc, res, options, projection, userProvidedFields,
        null, callback);
  }

  const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);
  if (mongooseOptions.lean) {
    return model.populate(doc, pop).then(
      doc => {
        _completeOneLean(model.schema, doc, null, res, options, callback);
      },
      error => {
        callback(error);
      }
    );
  }

  completeOne(model, doc, res, options, projection, userProvidedFields, [], (err, doc) => {
    if (err != null) {
      return callback(err);
    }
    model.populate(doc, pop).then(res => { callback(null, res); }, err => { callback(err); });
  });
};


Query.prototype._completeMany = async function _completeMany(docs, fields, userProvidedFields, opts) {
  const model = this.model;
  return Promise.all(docs.map(doc => new Promise((resolve, reject) => {
    const rawDoc = doc;
    doc = helpers.createModel(model, doc, fields, userProvidedFields);
    if (opts.session != null) {
      doc.$session(opts.session);
    }
    doc.$init(rawDoc, opts, (err) => {
      if (err != null) {
        return reject(err);
      }
      resolve(doc);
    });
  })));
};


Query.prototype._findOne = async function _findOne() {
  this._applyTranslateAliases();
  this._castConditions();

  if (this.error()) {
    const err = this.error();
    throw err;
  }

  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);

  const options = this._optionsForExec();

  
  const doc = await this.mongooseCollection.findOne(this._conditions, options);
  return new Promise((resolve, reject) => {
    this._completeOne(doc, null, options.projection, (err, res) => {
      if (err) {
        return reject(err);
      }
      resolve(res);
    });
  });
};


Query.prototype.findOne = function(conditions, projection, options) {
  if (typeof conditions === 'function' ||
      typeof projection === 'function' ||
      typeof options === 'function' ||
      typeof arguments[3] === 'function') {
    throw new MongooseError('Query.prototype.findOne() no longer accepts a callback');
  }

  this.op = 'findOne';
  this._validateOp();

  if (options) {
    this.setOptions(options);
  }

  if (projection) {
    this.select(projection);
  }

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);

    prepareDiscriminatorCriteria(this);
  } else if (conditions != null) {
    this.error(new ObjectParameterError(conditions, 'filter', 'findOne'));
  }

  return this;
};



Query.prototype._countDocuments = async function _countDocuments() {
  this._applyTranslateAliases();

  try {
    this.cast(this.model);
  } catch (err) {
    this.error(err);
  }

  if (this.error()) {
    throw this.error();
  }

  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);

  const options = this._optionsForExec();

  const conds = this._conditions;

  return this.mongooseCollection.countDocuments(conds, options);
};


Query.prototype._applyTranslateAliases = function _applyTranslateAliases() {
  let applyTranslateAliases = false;
  if ('translateAliases' in this._mongooseOptions) {
    applyTranslateAliases = this._mongooseOptions.translateAliases;
  } else if (this.model?.schema?._userProvidedOptions?.translateAliases != null) {
    applyTranslateAliases = this.model.schema._userProvidedOptions.translateAliases;
  } else if (this.model?.base?.options?.translateAliases != null) {
    applyTranslateAliases = this.model.base.options.translateAliases;
  }
  if (!applyTranslateAliases) {
    return;
  }

  if (this.model?.schema?.aliases && Object.keys(this.model.schema.aliases).length > 0) {
    this.model.translateAliases(this._conditions, true);
    this.model.translateAliases(this._fields, true);
    this.model.translateAliases(this._update, true);
    if (this._distinct != null && this.model.schema.aliases[this._distinct] != null) {
      this._distinct = this.model.schema.aliases[this._distinct];
    }
  }
};


Query.prototype._estimatedDocumentCount = async function _estimatedDocumentCount() {
  if (this.error()) {
    throw this.error();
  }

  const options = this._optionsForExec();

  return this.mongooseCollection.estimatedDocumentCount(options);
};


Query.prototype.estimatedDocumentCount = function(options) {
  if (typeof options === 'function' ||
      typeof arguments[1] === 'function') {
    throw new MongooseError('Query.prototype.estimatedDocumentCount() no longer accepts a callback');
  }

  this.op = 'estimatedDocumentCount';
  this._validateOp();

  if (options != null) {
    this.setOptions(options);
  }

  return this;
};


Query.prototype.countDocuments = function(conditions, options) {
  if (typeof conditions === 'function' ||
      typeof options === 'function' ||
      typeof arguments[2] === 'function') {
    throw new MongooseError('Query.prototype.countDocuments() no longer accepts a callback');
  }

  this.op = 'countDocuments';
  this._validateOp();

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);
  }

  if (options != null) {
    this.setOptions(options);
  }

  return this;
};


Query.prototype.__distinct = async function __distinct() {
  this._applyTranslateAliases();
  this._castConditions();

  if (this.error()) {
    throw this.error();
  }

  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);

  const options = this._optionsForExec();

  return this.mongooseCollection.
    distinct(this._distinct, this._conditions, options);
};


Query.prototype.distinct = function(field, conditions, options) {
  if (typeof field === 'function' ||
      typeof conditions === 'function' ||
      typeof options === 'function' ||
      typeof arguments[3] === 'function') {
    throw new MongooseError('Query.prototype.distinct() no longer accepts a callback');
  }

  this.op = 'distinct';
  this._validateOp();

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);

    prepareDiscriminatorCriteria(this);
  } else if (conditions != null) {
    this.error(new ObjectParameterError(conditions, 'filter', 'distinct'));
  }

  if (field != null) {
    this._distinct = field;
  }

  if (options != null) {
    this.setOptions(options);
  }

  return this;
};


Query.prototype.sort = function(arg, options) {
  if (arguments.length > 2) {
    throw new Error('sort() takes at most 2 arguments');
  }
  if (options != null && typeof options !== 'object') {
    throw new Error('sort() options argument must be an object or nullish');
  }

  if (this.options.sort == null) {
    this.options.sort = {};
  }
  if (options && options.override) {
    this.options.sort = {};
  }
  const sort = this.options.sort;
  if (typeof arg === 'string') {
    const properties = arg.indexOf(' ') === -1 ? [arg] : arg.split(' ');
    for (let property of properties) {
      const ascend = '-' == property[0] ? -1 : 1;
      if (ascend === -1) {
        property = property.slice(1);
      }
      if (specialProperties.has(property)) {
        continue;
      }
      sort[property] = ascend;
    }
  } else if (Array.isArray(arg)) {
    for (const pair of arg) {
      if (!Array.isArray(pair)) {
        throw new TypeError('Invalid sort() argument, must be array of arrays');
      }
      const key = '' + pair[0];
      if (specialProperties.has(key)) {
        continue;
      }
      sort[key] = _handleSortValue(pair[1], key);
    }
  } else if (typeof arg === 'object' && arg != null && !(arg instanceof Map)) {
    for (const key of Object.keys(arg)) {
      if (specialProperties.has(key)) {
        continue;
      }
      sort[key] = _handleSortValue(arg[key], key);
    }
  } else if (arg instanceof Map) {
    for (let key of arg.keys()) {
      key = '' + key;
      if (specialProperties.has(key)) {
        continue;
      }
      sort[key] = _handleSortValue(arg.get(key), key);
    }
  } else if (arg != null) {
    throw new TypeError('Invalid sort() argument. Must be a string, object, array, or map.');
  }

  return this;
};


function _handleSortValue(val, key) {
  if (val === 1 || val === 'asc' || val === 'ascending') {
    return 1;
  }
  if (val === -1 || val === 'desc' || val === 'descending') {
    return -1;
  }
  if (val?.$meta != null) {
    return { $meta: val.$meta };
  }
  throw new TypeError('Invalid sort value: { ' + key + ': ' + val + ' }');
}


Query.prototype.deleteOne = function deleteOne(filter, options) {
  if (typeof filter === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Query.prototype.deleteOne() no longer accepts a callback');
  }
  this.op = 'deleteOne';
  this.setOptions(options);

  if (mquery.canMerge(filter)) {
    this.merge(filter);

    prepareDiscriminatorCriteria(this);
  } else if (filter != null) {
    this.error(new ObjectParameterError(filter, 'filter', 'deleteOne'));
  }

  return this;
};


Query.prototype._deleteOne = async function _deleteOne() {
  this._applyTranslateAliases();
  this._castConditions();

  if (this.error() != null) {
    throw this.error();
  }

  const options = this._optionsForExec();

  return this.mongooseCollection.deleteOne(this._conditions, options);
};


Query.prototype.deleteMany = function(filter, options) {
  if (typeof filter === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Query.prototype.deleteMany() no longer accepts a callback');
  }
  this.setOptions(options);
  this.op = 'deleteMany';

  if (mquery.canMerge(filter)) {
    this.merge(filter);

    prepareDiscriminatorCriteria(this);
  } else if (filter != null) {
    this.error(new ObjectParameterError(filter, 'filter', 'deleteMany'));
  }

  return this;
};


Query.prototype._deleteMany = async function _deleteMany() {
  this._applyTranslateAliases();
  this._castConditions();

  if (this.error() != null) {
    throw this.error();
  }

  const options = this._optionsForExec();

  return this.mongooseCollection.deleteMany(this._conditions, options);
};


function completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {
  if (options.includeResultMetadata && doc == null) {
    _init(null);
    return null;
  }

  helpers.createModelAndInit(model, doc, fields, userProvidedFields, options, pop, _init);

  function _init(err, casted) {
    if (err) {
      return callback(err);
    }


    if (options.includeResultMetadata) {
      if (doc && casted) {
        if (options.session != null) {
          casted.$session(options.session);
        }
        res.value = casted;
      } else {
        res.value = null;
      }
      return callback(null, res);
    }
    if (options.session != null) {
      casted.$session(options.session);
    }
    callback(null, casted);
  }
}


function prepareDiscriminatorCriteria(query) {
  if (!query || !query.model || !query.model.schema) {
    return;
  }

  const schema = query.model.schema;

  if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
    query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
  }
}


Query.prototype.findOneAndUpdate = function(filter, doc, options) {
  if (typeof filter === 'function' ||
      typeof doc === 'function' ||
      typeof options === 'function' ||
      typeof arguments[3] === 'function') {
    throw new MongooseError('Query.prototype.findOneAndUpdate() no longer accepts a callback');
  }

  this.op = 'findOneAndUpdate';
  this._validateOp();
  this._validate();

  switch (arguments.length) {
    case 2:
      options = undefined;
      break;
    case 1:
      doc = filter;
      filter = options = undefined;
      break;
  }

  if (mquery.canMerge(filter)) {
    this.merge(filter);
  } else if (filter != null) {
    this.error(
      new ObjectParameterError(filter, 'filter', 'findOneAndUpdate')
    );
  }

  
  if (doc) {
    this._mergeUpdate(doc);
  }

  options = options ? clone(options) : {};

  if (options.projection) {
    this.select(options.projection);
    delete options.projection;
  }
  if (options.fields) {
    this.select(options.fields);
    delete options.fields;
  }

  const returnOriginal = this &&
    this.model &&
    this.model.base &&
    this.model.base.options &&
    this.model.base.options.returnOriginal;
  if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
    options.returnOriginal = returnOriginal;
  }

  this.setOptions(options);

  return this;
};


Query.prototype._findOneAndUpdate = async function _findOneAndUpdate() {
  this._applyTranslateAliases();
  this._castConditions();

  _castArrayFilters(this);

  if (this.error()) {
    throw this.error();
  }

  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);

  if ('strict' in this.options) {
    this._mongooseOptions.strict = this.options.strict;
  }
  const options = this._optionsForExec(this.model);
  convertNewToReturnDocument(options);

  this._update = this._castUpdate(this._update);

  const _opts = Object.assign({}, options, {
    setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
  });
  this._update = setDefaultsOnInsert(this._conditions, this.model.schema,
    this._update, _opts);

  if (!this._update || Object.keys(this._update).length === 0) {
    if (options.upsert) {
      
      const $set = clone(this._update);
      delete $set._id;
      this._update = { $set };
    } else {
      this._executionStack = null;
      const res = await this._findOne();
      return res;
    }
  } else if (this._update instanceof Error) {
    throw this._update;
  } else {
    
    
    
    if (this._update.$set && Object.keys(this._update.$set).length === 0) {
      delete this._update.$set;
    }
  }

  const runValidators = _getOption(this, 'runValidators', false);
  if (runValidators) {
    await this.validate(this._update, options, false);
  }

  if (this._update.toBSON) {
    this._update = this._update.toBSON();
  }

  let res = await this.mongooseCollection.findOneAndUpdate(this._conditions, this._update, options);
  for (const fn of this._transforms) {
    res = fn(res);
  }
  const doc = !options.includeResultMetadata ? res : res.value;

  return new Promise((resolve, reject) => {
    this._completeOne(doc, res, options.projection, (err, res) => {
      if (err) {
        return reject(err);
      }
      resolve(res);
    });
  });
};


Query.prototype.findOneAndDelete = function(filter, options) {
  if (typeof filter === 'function' ||
      typeof options === 'function' ||
      typeof arguments[2] === 'function') {
    throw new MongooseError('Query.prototype.findOneAndDelete() no longer accepts a callback');
  }

  this.op = 'findOneAndDelete';
  this._validateOp();
  this._validate();

  if (mquery.canMerge(filter)) {
    this.merge(filter);
  }

  options && this.setOptions(options);

  return this;
};

Query.prototype._findOneAndDelete = async function _findOneAndDelete() {
  this._applyTranslateAliases();
  this._castConditions();

  if (this.error() != null) {
    throw this.error();
  }

  const includeResultMetadata = this.options.includeResultMetadata;

  const filter = this._conditions;
  const options = this._optionsForExec(this.model);

  let res = await this.mongooseCollection.findOneAndDelete(filter, options);
  for (const fn of this._transforms) {
    res = fn(res);
  }
  const doc = !includeResultMetadata ? res : res.value;

  return new Promise((resolve, reject) => {
    this._completeOne(doc, res, options.projection, (err, res) => {
      if (err) {
        return reject(err);
      }
      resolve(res);
    });
  });
};


Query.prototype.findOneAndReplace = function(filter, replacement, options) {
  if (typeof filter === 'function' ||
      typeof replacement === 'function' ||
      typeof options === 'function' ||
      typeof arguments[4] === 'function') {
    throw new MongooseError('Query.prototype.findOneAndReplace() no longer accepts a callback');
  }

  this.op = 'findOneAndReplace';
  this._validateOp();
  this._validate();

  if (mquery.canMerge(filter)) {
    this.merge(filter);
  } else if (filter != null) {
    this.error(
      new ObjectParameterError(filter, 'filter', 'findOneAndReplace')
    );
  }

  if (replacement != null) {
    this._mergeUpdate(replacement);
  }

  options = options || {};

  const returnOriginal = this &&
  this.model &&
  this.model.base &&
  this.model.base.options &&
  this.model.base.options.returnOriginal;
  if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
    options.returnOriginal = returnOriginal;
  }
  this.setOptions(options);

  return this;
};

Query.prototype._findOneAndReplace = async function _findOneAndReplace() {
  this._applyTranslateAliases();
  this._castConditions();
  if (this.error() != null) {
    throw this.error();
  }

  if ('strict' in this.options) {
    this._mongooseOptions.strict = this.options.strict;
    delete this.options.strict;
  }

  const filter = this._conditions;
  const options = this._optionsForExec();
  convertNewToReturnDocument(options);

  const includeResultMetadata = this.options.includeResultMetadata;

  const modelOpts = { skipId: true };
  if ('strict' in this._mongooseOptions) {
    modelOpts.strict = this._mongooseOptions.strict;
  }

  const runValidators = _getOption(this, 'runValidators', false);

  try {
    const update = new this.model(this._update, null, modelOpts);
    if (runValidators) {
      await update.validate();
    } else if (update.$__.validationError) {
      throw update.$__.validationError;
    }
    this._update = update.toBSON();
  } catch (err) {
    if (err instanceof ValidationError) {
      throw err;
    }
    const validationError = new ValidationError();
    validationError.errors[err.path] = err;
    throw validationError;
  }

  let res = await this.mongooseCollection.findOneAndReplace(filter, this._update, options);

  for (const fn of this._transforms) {
    res = fn(res);
  }

  const doc = !includeResultMetadata ? res : res.value;
  return new Promise((resolve, reject) => {
    this._completeOne(doc, res, options.projection, (err, res) => {
      if (err) {
        return reject(err);
      }
      resolve(res);
    });
  });
};


function convertNewToReturnDocument(options) {
  if ('new' in options) {
    options.returnDocument = options['new'] ? 'after' : 'before';
    delete options['new'];
  }
  if ('returnOriginal' in options) {
    options.returnDocument = options['returnOriginal'] ? 'before' : 'after';
    delete options['returnOriginal'];
  }
  
  if (typeof options.returnDocument === 'string') {
    options.returnOriginal = options.returnDocument === 'before';
  }
}


function _getOption(query, option, def) {
  const opts = query._optionsForExec(query.model);

  if (option in opts) {
    return opts[option];
  }
  if (option in query.model.base.options) {
    return query.model.base.options[option];
  }
  return def;
}


function _completeOneLean(schema, doc, path, res, opts, callback) {
  if (opts.lean && typeof opts.lean.transform === 'function') {
    opts.lean.transform(doc);

    for (let i = 0; i < schema.childSchemas.length; i++) {
      const childPath = path ? path + '.' + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
      const _schema = schema.childSchemas[i].schema;
      const obj = mpath.get(childPath, doc);
      if (obj == null) {
        continue;
      }
      if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++) {
          opts.lean.transform(obj[i]);
        }
      } else {
        opts.lean.transform(obj);
      }
      _completeOneLean(_schema, obj, childPath, res, opts);
    }
    if (callback) {
      return callback(null, doc);
    } else {
      return;
    }
  }
  if (opts.includeResultMetadata) {
    return callback(null, res);
  }
  return callback(null, doc);
}


function _completeManyLean(schema, docs, path, opts) {
  if (opts.lean && typeof opts.lean.transform === 'function') {
    for (const doc of docs) {
      opts.lean.transform(doc);
    }

    for (let i = 0; i < schema.childSchemas.length; i++) {
      const childPath = path ? path + '.' + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
      const _schema = schema.childSchemas[i].schema;
      let doc = mpath.get(childPath, docs);
      if (doc == null) {
        continue;
      }
      doc = doc.flat();
      for (let i = 0; i < doc.length; i++) {
        opts.lean.transform(doc[i]);
      }
      _completeManyLean(_schema, doc, childPath, opts);
    }
  }

  return docs;
}

Query.prototype._mergeUpdate = function(doc) {
  if (!this._update) {
    this._update = Array.isArray(doc) ? [] : {};
  }

  if (doc == null || (typeof doc === 'object' && Object.keys(doc).length === 0)) {
    return;
  }

  if (doc instanceof Query) {
    if (Array.isArray(this._update)) {
      throw new Error('Cannot mix array and object updates');
    }
    if (doc._update) {
      utils.mergeClone(this._update, doc._update);
    }
  } else if (Array.isArray(doc)) {
    if (!Array.isArray(this._update)) {
      throw new Error('Cannot mix array and object updates');
    }
    this._update = this._update.concat(doc);
  } else {
    if (Array.isArray(this._update)) {
      throw new Error('Cannot mix array and object updates');
    }
    utils.mergeClone(this._update, doc);
  }
};


async function _updateThunk(op) {
  this._applyTranslateAliases();

  this._castConditions();

  _castArrayFilters(this);

  if (this.error() != null) {
    throw this.error();
  }

  const castedQuery = this._conditions;
  const options = this._optionsForExec(this.model);

  this._update = clone(this._update, options);
  const isOverwriting = op === 'replaceOne';
  if (isOverwriting) {
    this._update = new this.model(this._update, null, true);
  } else {
    this._update = this._castUpdate(this._update);

    if (this._update == null || Object.keys(this._update).length === 0) {
      return { acknowledged: false };
    }

    const _opts = Object.assign({}, options, {
      setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
    });
    this._update = setDefaultsOnInsert(this._conditions, this.model.schema,
      this._update, _opts);
  }

  if (Array.isArray(options.arrayFilters)) {
    options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);
  }

  const runValidators = _getOption(this, 'runValidators', false);
  if (runValidators) {
    await this.validate(this._update, options, isOverwriting);
  }

  if (this._update.toBSON) {
    this._update = this._update.toBSON();
  }

  return this.mongooseCollection[op](castedQuery, this._update, options);
}


Query.prototype.validate = async function validate(castedDoc, options, isOverwriting) {
  if (typeof arguments[3] === 'function') {
    throw new MongooseError('Query.prototype.validate() no longer accepts a callback');
  }

  await _executePreHooks(this, 'validate');

  if (isOverwriting) {
    await castedDoc.$validate();
  } else {
    await new Promise((resolve, reject) => {
      updateValidators(this, this.model.schema, castedDoc, options, (err) => {
        if (err != null) {
          return reject(err);
        }
        resolve();
      });
    });
  }

  await _executePostHooks(this, null, null, 'validate');
};

Query.prototype._updateMany = async function _updateMany() {
  return _updateThunk.call(this, 'updateMany');
};

Query.prototype._updateOne = async function _updateOne() {
  return _updateThunk.call(this, 'updateOne');
};

Query.prototype._replaceOne = async function _replaceOne() {
  return _updateThunk.call(this, 'replaceOne');
};


Query.prototype.updateMany = function(conditions, doc, options, callback) {
  if (typeof options === 'function') {
    
    callback = options;
    options = null;
  } else if (typeof doc === 'function') {
    
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === 'function') {
    
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
    
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  return _update(this, 'updateMany', conditions, doc, options, callback);
};


Query.prototype.updateOne = function(conditions, doc, options, callback) {
  if (typeof options === 'function') {
    
    callback = options;
    options = null;
  } else if (typeof doc === 'function') {
    
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === 'function') {
    
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
    
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  return _update(this, 'updateOne', conditions, doc, options, callback);
};


Query.prototype.replaceOne = function(conditions, doc, options, callback) {
  if (typeof options === 'function') {
    
    callback = options;
    options = null;
  } else if (typeof doc === 'function') {
    
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === 'function') {
    
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
    
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  return _update(this, 'replaceOne', conditions, doc, options, callback);
};


function _update(query, op, filter, doc, options, callback) {
  
  query.op = op;
  query._validateOp();
  doc = doc || {};

  
  if (options != null) {
    if ('strict' in options) {
      query._mongooseOptions.strict = options.strict;
    }
  }

  if (!(filter instanceof Query) &&
      filter != null &&
      filter.toString() !== '[object Object]') {
    query.error(new ObjectParameterError(filter, 'filter', op));
  } else {
    query.merge(filter);
  }

  if (utils.isObject(options)) {
    query.setOptions(options);
  }

  query._mergeUpdate(doc);

  
  if (callback) {
    query.exec(callback);

    return query;
  }

  return query;
}


Query.prototype.transform = function(fn) {
  this._transforms.push(fn);
  return this;
};


Query.prototype.orFail = function(err) {
  this.transform(res => {
    switch (this.op) {
      case 'find':
        if (res.length === 0) {
          throw _orFailError(err, this);
        }
        break;
      case 'findOne':
        if (res == null) {
          throw _orFailError(err, this);
        }
        break;
      case 'replaceOne':
      case 'updateMany':
      case 'updateOne':
        if (res && res.matchedCount === 0) {
          throw _orFailError(err, this);
        }
        break;
      case 'findOneAndDelete':
      case 'findOneAndUpdate':
      case 'findOneAndReplace':
        if (this.options.includeResultMetadata && res != null && res.value == null) {
          throw _orFailError(err, this);
        }
        if (!this.options.includeResultMetadata && res == null) {
          throw _orFailError(err, this);
        }
        break;
      case 'deleteMany':
      case 'deleteOne':
        if (res.deletedCount === 0) {
          throw _orFailError(err, this);
        }
        break;
      default:
        break;
    }

    return res;
  });
  return this;
};


function _orFailError(err, query) {
  if (typeof err === 'function') {
    err = err.call(query);
  }

  if (err == null) {
    err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);
  }

  return err;
}


Query.prototype.isPathSelectedInclusive = function(path) {
  return isPathSelectedInclusive(this._fields, path);
};


Query.prototype.exec = async function exec(op) {
  if (typeof op === 'function' || (arguments.length >= 2 && typeof arguments[1] === 'function')) {
    throw new MongooseError('Query.prototype.exec() no longer accepts a callback');
  }

  if (typeof op === 'string') {
    this.op = op;
  }

  if (this.op == null) {
    throw new MongooseError('Query must have `op` before executing');
  }
  if (this.model == null) {
    throw new MongooseError('Query must have an associated model before executing');
  }

  const thunk = opToThunk.get(this.op);
  if (!thunk) {
    throw new MongooseError('Query has invalid `op`: "' + this.op + '"');
  }

  if (this.options && this.options.sort && typeof this.options.sort === 'object' && this.options.sort.hasOwnProperty('')) {
    throw new Error('Invalid field "" passed to sort()');
  }

  if (this._executionStack != null) {
    let str = this.toString();
    if (str.length > 60) {
      str = str.slice(0, 60) + '...';
    }
    const err = new MongooseError('Query was already executed: ' + str);
    err.originalStack = this._executionStack;
    throw err;
  } else {
    this._executionStack = new Error().stack;
  }

  let skipWrappedFunction = null;
  try {
    await _executePreExecHooks(this);
  } catch (err) {
    if (err instanceof Kareem.skipWrappedFunction) {
      skipWrappedFunction = err;
    } else {
      throw err;
    }
  }

  let res;

  let error = null;
  try {
    await _executePreHooks(this);
    res = skipWrappedFunction ? skipWrappedFunction.args[0] : await this[thunk]();

    for (const fn of this._transforms) {
      res = fn(res);
    }
  } catch (err) {
    if (err instanceof Kareem.skipWrappedFunction) {
      res = err.args[0];
    } else {
      error = err;
    }

    error = this.model.schema._transformDuplicateKeyError(error);
  }

  res = await _executePostHooks(this, res, error);

  await _executePostExecHooks(this);

  return res;
};


function _executePostExecHooks(query) {
  return new Promise((resolve, reject) => {
    query._hooks.execPost('exec', query, [], {}, (error) => {
      if (error) {
        return reject(error);
      }

      resolve();
    });
  });
}


function _executePostHooks(query, res, error, op) {
  if (query._queryMiddleware == null) {
    if (error != null) {
      throw error;
    }
    return res;
  }

  return new Promise((resolve, reject) => {
    const opts = error ? { error } : {};

    query._queryMiddleware.execPost(op || query.op, query, [res], opts, (error, res) => {
      if (error) {
        return reject(error);
      }

      resolve(res);
    });
  });
}


function _executePreExecHooks(query) {
  return new Promise((resolve, reject) => {
    query._hooks.execPre('exec', query, [], (error) => {
      if (error != null) {
        return reject(error);
      }
      resolve();
    });
  });
}


function _executePreHooks(query, op) {
  if (query._queryMiddleware == null) {
    return;
  }

  return new Promise((resolve, reject) => {
    query._queryMiddleware.execPre(op || query.op, query, [], (error) => {
      if (error != null) {
        return reject(error);
      }
      resolve();
    });
  });
}


Query.prototype.then = function(resolve, reject) {
  return this.exec().then(resolve, reject);
};


Query.prototype.catch = function(reject) {
  return this.exec().then(null, reject);
};


Query.prototype.finally = function(onFinally) {
  return this.exec().finally(onFinally);
};


Query.prototype[Symbol.toStringTag] = function toString() {
  return `Query { ${this.op} }`;
};


Query.prototype.pre = function(fn) {
  this._hooks.pre('exec', fn);
  return this;
};


Query.prototype.post = function(fn) {
  this._hooks.post('exec', fn);
  return this;
};


Query.prototype._castUpdate = function _castUpdate(obj) {
  let schema = this.schema;

  const discriminatorKey = schema.options.discriminatorKey;
  const baseSchema = schema._baseSchema ? schema._baseSchema : schema;
  if (this._mongooseOptions.overwriteDiscriminatorKey &&
      obj[discriminatorKey] != null &&
      baseSchema.discriminators) {
    const _schema = Object.values(baseSchema.discriminators).find(
      discriminator => discriminator.discriminatorMapping.value === obj[discriminatorKey]
    );
    if (_schema != null) {
      schema = _schema;
    }
  }

  let upsert;
  if ('upsert' in this.options) {
    upsert = this.options.upsert;
  }

  return castUpdate(schema, obj, {
    strict: this._mongooseOptions.strict,
    upsert: upsert,
    arrayFilters: this.options.arrayFilters,
    overwriteDiscriminatorKey: this._mongooseOptions.overwriteDiscriminatorKey,
    overwriteImmutable: this._mongooseOptions.overwriteImmutable
  }, this, this._conditions);
};


Query.prototype.populate = function() {
  const args = Array.from(arguments);
  
  if (!args.some(Boolean)) {
    return this;
  }

  const res = utils.populate.apply(null, args);

  
  
  if (this.options != null) {
    const readConcern = this.options.readConcern;
    const readPref = this.options.readPreference;

    for (const populateOptions of res) {
      if (readConcern != null && (populateOptions && populateOptions.options && populateOptions.options.readConcern) == null) {
        populateOptions.options = populateOptions.options || {};
        populateOptions.options.readConcern = readConcern;
      }
      if (readPref != null && (populateOptions && populateOptions.options && populateOptions.options.readPreference) == null) {
        populateOptions.options = populateOptions.options || {};
        populateOptions.options.readPreference = readPref;
      }
    }
  }

  const opts = this._mongooseOptions;

  if (opts.lean != null) {
    const lean = opts.lean;
    for (const populateOptions of res) {
      if ((populateOptions && populateOptions.options && populateOptions.options.lean) == null) {
        populateOptions.options = populateOptions.options || {};
        populateOptions.options.lean = lean;
      }
    }
  }

  if (!utils.isObject(opts.populate)) {
    opts.populate = {};
  }

  const pop = opts.populate;

  for (const populateOptions of res) {
    const path = populateOptions.path;
    if (pop[path] && pop[path].populate && populateOptions.populate) {
      populateOptions.populate = pop[path].populate.concat(populateOptions.populate);
    }

    pop[populateOptions.path] = populateOptions;
  }
  return this;
};


Query.prototype.getPopulatedPaths = function getPopulatedPaths() {
  const obj = this._mongooseOptions.populate || {};
  const ret = Object.keys(obj);
  for (const path of Object.keys(obj)) {
    const pop = obj[path];
    if (!Array.isArray(pop.populate)) {
      continue;
    }
    _getPopulatedPaths(ret, pop.populate, path + '.');
  }
  return ret;
};


function _getPopulatedPaths(list, arr, prefix) {
  for (const pop of arr) {
    list.push(prefix + pop.path);
    if (!Array.isArray(pop.populate)) {
      continue;
    }
    _getPopulatedPaths(list, pop.populate, prefix + pop.path + '.');
  }
}


Query.prototype.cast = function(model, obj) {
  obj || (obj = this._conditions);
  model = model || this.model;
  const discriminatorKey = model.schema.options.discriminatorKey;
  if (obj != null &&
      obj.hasOwnProperty(discriminatorKey)) {
    model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;
  }

  const opts = { upsert: this.options && this.options.upsert };
  if (this.options) {
    if ('strict' in this.options) {
      opts.strict = this.options.strict;
    }
    if ('strictQuery' in this.options) {
      opts.strictQuery = this.options.strictQuery;
    }
  }
  if ('sanitizeFilter' in this._mongooseOptions) {
    opts.sanitizeFilter = this._mongooseOptions.sanitizeFilter;
  }

  try {
    return cast(model.schema, obj, opts, this);
  } catch (err) {
    
    if (typeof err.setModel === 'function') {
      err.setModel(model);
    }
    throw err;
  }
};


Query.prototype._castFields = function _castFields(fields) {
  let selected,
      elemMatchKeys,
      keys,
      key,
      out;

  if (fields) {
    keys = Object.keys(fields);
    elemMatchKeys = [];

    
    for (let i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (fields[key].$elemMatch) {
        selected || (selected = {});
        selected[key] = fields[key];
        elemMatchKeys.push(key);
      }
    }
  }

  if (selected) {
    
    try {
      out = this.cast(this.model, selected);
    } catch (err) {
      return err;
    }

    
    for (let i = 0; i < elemMatchKeys.length; ++i) {
      key = elemMatchKeys[i];
      fields[key] = out[key];
    }
  }

  return fields;
};


Query.prototype._applyPaths = function applyPaths() {
  if (!this.model) {
    return;
  }
  this._fields = this._fields || {};

  let sanitizeProjection = undefined;
  if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, 'sanitizeProjection')) {
    sanitizeProjection = this.model.db.options.sanitizeProjection;
  } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, 'sanitizeProjection')) {
    sanitizeProjection = this.model.base.options.sanitizeProjection;
  } else {
    sanitizeProjection = this._mongooseOptions.sanitizeProjection;
  }

  const schemaLevelProjections = this._mongooseOptions.schemaLevelProjections ?? true;

  if (schemaLevelProjections) {
    helpers.applyPaths(this._fields, this.model.schema, sanitizeProjection);
  }

  let _selectPopulatedPaths = true;

  if ('selectPopulatedPaths' in this.model.base.options) {
    _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;
  }
  if ('selectPopulatedPaths' in this.model.schema.options) {
    _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;
  }

  if (_selectPopulatedPaths) {
    selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);
  }
};


Query.prototype.cursor = function cursor(opts) {
  if (opts) {
    this.setOptions(opts);
  }

  try {
    this.cast(this.model);
  } catch (err) {
    return (new QueryCursor(this))._markError(err);
  }

  return new QueryCursor(this);
};




Query.prototype.tailable = function(val, opts) {
  
  
  if (val != null && typeof val.constructor === 'function' && val.constructor.name === 'Object') {
    opts = val;
    val = true;
  }

  if (val === undefined) {
    val = true;
  }

  if (opts && typeof opts === 'object') {
    for (const key of Object.keys(opts)) {
      if (key === 'awaitData' || key === 'awaitdata') { 
        
        this.options['awaitData'] = !!opts[key];
      } else {
        this.options[key] = opts[key];
      }
    }
  }

  this.options.tailable = arguments.length ? !!val : true;

  return this;
};





Query.prototype.near = function() {
  const params = [];
  const sphere = this._mongooseOptions.nearSphere;

  

  if (arguments.length === 1) {
    if (Array.isArray(arguments[0])) {
      params.push({ center: arguments[0], spherical: sphere });
    } else if (typeof arguments[0] === 'string') {
      
      params.push(arguments[0]);
    } else if (utils.isObject(arguments[0])) {
      if (typeof arguments[0].spherical !== 'boolean') {
        arguments[0].spherical = sphere;
      }
      params.push(arguments[0]);
    } else {
      throw new TypeError('invalid argument');
    }
  } else if (arguments.length === 2) {
    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
      params.push({ center: [arguments[0], arguments[1]], spherical: sphere });
    } else if (typeof arguments[0] === 'string' && Array.isArray(arguments[1])) {
      params.push(arguments[0]);
      params.push({ center: arguments[1], spherical: sphere });
    } else if (typeof arguments[0] === 'string' && utils.isObject(arguments[1])) {
      params.push(arguments[0]);
      if (typeof arguments[1].spherical !== 'boolean') {
        arguments[1].spherical = sphere;
      }
      params.push(arguments[1]);
    } else {
      throw new TypeError('invalid argument');
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[0] === 'string' && typeof arguments[1] === 'number'
        && typeof arguments[2] === 'number') {
      params.push(arguments[0]);
      params.push({ center: [arguments[1], arguments[2]], spherical: sphere });
    } else {
      throw new TypeError('invalid argument');
    }
  } else {
    throw new TypeError('invalid argument');
  }

  return Query.base.near.apply(this, params);
};


Query.prototype.nearSphere = function() {
  this._mongooseOptions.nearSphere = true;
  this.near.apply(this, arguments);
  return this;
};


if (Symbol.asyncIterator != null) {
  Query.prototype[Symbol.asyncIterator] = function() {
    return this.cursor().transformNull()._transformForAsyncIterator();
  };
}




Query.prototype.box = function(ll, ur) {
  if (!Array.isArray(ll) && utils.isObject(ll)) {
    ur = ll.ur;
    ll = ll.ll;
  }
  return Query.base.box.call(this, ll, ur);
};



Query.prototype.center = Query.base.circle;


Query.prototype.centerSphere = function() {
  if (arguments[0] != null && typeof arguments[0].constructor === 'function' && arguments[0].constructor.name === 'Object') {
    arguments[0].spherical = true;
  }

  if (arguments[1] != null && typeof arguments[1].constructor === 'function' && arguments[1].constructor.name === 'Object') {
    arguments[1].spherical = true;
  }

  Query.base.circle.apply(this, arguments);
};



Query.prototype.selectedInclusively = function selectedInclusively() {
  return isInclusive(this._fields);
};


Query.prototype.selectedExclusively = function selectedExclusively() {
  return isExclusive(this._fields);
};


Query.prototype.model;


module.exports = Query;


'use strict';

const MongooseError = require('../error/mongooseError');
const Readable = require('stream').Readable;
const eachAsync = require('../helpers/cursor/eachAsync');
const immediate = require('../helpers/immediate');
const kareem = require('kareem');
const util = require('util');


function AggregationCursor(agg) {
  
  
  Readable.call(this, { autoDestroy: true, objectMode: true });

  this.cursor = null;
  this.agg = agg;
  this._transforms = [];
  const connection = agg._connection;
  const model = agg._model;
  delete agg.options.cursor.useMongooseAggCursor;
  this._mongooseOptions = {};

  if (connection) {
    this.cursor = connection.db.aggregate(agg._pipeline, agg.options || {});
    setImmediate(() => this.emit('cursor', this.cursor));
  } else {
    _init(model, this, agg);
  }
}

util.inherits(AggregationCursor, Readable);


function _init(model, c, agg) {
  if (!model.collection.buffer) {
    model.hooks.execPre('aggregate', agg, function(err) {
      if (err != null) {
        _handlePreHookError(c, err);
        return;
      }
      if (typeof agg.options?.cursor?.transform === 'function') {
        c._transforms.push(agg.options.cursor.transform);
      }

      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
      c.emit('cursor', c.cursor);
    });
  } else {
    model.collection.emitter.once('queue', function() {
      model.hooks.execPre('aggregate', agg, function(err) {
        if (err != null) {
          _handlePreHookError(c, err);
          return;
        }

        if (typeof agg.options?.cursor?.transform === 'function') {
          c._transforms.push(agg.options.cursor.transform);
        }

        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
        c.emit('cursor', c.cursor);
      });
    });
  }
}


function _handlePreHookError(queryCursor, err) {
  if (err instanceof kareem.skipWrappedFunction) {
    const resultValue = err.args[0];
    if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {
      const err = new MongooseError(
        'Cannot `skipMiddlewareFunction()` with a value when using ' +
        '`.aggregate().cursor()`, value must be nullish or empty array, got "' +
        util.inspect(resultValue) +
        '".'
      );
      queryCursor._markError(err);
      queryCursor.listeners('error').length > 0 && queryCursor.emit('error', err);
      return;
    }
    queryCursor.emit('cursor', null);
    return;
  }
  queryCursor._markError(err);
  queryCursor.listeners('error').length > 0 && queryCursor.emit('error', err);
}



AggregationCursor.prototype._read = function() {
  const _this = this;
  _next(this, function(error, doc) {
    if (error) {
      return _this.emit('error', error);
    }
    if (!doc) {
      _this.push(null);
      _this.cursor.close(function(error) {
        if (error) {
          return _this.emit('error', error);
        }
      });
      return;
    }
    _this.push(doc);
  });
};

if (Symbol.asyncIterator != null) {
  const msg = 'Mongoose does not support using async iterators with an ' +
    'existing aggregation cursor. See https:

  AggregationCursor.prototype[Symbol.asyncIterator] = function() {
    throw new MongooseError(msg);
  };
}


Object.defineProperty(AggregationCursor.prototype, 'map', {
  value: function(fn) {
    this._transforms.push(fn);
    return this;
  },
  enumerable: true,
  configurable: true,
  writable: true
});


AggregationCursor.prototype._markError = function(error) {
  this._error = error;
  return this;
};


AggregationCursor.prototype.close = async function close() {
  if (typeof arguments[0] === 'function') {
    throw new MongooseError('AggregationCursor.prototype.close() no longer accepts a callback');
  }
  try {
    await this.cursor.close();
  } catch (error) {
    this.listeners('error').length > 0 && this.emit('error', error);
    throw error;
  }
  this.emit('close');
};


AggregationCursor.prototype._destroy = function _destroy(_err, callback) {
  let waitForCursor = null;
  if (!this.cursor) {
    waitForCursor = new Promise((resolve) => {
      this.once('cursor', resolve);
    });
  } else {
    waitForCursor = Promise.resolve();
  }

  waitForCursor
    .then(() => this.cursor.close())
    .then(() => {
      this._closed = true;
      callback();
    })
    .catch(error => {
      callback(error);
    });
  return this;
};


AggregationCursor.prototype.next = async function next() {
  if (typeof arguments[0] === 'function') {
    throw new MongooseError('AggregationCursor.prototype.next() no longer accepts a callback');
  }
  return new Promise((resolve, reject) => {
    _next(this, (err, res) => {
      if (err != null) {
        return reject(err);
      }
      resolve(res);
    });
  });
};


AggregationCursor.prototype.eachAsync = function(fn, opts) {
  if (typeof arguments[2] === 'function') {
    throw new MongooseError('AggregationCursor.prototype.eachAsync() no longer accepts a callback');
  }
  const _this = this;
  if (typeof opts === 'function') {
    opts = {};
  }
  opts = opts || {};

  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts);
};


if (Symbol.asyncIterator != null) {
  AggregationCursor.prototype[Symbol.asyncIterator] = function() {
    return this.transformNull()._transformForAsyncIterator();
  };
}


AggregationCursor.prototype._transformForAsyncIterator = function() {
  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
    this.map(_transformForAsyncIterator);
  }
  return this;
};


AggregationCursor.prototype.transformNull = function(val) {
  if (arguments.length === 0) {
    val = true;
  }
  this._mongooseOptions.transformNull = val;
  return this;
};


function _transformForAsyncIterator(doc) {
  return doc == null ? { done: true } : { value: doc, done: false };
}


AggregationCursor.prototype.addCursorFlag = function(flag, value) {
  const _this = this;
  _waitForCursor(this, function() {
    _this.cursor.addCursorFlag(flag, value);
  });
  return this;
};


function _waitForCursor(ctx, cb) {
  if (ctx.cursor) {
    return cb();
  }
  ctx.once('cursor', function() {
    cb();
  });
}


function _next(ctx, cb) {
  let callback = cb;
  if (ctx._transforms.length) {
    callback = function(err, doc) {
      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {
        return cb(err, doc);
      }
      cb(err, ctx._transforms.reduce(function(doc, fn) {
        return fn(doc);
      }, doc));
    };
  }

  if (ctx._error) {
    return immediate(function() {
      callback(ctx._error);
    });
  }

  if (ctx.cursor) {
    return ctx.cursor.next().then(
      doc => {
        if (!doc) {
          return callback(null, null);
        }

        callback(null, doc);
      },
      err => callback(err)
    );
  } else {
    ctx.once('error', cb);
    ctx.once('cursor', function() {
      _next(ctx, cb);
    });
  }
}

module.exports = AggregationCursor;

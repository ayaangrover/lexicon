
'use strict';

const MongooseError = require('../error/mongooseError');
const Readable = require('stream').Readable;
const eachAsync = require('../helpers/cursor/eachAsync');
const helpers = require('../queryHelpers');
const kareem = require('kareem');
const immediate = require('../helpers/immediate');
const { once } = require('events');
const util = require('util');


function QueryCursor(query) {
  
  
  Readable.call(this, { autoDestroy: true, objectMode: true });

  this.cursor = null;
  this.skipped = false;
  this.query = query;
  this._closed = false;
  const model = query.model;
  this._mongooseOptions = {};
  this._transforms = [];
  this.model = model;
  this.options = {};
  model.hooks.execPre('find', query, (err) => {
    if (err != null) {
      if (err instanceof kareem.skipWrappedFunction) {
        const resultValue = err.args[0];
        if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {
          const err = new MongooseError(
            'Cannot `skipMiddlewareFunction()` with a value when using ' +
            '`.find().cursor()`, value must be nullish or empty array, got "' +
            util.inspect(resultValue) +
            '".'
          );
          this._markError(err);
          this.listeners('error').length > 0 && this.emit('error', err);
          return;
        }
        this.skipped = true;
        this.emit('cursor', null);
        return;
      }
      this._markError(err);
      this.listeners('error').length > 0 && this.emit('error', err);
      return;
    }
    Object.assign(this.options, query._optionsForExec());
    this._transforms = this._transforms.concat(query._transforms.slice());
    if (this.options.transform) {
      this._transforms.push(this.options.transform);
    }
    
    
    if (this.options.batchSize) {
      
      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);
    }

    if (model.collection._shouldBufferCommands() && model.collection.buffer) {
      model.collection.queue.push([
        () => _getRawCursor(query, this)
      ]);
    } else {
      _getRawCursor(query, this);
    }
  });
}

util.inherits(QueryCursor, Readable);


function _getRawCursor(query, queryCursor) {
  try {
    const cursor = query.model.collection.find(query._conditions, queryCursor.options);
    queryCursor.cursor = cursor;
    queryCursor.emit('cursor', cursor);
  } catch (err) {
    queryCursor._markError(err);
    queryCursor.listeners('error').length > 0 && queryCursor.emit('error', queryCursor._error);
  }
}


QueryCursor.prototype._read = function() {
  _next(this, (error, doc) => {
    if (error) {
      return this.emit('error', error);
    }
    if (!doc) {
      this.push(null);
      this.cursor.close(function(error) {
        if (error) {
          return this.emit('error', error);
        }
      });
      return;
    }
    this.push(doc);
  });
};


QueryCursor.prototype.getDriverCursor = async function getDriverCursor() {
  if (this.cursor) {
    return this.cursor;
  }

  await once(this, 'cursor');
  return this.cursor;
};


Object.defineProperty(QueryCursor.prototype, 'map', {
  value: function(fn) {
    this._transforms.push(fn);
    return this;
  },
  enumerable: true,
  configurable: true,
  writable: true
});


QueryCursor.prototype._markError = function(error) {
  this._error = error;
  return this;
};


QueryCursor.prototype.close = async function close() {
  if (typeof arguments[0] === 'function') {
    throw new MongooseError('QueryCursor.prototype.close() no longer accepts a callback');
  }
  try {
    await this.cursor.close();
    this._closed = true;
    this.emit('close');
  } catch (error) {
    this.listeners('error').length > 0 && this.emit('error', error);
    throw error;
  }
};


QueryCursor.prototype._destroy = function _destroy(_err, callback) {
  let waitForCursor = null;
  if (!this.cursor) {
    waitForCursor = new Promise((resolve) => {
      this.once('cursor', resolve);
    });
  } else {
    waitForCursor = Promise.resolve();
  }

  waitForCursor
    .then(() => {
      this.cursor.close();
    })
    .then(() => {
      this._closed = true;
      callback();
    })
    .catch(error => {
      callback(error);
    });
  return this;
};


QueryCursor.prototype.rewind = function() {
  _waitForCursor(this, () => {
    this.cursor.rewind();
  });
  return this;
};


QueryCursor.prototype.next = async function next() {
  if (typeof arguments[0] === 'function') {
    throw new MongooseError('QueryCursor.prototype.next() no longer accepts a callback');
  }
  if (this._closed) {
    throw new MongooseError('Cannot call `next()` on a closed cursor');
  }
  return new Promise((resolve, reject) => {
    _next(this, function(error, doc) {
      if (error) {
        return reject(error);
      }
      resolve(doc);
    });
  });
};


QueryCursor.prototype.eachAsync = function(fn, opts) {
  if (typeof arguments[2] === 'function') {
    throw new MongooseError('QueryCursor.prototype.eachAsync() no longer accepts a callback');
  }
  if (typeof opts === 'function') {
    opts = {};
  }
  opts = opts || {};

  return eachAsync((cb) => _next(this, cb), fn, opts);
};


QueryCursor.prototype.options;


QueryCursor.prototype.addCursorFlag = function(flag, value) {
  _waitForCursor(this, () => {
    this.cursor.addCursorFlag(flag, value);
  });
  return this;
};


QueryCursor.prototype.transformNull = function(val) {
  if (arguments.length === 0) {
    val = true;
  }
  this._mongooseOptions.transformNull = val;
  return this;
};


QueryCursor.prototype._transformForAsyncIterator = function() {
  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
    this.map(_transformForAsyncIterator);
  }
  return this;
};


if (Symbol.asyncIterator != null) {
  QueryCursor.prototype[Symbol.asyncIterator] = function() {
    return this.transformNull()._transformForAsyncIterator();
  };
}


function _transformForAsyncIterator(doc) {
  return doc == null ? { done: true } : { value: doc, done: false };
}


function _next(ctx, cb) {
  let callback = cb;
  if (ctx._transforms.length) {
    callback = function(err, doc) {
      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {
        return cb(err, doc);
      }
      cb(err, ctx._transforms.reduce(function(doc, fn) {
        return fn.call(ctx, doc);
      }, doc));
    };
  }

  if (ctx._error) {
    return immediate(function() {
      callback(ctx._error);
    });
  }
  if (ctx.skipped) {
    return immediate(() => callback(null, null));
  }

  if (ctx.cursor) {
    if (ctx.query._mongooseOptions.populate && !ctx._pop) {
      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query,
        ctx.query._mongooseOptions);
      ctx._pop.__noPromise = true;
    }
    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {
      if (ctx._batchDocs && ctx._batchDocs.length) {
        
        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);
      } else if (ctx._batchExhausted) {
        
        return callback(null, null);
      } else {
        
        ctx._batchDocs = [];
        ctx.cursor.next().then(
          res => { _onNext.call({ ctx, callback }, null, res); },
          err => { _onNext.call({ ctx, callback }, err); }
        );
        return;
      }
    } else {
      return ctx.cursor.next().then(
        doc => {
          if (!doc) {
            callback(null, null);
            return;
          }

          if (!ctx.query._mongooseOptions.populate) {
            return _nextDoc(ctx, doc, null, callback);
          }

          ctx.query.model.populate(doc, ctx._pop).then(
            doc => {
              _nextDoc(ctx, doc, ctx._pop, callback);
            },
            err => {
              callback(err);
            }
          );
        },
        error => {
          callback(error);
        }
      );
    }
  } else {
    ctx.once('error', cb);

    ctx.once('cursor', function(cursor) {
      ctx.removeListener('error', cb);
      if (cursor == null) {
        if (ctx.skipped) {
          return cb(null, null);
        }
        return;
      }
      _next(ctx, cb);
    });
  }
}


function _onNext(error, doc) {
  if (error) {
    return this.callback(error);
  }
  if (!doc) {
    this.ctx._batchExhausted = true;
    return _populateBatch.call(this);
  }

  this.ctx._batchDocs.push(doc);

  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {
    
    
    immediate(() => this.ctx.cursor.next().then(
      res => { _onNext.call(this, null, res); },
      err => { _onNext.call(this, err); }
    ));
  } else {
    _populateBatch.call(this);
  }
}


function _populateBatch() {
  if (!this.ctx._batchDocs.length) {
    return this.callback(null, null);
  }
  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop).then(
    () => {
      _nextDoc(this.ctx, this.ctx._batchDocs.shift(), this.ctx._pop, this.callback);
    },
    err => {
      this.callback(err);
    }
  );
}


function _nextDoc(ctx, doc, pop, callback) {
  if (ctx.query._mongooseOptions.lean) {
    return ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {
      if (err != null) {
        return callback(err);
      }
      callback(null, doc);
    });
  }

  const { model, _fields, _userProvidedFields, options } = ctx.query;
  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {
    if (err != null) {
      return callback(err);
    }
    ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {
      if (err != null) {
        return callback(err);
      }
      callback(null, doc);
    });
  });
}


function _waitForCursor(ctx, cb) {
  if (ctx.cursor) {
    return cb();
  }
  ctx.once('cursor', function(cursor) {
    if (cursor == null) {
      return;
    }
    cb();
  });
}

module.exports = QueryCursor;

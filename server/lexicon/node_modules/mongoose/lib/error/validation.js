
'use strict';

const MongooseError = require('./mongooseError');
const getConstructorName = require('../helpers/getConstructorName');
const util = require('util');
const combinePathErrors = require('../helpers/error/combinePathErrors');


class ValidationError extends MongooseError {

  constructor(instance) {
    let _message;
    if (getConstructorName(instance) === 'model') {
      _message = instance.constructor.modelName + ' validation failed';
    } else {
      _message = 'Validation failed';
    }

    super(_message);

    this.errors = {};
    this._message = _message;

    if (instance) {
      instance.$errors = this.errors;
    }
  }

  toString() {
    return this.name + ': ' + combinePathErrors(this);
  }

  inspect() {
    return Object.assign(new Error(this.message), this);
  }

  addError(path, error) {
    if (error instanceof ValidationError) {
      const { errors } = error;
      for (const errorPath of Object.keys(errors)) {
        this.addError(`${path}.${errorPath}`, errors[errorPath]);
      }

      return;
    }

    this.errors[path] = error;
    this.message = this._message + ': ' + combinePathErrors(this);
  }
}


if (util.inspect.custom) {
  
  ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;
}

Object.defineProperty(ValidationError.prototype, 'toJSON', {
  enumerable: false,
  writable: false,
  configurable: true,
  value: function() {
    return Object.assign({}, this, { name: this.name, message: this.message });
  }
});


Object.defineProperty(ValidationError.prototype, 'name', {
  value: 'ValidationError'
});


module.exports = ValidationError;
